% Institute of Computer Science thesis template
% authors: Sven Laur, Liina Kamm
% last change Tõnu Tamme 09.05.2017
\documentclass[12pt]{article}
\usepackage{CormorantGaramond}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english, estonian]{babel}
\usepackage[labelsep = period]{caption}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{inconsolata}
\usepackage[utf8x]{inputenc}
\usepackage{pifont}
\usepackage{verbatim}
\addto\captionsestonian{
  \renewcommand\refname{Viidatud kirjandus}}
\bibliographystyle{plain}
\def\linnuke{\ding{51}}
\def\pealkiri{Funktsionaalse programmeerimiskeele liigisüsteem}
\definecolor{ereroheline}{RGB}{0,255,0}
\definecolor{hall}{RGB}{128,128,128}
\definecolor{helehall}{RGB}{192,192,192}
\definecolor{must}{RGB}{0,0,0}
\definecolor{roheline}{RGB}{0,128,0}
\newcommand\peatykk[1]{
  \clearpage
  \section{#1}}
\newcommand\peatykktarn[1]{
  \clearpage
  \section*{#1}
  \addcontentsline{toc}{section}{#1}}
\newcommand\markus[1]{\textcolor{roheline}{\textbf{#1}}}
\begin{document}
  \thispagestyle{empty}
  \begin{center}
    \large
      TARTU ÜLIKOOL\\
      Arvutiteaduse instituut\\
      Informaatika õppekava

    \vspace{25mm}

    \Large
      Liisi Kerik

    \vspace{4mm}

    \huge
      \pealkiri

    \vspace{20mm}

    \Large
      Magistritöö (30 EAP)
  \end{center}

  \vspace{2mm}

  \begin{flushright}
    \begin{tabular}{rl} 
      Juhendaja: & Härmel Nestra, PhD
    \end{tabular}
  \end{flushright}
  \vfill
  \centerline{Tartu 2018}
  \newpage
  \noindent
  \textbf{\large\pealkiri}

  \vspace*{1ex}

  \noindent
  \textbf{Lühikokkuvõte:} 

  \noindent
  Staatilised tüübisüsteemid võimaldavad leida programmidest teatud vigu juba enne koodi käivitamist ja aitavad seega kaasa töökindlama koodi kirjutamisele. Paljud funktsionaalsed keeled, näiteks Haskell ja Idris, on staatiliselt tüübitud.

  Mida väljendusrikkam on keele tüübisüsteem, seda rohkem vigu on võimalik juba tüübikontrolli ajal leida. Osad keeled, näiteks Idris, kasutavad sõltuvaid tüüpe, mis muudavad tüübisüsteemi võimsaks aga ka keeruliseks. Hiljuti Haskellis sisse toodud edutamine võimaldab tõsta tüübisüsteemi väljendusrikkust ilma sõltuvate tüüpideta.

  Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud funktsionaalne programmeerimiskeel, mille tüübisüsteemi on rikastatud edutamise abil.

  Käsoleva töö tulemuseks olev keel Awful näitab, et edutamise teel saadud liikide ja tüüpidele on palju kasulikke rakendusi ka keeles, milles puuduvad üldistatud algebralised andmetüübid.

  Awful kasutab üldistatud algebraliste andmetüüpide abil piiravamat aga oluliselt lihtsamat uut andmetüüpide konstrueerimise viisi. \textit{Hargnevad andmetüübid} võimaldavad konstrueerida paljusid kasulikke tüüpe, näiteks staatilise pikkusega vektoreid, mille jaoks Haskellis või Idrises kasutataks üldistatud algebralisi andmetüüpe.

  \vspace*{1ex}

  \noindent
  \textbf{Võtmesõnad:} andmetüübid ja struktuurid, funktsionaalprogrammeerimine, liigid, polümorfism, edutamine, tüübisüsteemid

  \vspace*{1ex}

  \noindent
  \textbf{CERCS:} P175 Informaatika, süsteemiteooria

  \vspace*{3ex}

  {
    \selectlanguage{english}
    \noindent
    \textbf{\large A Kind System for a Functional Programming Language}

    \vspace*{1ex}

    \noindent
    \textbf{Abstract:}

    \noindent
    Static type systems find some classes of bugs before the program is run, therefore assisting in writing safer code. Many functional languages, for example, Haskell and Idris, are statically typed.

    The more expressive a language's type system is, the more bugs can be found during type checking. Some languages, for example, Idris, use dependent types, which result in an expressive albeit complex type system. Promotion, which has been recently introduced in Haskell, improves the expressiveness of the type system without resorting to dependent types.

    The aim of this work was to develop a statically typed functional language with a type system that has been enriched via promotion.

    The language which is the result of this work, Awful, shows that promoted kinds and types have many useful applications even in a language that does not have generalised algebraic data types.

    Instead of generalised algebraic data types Awful employs a more restrictive but also considerably simpler new way of constructing new data types. \textit{Branching data types} enable construction of many useful types, like statically sized vectors, for which we would use generalised algebraic data types in Haskell or Idris.

    \vspace*{1ex}

    \noindent
    \textbf{Keywords:} data types and structures, functional programming, kinds, polymorphism, promotion, type systems

    \vspace*{1ex}

    \noindent
    \textbf{CERCS:} P175 Informatics, systems theory

    \vspace*{1ex}}
  \newpage
  \tableofcontents
  \peatykktarn{Tänusõnad}
    
  \peatykk{Sissejuhatus}
    Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud funktsionaalne programmeerimiskeel. Dünaamiliselt tüübitud keeltes, nagu näiteks Python ja Wolfram Language~\cite{Wol}, selguvad kõik vead programmi töö käigus. Klassikalisteks näideteks vigadest, mis programmi töö käigus juhtuda võivad, on funktsiooni kutsumine vale tüüpi argumendi peal, massiivi indekseerimine liiga suure arvuga või nulliga jagamine. Staatiliselt tüübitud keeltes, nagu Haskell~\cite{Gla} ja Idris~\cite{The_Idr}, aitab tüübikontroll ennetada osasid programmi jooksutamise käigus tekkivaid vigu ja soovimatut käitumist. Staatiline tüübikontroll muudab koodi tüübiturvalisemaks.

    Turingi-täieliku keele puhul ei saa tüübikontroll, mille termineerumine on alati tagatud, ennetada kõiki vigu, ilma samas osasid korrektseid programme kõrvale heitmata. See tähendab, et iga tüübikontrolli-algoritm, mis alati termineerub ja on täielik (kiidab heaks kõik korrektsed programmid), peab lubama osasid ebakorrektseid programme~\cite{Typ}. Mida väljendusrikkam on tüübisüsteem, seda rohkem vigu on võimalik ennetada. Näiteks on osades programmeerimiskeeltes massiivide pikkuste ja indekseerimisega seotud vead dünaamilised, aga osades keeltes on saadaval staatilise pikkusega vektorid, mille puhul vektori pikkus on märgitud tema tüübis ja seega näiteks programm, kus üritatakse leida skalaarkorrutist kahest erineva pikkusega vektorist, tunnistatakse ebakorrektseks juba enne käivitamist.

    Kuna staatiline tüübikontroll ennetab osasid programmi töö käigus tekkivaid vigu, vähendab see soovimatu käitumise, programmi kokku jooksmise ja turvaaukude ohtu. Seega on tüübisüsteemid suure praktilise tähtsusega.

    Käesoleva töö tulemuseks on staatiliselt tüübitud puhas funktsionaalne programmeerimiskeel nimega Awful. Awfuli tüübisüsteem sisaldab parameetrilist polümorfismi ja ühe muutuja tüübiklasse ning tüübisüsteemi on rikastatud edutamise abil, võttes eeskuju Haskellist~\cite{Giv}. Üks oluline erinevus teistest keeltest on andmetüübid. Kui Haskellis on olemas algebralised andmetüübid ja üldistatud algebralised andmetüübid, siis Awfuli viis lasta kasutajal uusi andmetüüpe deklareerida on oluliselt erinev. Awful toob sisse \textit{hargnevad andmetüübid}, mis on piiravamad kui üldistatud algebralised andmetüübid aga on samas ka oluliselt lihtsamad ja paljude rakenduste jaoks piisavad.

    Käesolevas töös alustame sellest, et kirjutame tüübiklassidest ning võrdleme, millised omadused on Haskelli ja Awfuli tüübiklassidel. Meenutame lühidalt üldistatud algebralisi andmetüüpe, tutvustame tüübitaseme andmeid ja edutamist ning toome näiteid sellest, kuidas edutamine muudab tüübisüsteemi väljendusrikkamaks. Meenutame lühidalt ka sõltuvaid tüüpe ja vaatleme, kuidas need võrdlevad edutamisega.

    Töö teises pooles tutvustame käesoleva töö teemaks olevat keelt Awfulit. Spetsifitseerime keele süntaksi. Kirjeldame keelt, põhjendame disainivalikuid ja toome koodinäiteid. Viimases peatükis räägime täiendustest ja parandustest, mida on tulevikus kavas teostada. Peamised plaanitavad muudatused on liikide käsitlemine kategooriatena ning klasside käsitlemine alamliikidena, aga lisaks ka väiksemad keele kasutusmugavuse seisukohast olulised aspektid.
  \peatykk{\textit{Ad hoc} polümorfism ja tüübiklassid}
    Parameetriline polümorfism võimaldab käsitleda koos andmeid, millel on sama struktuur aga erinevat tüüpi sisu. Näiteks ei ole tarvis keeles, kus on olemas parameetriline polümorfism, luua kahte erinevat andmetüüpi tähtede listide ja täisarvude listide jaoks. Selle asemel võib luua parametriseeritud andmetüübi, mille abil saab konstrueerida ükskõik millise sisuga liste. Sellise andmetüübi jaoks saab kirjutada ka parameetriliselt polümorfseid funktsioone. Näiteks käitub listide konkateneerimine samamoodi olenemata sellest, kas konkateneerime tähtede või täisarvude liste.

    Parameetriline polümorfism ei ole ainus polümorfismi liik mida programmeerimiskeeled kasutavad. Teine oluline abstraktsioon on \textit{ad hoc} polümorfism~\cite{Fun}.
    \subsection{\textit{Ad hoc} polümorfism}\label{peidetudargumendid}
      Kui parameetrilise polümorfismi korral tegeleme andmete ja funktsioonidega, millel on samasugune struktuur ja käitumine olenemata sellest, mis tüüpi andmetega tegeletakse, siis \textit{ad hoc} polümorfism võimaldab kokku võtta funktsioone, millel on sarnane otstarve aga erinev käitumine, mis oleneb andmete tüübist.

      Üks lihtne näide on aritmeetikatehted. Aritmeetikatehteid on tarvis paljude erinevate struktuuride jaoks. Me võime liita ja korrutada täisarvusid, jäägiklassiringide elemente, loogikaväärtusi, vektoreid, kompleksarvusid, maatrikseid, harilikke murdusid, polünoome, kvaternione ja pajusid muid tüüpe. Kõigi puhul on liitmise ja korrutamise teostused erinevad, aga on ka olulisi ühiseid omadusi (näiteks see, et liitmise ja korrutamise vahel kehtib distributiivsus).

      On mugav, kui erinevate tüüpide peal töötavate aritmeetikatehete jaoks on võimalik kasutada samu funktsiooninimesid ja operaatoreid. Kontekstist on enamasti selge, mida liidetakse või korrutatakse, ning seega arvukalt erinevaid funktsiooninimesid või operaatoreid ainult muudab koodi pikemaks ja vähem loetavaks.

      Eriti kasulik on \textit{ad hoc} polümorfism siis, kui on tarvis parameetriliselt polümorfse funktsiooni sees erineva teostusega aga sarnase otstarbega funktsioone kasutada. Näiteks juhul kui Haskellis ei oleks \textit{ad hoc} polümorfismi, peaks vektorite liitmise funktsiooni kirja panema järgneval viisi:

      \begin{verbatim}add_array :: (t -> t -> t) -> Array n t -> Array n t -> Array n t
add_array _ Empty_Array Empty_Array = Empty_Array
add_array add_t (Construct_Array x a) (Construct_Array y b) =
  Construct_Array (add_t x y) (add_array add_t a b)\end{verbatim}

    Lisaargument \verb!add_t!, mis ütleb, kuidas täpselt vektorite elemente liita, tuleks anda igal \verb!add_array! kutsel. See muudaks koodi pikemaks. Õnneks on Haskellis, ja ka paljudes teistes keeltes, olemas \textit{ad hoc} polümorfism, mis võimaldab selle ebavajaliku lisaargumendi likvideerida -- erinevaid tüüpe saab liita sama funktsiooninime (või operaatoriga) ja keel suudab ise tuvastada, millist liitmist rakendada. Haskelli \textit{ad hoc} polümorfism on teostatud tüübiklasside kaudu~\cite{How}.
    \subsection{Tüübiklassid Haskellis}\label{haskklass}
      Toome alguses lihtsa näite tüübiklassist, selgitades, kuidas eelmise jaotise näide vektorite liitmisest tüübiklasside olemasolul muutub. Seejärel selgitame, millised piirangud Haskell tüübiklassidele seab.

      Kui tahame luua funktsiooni \verb!add!, mis töötaks erinevate andmetüüpide peal erinevalt, peab ta olema tüübiklassi meetod. Loomegi selle jaoks lihtsa, ühe meetodiga tüübiklassi \verb!Addible!. Tüübiklassid võivad sisaldada ka mitut meetodit, aga selles näites piirdume lühiduse huvides ainult ühega.

      \begin{verbatim}class Addible t where
  add :: t -> t -> t\end{verbatim}

      See klassideklaratsioon ütleb, et kui tüüp \verb!t! kuulub klassi \verb!Addible!, on tema jaoks defineeritud meetod \verb!add! tüüpi \verb!t -> t -> t!. Nüüd ütleme, et vektor on selle klassi \textit{esindaja} (ing. k. \textit{instance}).

      \begin{verbatim}instance Addible t => Addible (Array n t) where
  add Empty_Array Empty_Array = Empty_Array
  add (Construct_Array x a) (Construct_Array y b) =
    Construct_Array (add x y) (add a b)\end{verbatim}

      Esimene rida ütleb, et vektor üle tüübi \verb!t! on liidetav parajasti siis kui tüüp \verb!t! ise on liidetav. Järgmised kaks rida defineerivad meetodi \verb!add!. Erinevus võrreldes eelmise versiooniga on see, et nüüd ei ole enam vaja pikka tüübispetsiifilist funktsiooninime \verb!add_array! ega lisaargumenti \verb!add_t!. Kui varem oleksime pidanud täisarvuliste vektorite liitmiseks kutsuma funktsiooni \verb!add_array (+)!, siis nüüd piisab sellest, et kutsume lihtsalt funktsiooni \verb!add! ja Haskelli kompilaator tuletab ise, millist \verb!add! meetodi implementatsiooni on mõeldud ja milliseid lisaargumente ta vajab.

      Tüübiklasside puhul, nagu ka klasside puhul objektorienteeritud keeltes, on olemas pärilus. Toome näiteks Haskelli \verb!Control.Applicative! teegis defineeritud klassi \verb!Applicative!, mille esindajad peavad alati kuuluma ka klassi \verb!Functor!.

      \begin{verbatim}class Functor f => Applicative f where
  (<*>) :: f (t -> u) -> f t -> f u
  pure  :: t -> f t\end{verbatim}

      Rohkem näiteid tüübiklassidest, kasutades juba Awfuli süntaksit, on peatükis~\ref{manual}. Kirjeldame nüüd detailsemalt, milliseid võimalusi Haskelli tüübiklassid pakuvad ja millised piirangud on neile seatud.
      \subsubsection{Tüübiklassid Haskell 2010 standardis}\label{haskstd}
        Haskell 2010 standard spetsifitseerib tüübiklassid järgnevalt~\cite{Has}.
        \begin{itemize}
          \item
            Klassi deklaratsioon on kujul \verb!class! $cx$ \verb!=>! $C$ $u$ \verb!where! $cdecls$, kus $C$ on uue klassi nimi, $u$ on tüübimuutuja, $cx$ spetsifitseerib, mis klassid klass $C$ pärib (teisisõnu spetsifitseerib $C$ ülemklassid) ja $cdecls$ sisaldab klassi meetodeid.
          \item
            Ülemklasse spetsifitseerides tohib kasutada ainult tüübimuutujat $u$, mis on klassi deklareerides sisse toodud, ja mitte ühtegi teist tüüpi ega ka mitte mõnda uut tüübimuutujat. Näiteks ei tohi kirjutada

            \begin{verbatim}class Bug Int => Bug' t\end{verbatim}

            või

            \begin{verbatim}class Bug u => Bug' t\end{verbatim}
          \item
            Pärilussuhetes ei tohi tekkida tsüklit. Klasside pärilussuhted moodustavad suunatud atsüklilise graafi.
          \item
            Haskell võimaldab mitmest pärilust, ehk tüübiklassil võib olla rohkem kui üks vanem.

            \begin{verbatim}class (A t, B t) => C t\end{verbatim}
          \item
            Iga meetodi deklaratsioon on kujul $v_i$ \verb!::! $cx_i$ \verb!=>! $t_i$, kus $v_i$ on meetodi nimi, $t_i$ on meetodi tüüp ja $cx_i$ on tüübimuutujatele seatavate kitsenduste nimekiri.
          \item
            Tüüp $t_i$ peab sisaldama klassi päises sisse toodud tüübimuutujat $u$. Põhjuseks on see, et vastasel juhul ei ole võimalik klassi meetodi kutsel tuletada, millise tüübi jaoks mõeldud teostust kasutada. Toome näite, mis juhtuks, kui lubada meetodite tüüpe, mis ei vasta sellele kitsendusele.

            \begin{verbatim}class Bug t where
  bug :: Int
instance Bug Char where
  bug = 0
instance Bug Int where
  bug = 1\end{verbatim}

            Kui kasutatakse meetodit \verb!bug!, ei ole tüüpimisalgoritmil võimalik teada, kas tegu on meetodi \verb!bug! teostusega \verb!Char!, \verb!Int! või mõne muu tüübi jaoks. Seetõttu ei ole sellist avaldist ka võimalik väärtustada. Ka eksplitsiitne tüübiannotatsioon ei aita, sest sellise meetodi tüüp on sama kõigi teostuste korral.
          \item
            Kitsenduste nimekiri $cx_i$ tohib kitsendada ainult tüübimuutujaid, mis on sisse toodud tüübis $t_i$. Ei tohi kitsendada tüüpe, mis ei ole tüübimuutujad, näiteks

            \begin{verbatim}class Bug t where
  bug :: Bug' Int => t\end{verbatim}

            Ei tohi tuua kitsendustes sisse tüübimuutujaid, mida tüübis $t$ ei esine, näiteks

            \begin{verbatim}class Bug t where
  bug :: Bug' u => t\end{verbatim}

            Ei tohi kitsendada ka klassi päises deklareeritud tüübimuutujat $u$, näiteks

            \begin{verbatim}class Bug t where
  bug :: Bug' t => t\end{verbatim}
          \item
            $cdecls$ võib sisaldada ka operaatorite assotsieerumissuuna ja prioriteedi deklaratsioone (ing. k. \textit{fixity declaration}) ning vaikedefinitsioone klassi meetodite jaoks.
        \end{itemize}

        Klasside esindajad on spetsifitseeritud järgnevalt~\cite{Has}.

        \begin{itemize}
          \item
            Kui meil on klass nimega $C$, siis tema esindaja on kujul \verb!instance! $cx'$ \verb!=>! $C$ $(T$ $u_1$ \ldots $u_k)$ \verb!where! \verb!{!$d$\verb!}!, kus $k\in\mathbb{N}_0$. Kitsenduste nimekiri $cx'$ võimaldab kitsendada tüübikonstruktorile $T$ argumentiks antud tüübimuutujaid $u_1$ \ldots $u_k$. Plokk $d$ sisaldab klassi meetodite definitsioone tüübi $T$ jaoks. Juhul, kui ühtegi definitsiooni ei ole, võib võtmesõna \verb!where! ära jätta.
          \item
            Programmis ei tohi olla kahte sama klassi esindajat sama tüübi jaoks.
          \item
            Tüübikonstruktori $T$ argumendid $u_1$ \ldots $u_k$ peavad olema tüübimuutujad. Argumendiks ei tohi olla midagi muud, näiteks on keelatud selline esindaja:

            \begin{verbatim}instance Bug [Char]\end{verbatim}

            Nimetatud kitsendusega on seotud ka järgnev reegel.
          \item
            Klassi esindajat ei tohi luua tüübisünonüümi jaoks. $T$ peab olema tüübikonstruktor. Näiteks ei tohi klassi esindaja olla \verb!String!, sest tegu on sünonüümiga tüübile \verb![Char]! ning programmis võib olla ka klassi esindaja tüübi \verb![t]! jaoks.
          \item
            Tüübimuutujad $u_1$ \ldots $u_k$ peavad olema erinevad. Näiteks on keelatud selline esindaja:

            \begin{verbatim}instance Bug (t, t)\end{verbatim}
          \item
            Tüübi $T$ $u_1$ \ldots $u_k$ liik peab olema sama, mis klassi $C$ tüübimuutuja $u$ liik. Liikidest räägime täpsemalt jaotises~\ref{liiksort}. Seni aga toome ühe lihtsa näite liikide sobimatusest. Klass \verb!Functor! on mõeldud ühe argumendiga tüübikonstruktorite jaoks.

            \begin{verbatim}class Functor f where
  fmap :: (t -> u) -> f t -> f u\end{verbatim}

            Seda on näha meetodi \verb!fmap! signatuurist, kus tüübimuutuja \verb!f! võtab ühe argumendi. Seega peavad klassi \verb!Functor! esindajad olema tüübikonstruktorid, mis võtavad täpselt ühe argumendi (näiteks \verb!Maybe!, listi tüübikonstruktor, aga ka tüübikonstruktor \verb!Either t!). Järgmised kaks esindajat on keelatud, sest tüübid \verb!Int! ja \verb![t]! ei võta piisavalt argumente:

            \begin{verbatim}instance Functor Int
instance Functor [t]\end{verbatim}

            Järgmine esindaja on aga keelatud, sest \verb!Either!, millele ei ole argumendiks antud ühtegi tüübimuutujat, võtab mitte üks vaid kaks argumenti, seega liiga palju.

            \begin{verbatim}instance Functor Either\end{verbatim}

            Jaotises~\ref{liiksort} selgitame, kuidas liik võib olla ka palju keerulisem kui tüübikonstruktori argumentide arv, aga praeguseks piirdume ülalpool toodud lihtsate näitega.
          \item
            Tüüp $T$ $u_1$ \ldots $u_k$ kitsendustega $cx'$ peab olema ka kõigi $C$ ülemklasside esindaja. Näiteks kuna klass \verb!Functor! on klassi \verb!Applicative! ülemklass, ei tohi kirjutada klassi \verb!Applicative! esindajat ilma vastava \verb!Functor! esindajata. Lisaks tähendab see reegel, et ülemklassi esindajale ei tohi seada rangemaid kitsendusi kui alamklassi (päriva klassi) esindajale. Näiteks on keelatud järgmine kood:

            \begin{verbatim}class Bug t => Bug' t
instance Ord t => Bug [t]
instance Bug' [t]\end{verbatim}

            Selline kood ei ole lubatud, sest klass \verb!Bug! on klassi \verb!Bug'! ülemklass ning alati, kui tüübi peal kehtib kitsendus \verb!Bug'!, peaks järelikult kehtima ka \verb!Bug!.
          \item
            Kitsenduste nimekiri $cx'$ tohib kitsendada ainult tüübimuutujaid $u_1$ \ldots $u_k$. Keelatud on kitsendada tüüpe, mis ei ole tüübimuutujad:

            \begin{verbatim}instance Bug Int => Bug' [t]\end{verbatim}

            Samuti on keelatud kitsendustes uusi tüübimuutujaid sisse tuua:

            \begin{verbatim}instance Bug u => Bug' [t]\end{verbatim}
          \item
            Plokk $d$ tohib sisaldada ainult klassi $C$ meetodite definitsioone ning muud definitsioonid (ka operaatorite assotsieerumissuuna ja prioriteedi deklaratsioonid) on keelatud. Haskell lubab osade meetodite definitsioonid kirjutamata jätta. Juhul, kui defineerimata meetodi jaoks on olemas vaiketeostus, kasutatakse seda. Kui ei ole, on meetodi väärtus antud tüübi jaoks \verb!undefined!. 
          \item
            Ploki $d$ definitsioonid peavad vastama klassi deklaratsioonis toodud tüübisignatuuridele. Sealhulgas tähendab see, et meetodi $v_i$ definitsioon tüübi $T$ $u_1$ \ldots $u_k$ jaoks ei tohi nõuda rangemaid kitsendusi $t_i$ kui on määratud klassi deklaratsioonis tüübisignatuuris, kitsenduste nimekirjas $cx_i$. Samuti ei tohi definitsioon nõuda rangemaid kitsendusi tüübimuutujatele $u_1$ \ldots $u_k$ kui on sisse toodud kitsenduste nimekirjas $cx'$ esindaja deklaratsiooni päises. Toome kaks näidet esindajatest, mis ei läbi tüübikontrolli, kuna definitsiooni sisust järelduksid liiga ranged kitsendused.

            \begin{verbatim}class Bug t where
  bug :: t -> f t
instance Bug [t] where
  bug = pure\end{verbatim}

            Loome klassi \verb!Bug!, millel on meetod \verb!bug!. Meetodil \verb!bug! on kitsendamata tüübimuutuja \verb!f!. Selline esindaja ei läbi tüübikontrolli, sest funktsioon \verb!pure! eeldab klassi \verb!Applicative!, aga klassi deklaratsioonis ei ole tüübimuutuja \verb!f! kitsendamist ette nähtud.

            \begin{verbatim}class Bug t where
  bug :: t -> t
instance Bug [t] where
  bug = sort\end{verbatim}

            Ka see näide ei läbi tüübikontrolli, sest meetodi teostus eeldab mitte-ettenähtud kitsendusi esindaja deklaratsiooni päises sisse toodud tüübimuutujale. Funktsioon \verb!sort! eeldab, et listi elemendid on võrreldavad, aga samas ei ole seda eeldust sisse toodud. Seda näidet saab parandada järgmisel lihtsal viisil:

            \begin{verbatim}instance Ord t => Bug [t] where
  bug = sort\end{verbatim}
          \item
            Ploki $d$ definitsioonidele on keelatud kirjutada tüübisignatuure, sel lihtsal põhjusel, et klassi meetodite tüübisignatuurid on toodud juba klassi deklaratsioonis ning seega esindajat defineerides ei ole need vajalikud.
        \end{itemize}
      \subsubsection{Tüübiklassidega seotud laiendused}
        Haskellil on ka palju laiendusi, mis võimaldavad tüübiklasside vallas paindlikkust lisada. Loetleme siinkohal mõned tüübiklassidega seotud laiendused~\cite{Gla}. Me ei hakka detailselt käsitlema nimetatud laienduste kasutusvõimalusi, vaid lihtsalt mainime lühidalt, milliseid piiranguid need eemaldavad.

        \begin{itemize}
          \item
            \verb!ConstrainedClassMethods! võimaldab klassi meetodite tüübisignatuurides kitsendada ka klassi päises sisse toodud tüübimuutujaid.

            \begin{verbatim}class C t where
  f :: Ord t => t -> t -> t\end{verbatim}
          \item
            \verb!DefaultSignatures! võimaldab kirjutada erineva signatuuri klassi meetodile ja vaiketeostusele. See on kasulik näiteks juhuks, kui tahta kirjutada vaiketeostus, mis töötab ainult teatud kitsendatud juhtudel.
          \item
            \verb!FlexibleContexts! võtab ära piirangu, et klassi kontekst $cx$ on lihtsalt ülemklasside nimekiri. See võimaldab kitsenduste nimekirjas kasutada ka keerulisemaid avaldisi, mis ei pea koosnema tingimata ainult tüübimuutujatest vaid võivad sisaldada ka muid tüüpe.
          \item
            \verb!FlexibleInstances! võimaldab luua esindajaid, kus esindajaks muudetav tüüp ei koosne ainult konstruktorist ja tüübimuutujatest.

            \begin{verbatim}instance C [Char]\end{verbatim}
          \item
            \verb!IncoherentInstances! ja \verb!OverlappingInstances! on kaks aegunud laiendust, mis lubavad kattuvaid esindajaid.
          \item
            Standartses Haskellis on tüübiklassid üheparameetrilised. \verb!MultiParamTypeClasses! lubab suvalise arvu parameetritega -- sealhulgas ka ilma parameetrita -- tüübiklasse.

            \begin{verbatim}
class C
class B t u\end{verbatim}
          \item
            Laiendus \verb!FunctionalDependencies! on mõeldud loomaks mitmeparameetrilisi tüübiklasse, kus üks tüüp sõltub teisest. Näiteks oletame, et kirjutame algebrateeki ja soovime luua üldistatud korrutamist, mis võib korrutada erinevat tüüpi argumente, kusjuures tulemuse tüüp ei pruugi tingimata kummagi argumendi omaga ühtida.

            \begin{verbatim}class Mult t u v | t u -> v where
  mult :: t -> u -> v
instance Num t => Mult (Array n t) (Array n t) (Matrix n n t)
instance Num t => Mult (Array n t) (Matrix n m t) (Array m t)
instance Num t => Mult (Matrix m n t) (Array n t) (Array m t)
instance Num t => Mult (Matrix l m t) (Matrix m n t) (Matrix l n t)\end{verbatim}

            Kuna laiendus \verb!FunctionalDependencies! eeldab mitmeparameetrilisi tüübiklasse, võetakse sellega koos automaatselt kasutusse ka \verb!MultiParamTypeClasses!.
          \item
            \verb!InstanceSigs! võimaldab tüübisignatuure esindaja meetodite juures. Üks võimalik kasutus on näiteks lihtsalt täiendav dokumentatsioon esindajate sees.
          \item
            \verb!NullaryTypeClasses! on aegunud laiendus, mis võimaldab parameetriteta tüübiklasse. Selle asemel saab kasutada üldisemat laiendust \verb!MultiParamTypeClasses!.
          \item
            \verb!TypeSynonymInstances! võimaldab tüübisünonüüme, näiteks \verb!String!, klasside esindajateks muuta.
          \item
            \verb!UndecidableInstances! ja \verb!UndecidableSuperClasses! lubavad vastavalt esindajaid ja klasse, mille olemasolu võib resulteeruda mittetermineeruvas tüübikontrollis.
        \end{itemize}
    \subsection{Tüübiklassid Awfulis}
      Ka käesoleva töö teemaks olev keel Awful võimaldab \textit{ad hoc} polümorfismi tüübiklasside abil. Awful on tüübiklasside ja esindajate osas erinev Haskell 2010 standardist järgmistes aspektides:

      \begin{itemize}
        \item
          Lubatud on ainult ühene pärilus. Mitmene pärilus on plaanis lisada edasise töö käigus.
        \item
          Klassi meetodid ei pea sisaldama klassi päises sisse toodud tüübimuutujat. Kui Haskellis on meetod

          \begin{verbatim}class Bug (t :: *) where
  bug :: Int\end{verbatim}

          keelatud, siis Awfulis on analoogne meetod

          \begin{verbatim}Class Bug{T : Star}(bug : Int)\end{verbatim}

          lubatud. Hetkel ei oleks sellisest meetodist kasu, aga kuna tulevikus on kavas keelde lisada võimalus eksplitsiitselt klassiparameetrit edastada (näiteks \verb!bug{Char}!), ei näe käesoleva töö autor põhimõttelist põhjust Awfulis sellise meetodi keelamiseks.

          Selliste meetodite lubamine ei resulteeru interpretaatori kokku jooksmises ega ebakorrektses väärtustamises vaid kõigest veateates juhul kui meetodit on mõnes avaldises reaalselt kasutatud. Seetõttu on piirang tulevikku silmas pidades algusest peale kehtestamata jäetud, kuigi meetodi teostust avaldise sees eksplitsiitselt täpsustada ei ole veel võimalik.
        \item
          Haskell võimaldab osade tüübiklasside esindajaid (näiteks \verb!Eq!, \verb!Ord! ja \verb!Show!) automaatselt tuletada. Awfulis selline võimalus puudub.
        \item
          Ei ole võimalust lisada vaikedefinitsioone klassi meetodite jaoks. Kuna tegu on keele väljendusrikkuse seisukohast mittekriitilise võimalusega, ei ole seda hetkel kavas. Awfulis sisaldab klass ainult neid meetodeid, mis on minimaalselt vajalikud, ning kõik ülejäänud funktsioonid, mis saab nende kaudu defineerida, tuleb kirjutada väljaspool klassi. Selle tõttu ei luba Awful, erinevalt Haskellist, esindaja defineerimisel ühtegi meetodit kirjutamata jätta. Kuna puuduvad vaikedefinitsioond, on defineerimata meetod alati viga.
      \end{itemize}
  \peatykk{Tüübitaseme andmed ja edutamine}\label{edutamine}
    Selles peatükis refereerime, mis on edutamine ning kuidas see muudab tüübisüsteemi väljendusrikkamaks ja aitab kirjutada tüübiturvalisemat koodi. Kuna käesoleva töö autori loodud keelt tutvustatakse alles peatükkides~\ref{syntaks} ja~\ref{manual}, ning kuna Haskell on esimene keel, mis võimaldab edutamist~\cite{Giv}, on antud peatükis edutamise põhimõtete selgitamiseks kasutatud Haskelli süntaksit.

    Sageli on tüübiturvalisema koodi kirjutamiseks kasulik, kui saab tüüpide tasemel väärtusi kasutada. Näiteks võimaldavad tüübitaseme naturaalarvud luua vektoreid, mille pikkus, erinevalt listide omast, on juba tüübikontrolli ajal teada. Vektorite pikkustega seotud vead tulevad sellisel juhul välja juba tüübikontrollis, enne väärtustamist või kompileerimist.

    See võimaldab kirjutada näiteks vektorite liitmise või viimase elemendi leidmise funktsiooni tüübiturvaliselt. Juhul, kui kirjutada neid funktsioone listide abil, ei ole kuidagi tagatud, et programmeerija ei kutsu vektorite liitmise funktsiooni välja kahe erineva pikkusega listi peal või ei kutsu viimase elemendi leidmise funktsiooni tühja listi peal.

    Lisaks kannavad tüübid kasulikku teavet funktsioonide sisendite ja väljundite kohta, ning mida väljendusrikkam tüübisüsteem on seda detailsemalt saavad funktsioonide tüübid funktsioonide sisu kirjeldada. Näiteks juhul kui keeles on võimalik kasutada tüübitaseme naturaalarve, saab vektorite liitmise funktsiooni tüüpi vaadates kohe teada, et kaks vektorit peavad olema sama pikad. Vaadates vektori viimase elemendi leidmise funktsiooni tüüpi, on kohe aru saada, et vektor ei tohi olla pikkusega null.

    Tüübitaseme andmed parandavad tüübiturvalisust, vähendavad korduva koodi hulka ning lisaks aitavad kaasa sellele, et tüübisüsteem oleks väljendusrikkam ja tüübid dokumenteeriks paremini funktsioonide sisu.
    \subsection{Üldistatud algebralised andmetüübid}
      Käesoleva peatüki näidetes on kasutatud üldistatud algebralisi andmetüüpe. Seega enne tüübitaseme andmete juurde liikumist selgitame lühidalt üldistatud algebralisi andmetüüpe ja toome mõned näited.

      Tavalise algebralise andmetüübi puhul järgneb tüübi nimele tüübimuutujate loetelu ja seejärel konstruktorid.

      \begin{verbatim}data Maybe t = Nothing | Just t\end{verbatim}

      Konstruktorid ei võimalda resulteeruvat tüüpi kuidagi kitsendada. Kui tüübil $D$, millel on $n$ tüübimuutujat, on konstruktor $C$ argumenttüüpidega $T_1$ \ldots $T_m$, siis $C$ tüüp on $T_1$ \verb!->! \ldots \verb!->! $T_m$ \verb!->! $D$ $t_1$ \ldots $t_n$, kus tüübimuutujad $t_1$ \ldots $t_n$ on kõik erinevad.

      Üldistatud algebralise andmetüüpide puhul~\cite{Fir} see kitsendus enam ei kehti. Andmekonstruktori resultaattüübis ei pea enam olema ainult tüübimuutujad. Näitame alustuseks, kuidas tüüpi \verb!Maybe! üldistatud algebraliste andmetüüpide süntaksiga kirja panna:

      \begin{verbatim}data Maybe :: * -> * where
  Nothing :: Maybe t
  Just :: t -> Maybe t\end{verbatim}

      Esimene rida näitab, et \verb!Maybe! on tüübikonstruktor, mis võtab ühe argumendi. Seejärel kirjutame konstruktorid. Erinevalt tavalisest algebralisest andmetüübist on üldistatud algebralise andmetüübi puhul vajalik märkida ka tulemuse tüüp, antud juhul \verb!Maybe t!. Konstruktori ulemuse tüübis ei pea aga tüübikonstruktor olema rakendatud ainult hulgale erinevatele tüübimuutujatele -- ta võib olla rakendatud ka tüüpidele, ning antud tüüpides esinevad tüübimuutujad ei pea omavahel erinema.

      \begin{verbatim}data Example :: * -> * -> * where
  Constr_0 :: Example Int [t]
  Constr_1 :: Example t t\end{verbatim}

      Üldistatud algebraliste andmetüüpide põhjalik selgitamine jääb väljapoole antud töö skoopi. Seetõttu piirdume siinkohal ainult selle lühikese selgitusega ja jätkame tüübitaseme andmete ning nende rakenduste tutvustamisega.
    \subsection{Tüübitaseme andmed}\label{tyybitasemeandmed}
      Mõnedes keeltes, näiteks Idris~\cite{The_Idr}, saab tüübitaseme andmete saavutamiseks kasutada sõltuvaid tüüpe. Sõltuvatest tüüpidest anname lühikese ülevaate jaotises~\ref{soltuvad}. Keeles, kus sõltuvaid tüüpe ei ole, on tüübitaseme andmeid võimalik kirjutada algebraliste andmetüüpide abil~\cite{Giv}. Tüübitaseme naturaalarvud näeksid Haskelli algebralisi andmetüüpe kasutades välja sellised:

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Sarnasel viisil saab teostada ka näiteks tüübitaseme liste:

      \begin{verbatim}data Empty_List
data Construct_List t l\end{verbatim}

      Tegu on tühjade tüüpidega, millel puuduvad andmekonstruktorid ja mis on mõeldud spetsiaalselt tüübitaseme andmete rolli täitmiseks.

      Toome mõned lihtsad näited andmetüüpidest, mille konstrueerimiseks on vaja tüübitaseme andmeid. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada. Neil on kaks konstruktorit: üks tühja vektori jaoks, ja teine vektori jaoks pikkusega \verb!n + 1!, mis võtab argumendiks pea ja \verb!n!-elemendilise saba.

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua suvalise arvu muutujatega Boole'i funktsiooni tüüp. \verb!0! muutuja Boole'i funktsioon on üks konstant. \verb!n + 1! muutuja Boole'i funktsioon saab esitada kahe \verb!n! muutuja Boole'i funktsiooni abil (jääkfunktsioonid, mille saame, asendades esimese muutuja vastavalt konstandiga \verb!False! või \verb!True!).

      \begin{verbatim}data Fun :: * -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid, mis sarnanevad struktuuri poolest üleelmises näited toodud vektoritele, selle vahega, et nad võivad sisaldada erinevat tüüpi andmeid.

      \begin{verbatim}data Tuple :: * -> * where
  Empty_Tuple :: Tuple Empty_List
  Construct_Tuple :: t -> Tuple l -> Tuple (Construct_List t l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: * -> * -> * where
  Empty_Array' :: t -> Array' Empty_List t
  Construct_Array' :: Array n (Array' l t) -> Array' (Construct_List n l) t\end{verbatim}

      Tüübitaseme andmed on kasulikud selleks, et saaks kirjutada tüübiturvalisemaid funktsioone. Näiteks kui tahame kirjutada vektorite liitmise funktsiooni, siis juhul kui kasutada vektorite esitamiseks liste, siis on tarvis arvestada ohuga, et programmeerija annab funktsiooni sisendiks erineva pikkusega listid. Erineva pikkusega listid resulteeruvad defineerimata käitumises või erindis programmi töö käigus ning tüüpimise ajal ei ole seda võimalik ennetavalt tuvastada.

      Tüübitaseme andmete olemasolul saab vektorite liitmise funktsiooni kirjutada eelpool näiteks toodud \verb!Array! tüübi peal, ning see tagab, et iga vektorite liitmise funktsiooni kutse puhul kontrollitakse juba tüüpimise ajal, et mõlemad argumendid oleks sama pikad.
    \subsection{Tüübid, liigid ja sordid}\label{liiksort}
      Niiviisi teostatud tüübitaseme andmetel on oluline puudus. Tüübisüsteem ei ole piisavalt keeruline kirjeldamaks programmeerija tegelikke kavatsusi. Ei ole võimalust kirjeldada, et kohas kus võib esineda näiteks tüüp \verb!Char! või \verb!Int!, ei tohi esineda naturaalarvuline tüüp, ja vastupidi -- ehk tüübid ei ole piisavalt tugevalt tüübitud~\cite{Giv}. Tüübikontrollist lähevad läbi koodinäited, mis ei ole programmeerija tegelike kavatsustega kooskõlas, näiteks:

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next t) n\end{verbatim}

      Siin on konstruktori \verb!Construct_Array! tulemuse tüübis vahetusse läinud tüübimuutujad \verb!n! ja \verb!t!. Koodinäide ei tohiks tegelikult tüüpuda, sest need tüübimuutujad on täiesti erineva otstarbega. Vältimaks seda laadi vigu, oleks vaja tüübisüsteemi, mis on piisavalt võimas kirjeldamaks, et tüübikonstruktori \verb!Array! esimene argument peab olema naturaalarv ja teine tavaline tüüp, ja et tüübikonstruktorit \verb!Next! saab rakendada ainult naturaalarvule.

      Selleks, et tüübitaseme naturaalarvusid, tüübitaseme liste ja teisi tüübitaseme andmeid saaks kasutada turvalisemalt, on vaja võimsamat liigisüsteemi. Liigid on tüüpide jaoks sama, mis tüübid väärtuste jaoks -- tegu on tüüpide tüüpidega. Ka liikidel võivad omakorda olla tüübid ja neid nimetatakse sortideks~\cite{Typ}.

      Tuntud liigikonstruktorid Haskellis on näiteks liik \verb!*! ja liigikonstruktor \verb!->!, mille kaudu konstrueeritakse tüübikonstruktorite liike. Need tagavad, et tüübikonstruktoreid rakendataks õigele arvule õigetele argumentidele, näiteks et programmeerija ei üritaks kirjutada tüüpi \verb!Int List!.

      Võimsam liigisüsteem, mis sisaldaks lisaks eelmainitud liikidele ka kõigi tüübitaseme andmete liike (näiteks naturaalarvude liiki ja listide liiki), aitaks vältida selliseid vigu nagu selles jaotises toodud näites.

      See, et jaotises~\ref{tyybitasemeandmed} kirjeldatud viis tüübitaseme andmeid luua ei ole piisavalt tüübiturvaline, ei ole selle ainus nõrk külg. Lisaks eelmainitud peamisele puudusele, on oluline miinus ka see, et programmeerija peab tüüpide tasemel duplitseerima andmeid, mis on väärtuste tasemel tegelikult juba olemas (näiteks on tüübitaseme naturaalarvud samasuguse struktuuriga mis väärtuste taseme naturaalarvud).

      Edutamine lahendab mõlemad probleemid, muutes tüübi- ja liigisüsteemi võimsamaks ning tagades, et programmeerija ei peaks ise käsitsi tüübitaseme andmeid kirjutama. Järgmistes jaotistes räägimegi sellest, kuidas edutamine töötab, kuidas see muudab tüübisüsteemi ja millised andmetüübid on edutatavad.
    \subsection{Edutamine}
      Edutamine tõstab sobivad andmetüübid automaatselt "`üks tase ülespoole"'. Andmetüübi edutamisel tehakse tüübikonstruktorist liigikonstruktor, kusjuures tüübiparameetritest saavad liigiparameetrid. Andmekonstruktoritest saavad vastava liigi tüübikonstruktorid, kusjuures argumentide tüüpidest saavad tüübikonstruktorite argumentide liigid~\cite{Giv}.
      \subsubsection{Edutamise näiteid}
        Võtame esimeseks näiteks lihtsa andmetüübi, kus puudub polümorfism: naturaalarvud.

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        Ilma edutamiseta saab siit tüübi \verb!Nat :: *! ning kaks andmekonstruktorit \verb!Zr! tüüpi \verb!Nat! ja \verb!Next! tüüpi \verb!Nat -> Nat!. Edutamise olemasolul saab lisaks ka liigi \verb!Nat! ning kaks tüübikonstruktorit \verb!Zr! liiki \verb!Nat! ja \verb!Next! liiki \verb!Nat -> Nat!.

        Vaatleme keerulisemat näidet: liste.

        \begin{verbatim}data List (t :: *) = Empty_List | Construct_List t (List t)\end{verbatim}

        Ilma edutamiseta saab sellest andmetüübist tüübikonstruktori \verb!List :: * -> *! ning kaks andmekonstruktorit \verb!Empty_List! tüüpi \verb!List (t :: *)! ja \verb!Construct_List! tüüpi \verb!(t :: *) -> List t -> List t!. Edutamise olemasolul saab sellest andmetüübist lisaks ka ühe argumendiga liigikonstruktori \verb!List! ning kaks tüübikonstruktorit \verb!Empty_List! liiki \verb!List k! ja \verb!Construct_List! liiki \verb!k -> List k -> List k!.

        Listide puhul tuleb mängu polümorfism. Parametriseeritud tüüp muutub parametriseeritud liigiks. Tüübipolümorfsetest andmekonstruktoritest saavad liigipolümorfsed tüübikonstruktorid.

        Standartne Haskell edutamist ei sisalda ning edutamise jaoks on vaja kasutada keele laiendusi. Vajalikud laiendused on \verb!DataKinds! (edutamine) ja \verb!KindSignatures! (liigisignatuurid) ning, kuna paljud edutamise rakendused nõuavad üldistatud algebralisi andmetüüpe, ka \verb!GADTs!. Liigipolümorfismi jaoks on lisaks vajalik laiendus \verb!PolyKinds!.
      \subsubsection{Andmetüübid, mida saab edutada}\label{kitsendused}
        Edutamisele on mõistlik seada teatud piirangud ning edutada ainult osasid andmetüüpe, mitte kõiki. Piirangud on seotud sooviga kasutada edutamise võimalusi (näiteks tüübitaseme naturaalarvusid ja liste) ilma muutmata tüübisüsteemi keerulisemaks kui hädapärast vajalik. Loetleme siinkohal piirangud, mida on kasutatud Haskellis~\cite{Giv}.

        \begin{itemize}
          \item
            Ei edutata üldistatud algebraliseid andmetüüpe, kuna see muudaks liigisüsteemi keerulisemaks tuues sisse liikide võrdsuskitsendused (ing. k. \textit{equality constraints}).
          \item
            Ei edutata primitiive, näiteks tähti ja täisarvusid. Primitiivide edutamisega ei kaasne tegelikult sisulisi raskusi, küll aga võib neile praktiliste rakenduste leidmine nõua teisi keele täiendusi, mis ei ole sama lihtsad. Haskellis on primitiivide edutamata jätmise põhjuseks see, et keele laienduse autorite arvates ei ole primitiivide edutamine kasulik kui ei ole võimalik edutada tüübitasemele ka tehteid primitiividega (näiteks \verb!Int! tüüpi täisarvude liitmist).
          \item
            Ei edutata andmetüüpe, millel on tüübiparameetreid muud liiki kui liik \verb!*!. Juhul kui edutada ainult sellele kitsendusele vastavaid andmetüüpe, on sortide süsteem äärmiselt lihtne. Kõik liigimuutujad on ühte sorti. See tähendab, et liigipolümorfismi korral ei pea liigimuutujate sorte märkima. Liigikonstruktori sort on lihtsalt naturaalarv, mis näitab, mitut argumenti liigikonstruktor vajab.

            Juhul, kui soovida edutada andmetüüpe, mis sisaldaks tüübiparameetrites mitte ainult liiki \verb!*! vaid ka liigikonstruktorit \verb!->!, ei ole sellele põhimõttelisi takistusi, aga selline täiendus nõuaks keerulisemat sortide süsteemi. Liigimuutujad võivad olla erinevat sorti. Liigipolümorfismi korral oleks vaja liigimuutujate sorte märkida. Edutamise teostamine muutuks keerulisemaks, samas kui vajadus sellise võimsusega liigisüsteemi järele on küsitav.

            Kui tahta minna veel kaugemale ja edutada andmetüüpe, mis on parametriseeritud üle omakorda edutamise teel saadud liikide, oleks see veel keerulisem. Sellisel juhul oleks vaja \textit{topeltedutamist} -- tüübid, mis ei ole parametriseeritud üle edutamise teel saadud liikide, tuleks edutada kaks taset ülespoole -- või peaks tüübid ja liigid sõltuvad olema.
          \item
            Ei edutata liigipolümorfseid tüüpe, kuna sellisel juhul oleks vajalik sordipolümorfism.
          \item
            Loomulikult ei tohi edutada andmekonstruktoreid, mis võtavad mitte-edutatavat tüüpi argumente. Andmekonstruktorite edutamisel muutub tüüp liigiks, aga mitte-edutatavat tüüpi liigiks muuta ei saa, ei ole see võimalik. Tüübi mitte-edutatavus levib kõigile andmekonstruktoritele mis teda kasutavad.
        \end{itemize}

        Sarnastest piirangutest on lähtutud ka Awfuli loomisel, teatud muudatustega.

        \begin{itemize}
          \item
            Keeles ei ole üldistatud algebralisi andmetüüpe, aga on hargnevad andmetüübid, mida kirjeldame alamjaotises~\ref{hargnevad}. Reegli asemel, et ei edutata üldistatud algebralisi andmetüüpe, on keeles Awful tüübisüsteemis reegel, et ei edutata hargnevaid andmetüüpe.
          \item
            Isegi kui jätta kõrvale asjaolu, et tüübitaseme tehteid ei ole Awfulisse plaanis lisada, siis võimalused andmetüüpide konstrueerimiseks on palju piiravamad kui üldistatud algebralised andmetüübid. Selle tõttu ei näe käesoleva töö autor hetkel Awfulis primitiivide edutamisele mõttekaid rakendusi. Tulevikku vaadates on tähtede (\verb!Char!) ja täisarvude (\verb!Int!) edutamine siiski teostatud, juhuks kui andmetüüpide konstrueerimise viisid tulevikus võimsamaks muutuvad.

            Jäägiklassiringide primitiivi (\verb!Modular!) ei edutata, sest tegu on tüübiga, mis on parametriseeritud üle naturaalarvude ja seega ei vasta kitsendusele, et kõik argumendid peavad olema liiki \verb!Star! (Haskelli \verb!*!).
          \item
            Lihtsuse huvides edutab Awful ainult neid andmetüüpe, mille kõik konstruktorid on edutatavad. Andmetüübi edutamist koos ainult osade konstruktorite edutamist ei tehta.
          \item
            Oleks võimalik edutada funktsiooni tüüpi sisaldavaid andmekonstruktoreid, näiteks

            \begin{verbatim}data Fun t u = Fun (t -> u)\end{verbatim}

            Siit oleks võimalik edutamise teel saada kahe argumendiga liigikonstruktor \verb!Fun! ning liigipolümorfne tüübikonstruktor \verb!Fun! liiki \verb!Fun(t -> u) -> Fun t u!, kus sümbol \verb!->! tähistab tüübikonstruktori liiki. Selline edutamine võimaldaks edutada andmekonstruktoreid, mis võtavad argumendiks funktsioone, ja neist tuleks tüübikonstruktorid, mis võtavad argumendiks tüübikonstruktoreid.

            Awfulis, erinevalt Haskellist, sellist tüüpi hetkel ei edutata, sest selleks ei olnud otsest vajadust, aga antud täiendusele ei ole põhimõttelisi takistusi ja ei ole välistatud tulevikus selle võimaluse lisamine.
        \end{itemize}
      \subsubsection{Tüübisüsteemi täiendused edutamise lisamisel}
        Selleks, et saaks toimuda edutamine (alamjaotises~\ref{kitsendused} kirjeldatud kitsendustega), on tarvis tüübisüsteemi täiendada. Selles alamjaotises kirjeldame lühidalt, mis muudatused olid Awfulis edutamise teostamiseks vajalikud.

        \begin{itemize}
          \item
            Kui edutame tüübipolümorfseid andmekonstruktoreid, näiteks listikonstruktorid, muutub tüübipolümorfism liigipolümorfismiks. Seega tekib vajadus liigipolümorfsete tüüpide järele.

            Täpselt nagu tüübipolümorfism ilma kohustusliku tüübirakenduseta toob kaasa vajaduse tüübituletuse järele, toob liigipolümorfism ilma kohustusliku liigirakenduseta kaasa vajaduse liigituletuse järele. Awful nõuab teostuse lihtsuse huvides liigirakendust kõigi liigipolümorfsete tüüpide kasutamisel, et vätida liigituletust. Kuna liigipolümorfsed tüübid ei ole nii laias kasutuses kui tüübipolümorfsed andmekonstruktorid ja funktsioonid, ei muuda liigituletuse puudumine keelt nii kohmakaks kui tüübituletuse puudumine.
          \item
            Liigisüsteem peab olema piisavalt võimas ja paindlik, et võimaldada tüüpidest uusi liike teha. Enne edutamise lisamist oli Awfulis ainult äärmiselt primitiivne liigisüsteem, mis sisaldas liiki \verb!Star! (analoogne Haskelli liigiga \verb!*!) ja liiki \verb!Arrow! (tüübikonstruktorite liik, analoogne Haskelli liigiga \verb!->!). Interpretaatori sees olid liigid esitatud järgneva andmetüübi abil:

            \begin{verbatim}data Kind = Star_kind | Arrow_kind Kind Kind\end{verbatim}

            Selgelt ei ole sellisele fikseeritud liigisüsteemile võimalik edutamist üles ehitada ja on tarvis olulisi muudatusi. Awfuli interpretaator kasutab liigi esitamiseks andmetüüpi

            \begin{verbatim}data Kind = Name_kind | Application_kind Kind Kind\end{verbatim}

            Liike \verb!Star! ja \verb!Arrow! käsitletakse muudatuse järel lihtsalt kui nimede erijuhtumeid.
          \item
            Enne edutamise teostamist ei olnud Awfulis sorte. Sortide järele ei olnud vajadust, sest oli ainult kaks fikseeritud liigikonstruktorit ning programmeerija kirjutatud liigi korrektsust oli võimalik kontrollida otse parseri tasandil.

            Liigisüsteem, mida saab lõpmatult uute liikidega laiendada, nõuab sorte. Liike ei saa üksteisele suvaliselt rakendada. Näiteks \verb!Star Arrow! ei ole korrektne liik ega isegi liigikonstruktor, sest \verb!Star! ei võta argumente ja seega ei tohi teda millelegi rakendada. Õnneks on edutamisele seatud piisavalt ranged piirangud ja sortide süsteem ei ole seega keeruline: liigikonstruktori sordiks on naturaalarv, mis näitab, mitut argumenti on tarvis.

            \begin{verbatim}data Sort = Star_sort | Arrow_sort Sort\end{verbatim}
          \item
            Primitiivide edutamisel on vaja lisada vastavad tüübid.
        \end{itemize}
      \subsubsection{Edutamise kasutusjuhtusid}
        Selles alamjaotises külastame uuesti näiteid, mida tõime alamjaotises~\ref{tyybitasemeandmed} rääkides tüübitaseme andmete rakendustest. Näitame, kuidas edutamine muudab nad tüübiturvaliseks ja aitab vältida korduvat koodi.

        Esiteks ei ole edutamise olemasolu korral enam tarvis käsitsi eksplitsiitselt tüübitaseme andmeid kirjeldada. Kirjutame naturaalarvude andmetüübi

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        ja sellest tuletatakse automaatselt liik \verb!Nat! ning vastava liigi tüübikonstruktorid \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!. Mis kõige tähtsam, tänu sellele, et nüüd on olemas liik \verb!Nat!, on tüübitaseme naturaalarvud teostatud tüübiturvaliselt: tüübikonstruktori \verb!Next! puhul on teada, et tema argumendiks kõlbab ainult naturaalarv ja mitte näiteks täht või list.

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Toome mõned lihtsad näited sellest, milleks saab tüübitaseme andmeid kasutada. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada.

      \begin{verbatim}data Array :: Nat -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua \verb!n! muutuja Boole'i funktsiooni tüüp.

      \begin{verbatim}data Fun :: Nat -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid.

      \begin{verbatim}data Tuple :: [*] -> * where
  Empty_Tuple :: Tuple []
  Construct_Tuple :: t -> Tuple l -> Tuple (t : l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: [Nat] -> * -> * where
  Empty_Array' :: t -> Array' [] t
  Construct_Array' :: Array n (Array' l t) -> Array' (n : l) t\end{verbatim}

      Siinkohal võib tekkida küsimus, kas edutamise praktiline kasutamine on võimalik keeles, kus ei ole üldistatud algebralisi andmetüüpe. Need lihtsad ja kasulikud rakendused, mida oleme selles alamjaotises vaadelnud, ei ole teostatavad ainult algebraliste andmetüüpide abil, kuna andmekonstruktorite resultaattüübid peavad erinema. Näiteks vektorite puhul annab üks andmekonstruktor tulemuseks vektori, mille pikkus on \verb!Zr!, aga teine annab tulemuseks vektori pikkusega \verb!Next n!.

      Hea uudis on see, et paljud edutatud andmetüüpide rakendused on siiski võimalikud ilma keelde üldistatud algebralisi andmetüüpe lisamata. On võimalik kasutada piiravamat ja lihtsamat viisi andmetüüpide konstrueerimiseks. Awful toob sisse \textit{hargnevad andmetüübid}, mida tutvustame alamjaotises~\ref{hargnevad}.
    \subsection{Edutamisega kaasnev nimekonflikt}
      Haskellis on tihti tavaks, et andmetüübi konstruktori nimi ühtib tüübi nimega, näiteks

      \begin{verbatim}data Pair t u = Pair t u\end{verbatim}

      Kuna andmekonstruktor \verb!Pair! esineb ainult avaldiste tasandil ja sama nimega tüübikonstruktor esineb ainult tüüpide tasandil, ei teki vajadust neil kahel vahet teha. Edutamine muudab olukorda.

      Edutades ülalpool mainitud andmetüüpi, saame lisaks tüübikonstruktorile \verb!Pair! liiki \verb!* -> * -> *! samanimelise tüübikonstruktori liiki \verb!t -> u -> Pair t u!, kus t ja u on liigimuutujad ning \verb!Pair! on edutamise teel saadud liigikonstruktor. Seega on kaks erineva liigi ja otstarbega aga samanimelist tüübikonstruktorit. Nendel vahet tegemiseks on mitmeid erinevaid võimalusi.
      \subsubsection{Eksplitsiitne edutamine vajaduse korral}
        Haskellis kasutatakse juhtudel, kus tekib nimede konflikt, edutamise teel saadud tüübikonstruktori ees ülakoma~\cite{Giv}. Antud näite korral tähistab tüübikonstruktor \verb!Pair! tavalist tüübikonstruktorit liiki \verb!* -> * -> *! ning \verb!'Pair! tähistab edutamise teel saadud tüübikonstruktorit liiki \verb!t -> u -> Pair t u!.

        Tasub mainida ka, et juhul kui kasutaja otsustab Haskellis \verb!-Wall! võtit kasutada, antakse hoiatused kõigi edutamise teel saadud tüübikonstruktorite kohta, mille ette ei ole ülakoma pandud -- ka nende kohta, mille puhul ei ole nimekonflikti võimalust~\cite{Gla}.
      \subsubsection{Nimekonflikti vältimine}
        Üks võimalus nimekonflikti lahendada on keelata tüübikonstruktori ja andmekonstruktori nimede ühtimine.

        \begin{verbatim}data Pair t u = MkPair t u\end{verbatim}

        Antud lahendus on lihtne, aga tal on puudusi. Nii on võimalik vältida edutamise eksplitsiitset märkimist, aga samas muutuvad pikemaks tavalised andmekonstruktorid. Programmeerijatele, kes on harjunud tüübikonstruktorit ja andmekonstruktorit sama nimega nimetama, võib olla kergem kohaneda edutamise eksplitsiitse märkimisega kui andmekonstruktorite teisiti nimetamisega.
      \subsubsection{Eksplitsiitne edutamine alati}
        Nimekonflikti saab lahendada ka märkides kõik edutamise teel saadud liigid ja tüübid mõne spetsiaalse sümboliga, näiteks ülalpool mainitud andmetüübi \verb!Pair! deklaratsioon annaks lisaks tavalisele andmekonstruktorile ja tüübikonstruktorile ka 2 argumendi liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"t -> u -> !Pair t u".

        Käesoleva töö autori arvates on tegu hea lahendusega, sest erinevalt eksplitsiitsest edutamisest ainult vajaduse korral näevad edutamise teel saadud tüübikonstruktorid ühtlasemad välja. Lisaks võib edutamise teel saadud liigi- ja tüübikonstruktorite eksplitsiitne eristamine aidata programmeerijat, kes ei ole veel edutamisega harjunud ja ei tunne end kindlalt seda abstraktsiooni kasutades. Täpselt nagu tüüpide juurde märkimine võib vahel koodi isedokumenteeruvusele kaasa aidata, võib seda teha ka edutamise teel saadud tüübikonstruktorite eksplitsiitne märkimine.

        Selle tõttu ongi tegu lahendusega, mis sai valitud käesoleva töö raames loodud programmeerimiskeele jaoks. Awful kasutab edutamise tähistamiseks hüüumärki ning nõuab seda nii edutamise teel saadud liikide kui ka tüüpide ees.
    \subsection{Edutamise võrdlus sõltuvate tüüpidega}\label{soltuvad}
      Paljude keelte tüübisüsteemides, sealhulgas Haskelli omas, kehtib \textit{faasierisus} (ing. k. \textit{phase distinction}). Väärtused võivad sõltuda tüüpidest aga mitte vastupidi. Ka edutamise olemasolul jääb faasierisus tegelikult kehtima. Kuigi näiteks vektorite puhul võib tunduda, et vektori tüüp sõltub naturaalarvulisest väärtusest, aga tegelikult on tüübid ja väärtused siiski rangelt eristatud~\cite{Giv}.

      Mõnedes teistes programmeerimiskeeltes, näiteks Agda~\cite{Agd}, Coq~\cite{The_Coq} ja Idris~\cite{The_Idr}, on olemas sõltuvad tüübid. See tähendab, et tüübid võivad sõltuda väärtustest.

      Sõltuvad tüübid, nagu ka edutamine, võimaldavad luua tüübitaseme naturaalarvusid ja liste ning muid tüübitaseme andmeid. Tegu on aga võimsama tööriistaga kui edutamine. Toome mõned lihtsad funktsioonid, mida saab kirjutada kasutades sõltuvaid tüüpe, aga mis ei ole võimalikud ainult andmetüüpide edutamise abil. Tarvitame näidetes Idrise süntaksit, sest see on väga sarnane Haskelli omaga (siinkohal toodud näidetes on ainus erinevus see, et tüübi märkimiseks kasutatakse ühte ja listi konstrueerimiseks kahte semikoolonit).

      Üks lihtne ja kasulik funktsioon, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada, on kahe vektori konkateneerimine. Kui me konkateneerime vektoreid pikkusega \verb!m! ja \verb!n!, siis tulemuse pikkus on \verb!m + n!. Tegu on tüübitaseme naturaalarvude liitmisega. Kui edutatakse ainult tüüpe ja konstruktoreid, ei ole tüübitaseme andmetele võimalik rakendada funktsioone.

      \begin{verbatim}cat : Array m t -> Array n t -> Array (m + n) t
cat Empty_Array b = b
cat (Construct_Array x a) b = Construct_Array x (cat a b)\end{verbatim}

      Toome siinkohal veel ühe näite sõltuvate tüüpide kasutusest~\cite{The_Idr}, mida ei ole võimalik teostada edutamise abil. Üldistatud algebraline andmetüüp \verb!InElement! võimaldab staatiliselt tõestada, et element esineb listis. \verb!inList! funktsiooni tüüp \verb!InList (5 : Int) [1, 2, 5]! on teoreem, mis ütleb, et \verb!5! esineb listis \verb![1, 2, 5]!. See, et meil õnnestub vastavat tüüpi funktsioon kirjutada, tõestab tüübis toodud väite.

      \begin{verbatim}data InList : t -> List t -> Type where
  Here : InList x (x :: l)
  There : InList x l -> InList x (y :: l)
inList : InList (5 : Integer) [1, 2, 5]
inList = There (There Here)\end{verbatim}

      Haskellis \verb!InList! tüüp küll toimib, sest liste on võimalik tüübi tasemele edutada, aga kuna \verb!Int! ei ole edutatav tüüp, ei ole Haskellis võimalik elemendi leidumise tõestust \verb!Int! tüüpi täisarvude listi jaoks läbi viia. Veel halvem on olukord juhul, kui tahaksime analoogseid tõestusi läbi viia vektorite peal. Sõltuvate tüüpidega on see võimalik, aga tavaline ühekordne edutamine ei võimalda saavutada tüübitaseme vektoreid. Haskellis ei läbiks järgnev andmetüüp tüübikontrolli.

      \begin{verbatim}data InArray : t -> Array n t -> Type where
  Here : InArray x (Construct_Array x a)
  There : InArray x l -> InArray x (Construct_Array y a)\end{verbatim}

      Näeme, et paraku on kasulikke ja üldsegi mitte keerulisi funktsioone, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada. Edutamisel on võrreldes sõltuvate tüüpidega siiski ka eeliseid mitte ainult puudusi~\cite{Giv}:

      \begin{itemize}
        \item
          Programmeerijatel, kes on harjunud faasierisusega, võib olla lihtsam mõista edutamist kui sõltuvaid tüüpe.
        \item
          Sõltuvad tüübid muudavad keerulisemaks tüübikontrolli ja tüübituletuse.
        \item
          Sellistes keeltes nagu Haskell on võimalik tüübikontrolli järel kõik tüübid kustutada (ing. k. \textit{type erasure}). See, et programmi töö käigus ei ole enam tüüpe tarvis, aitab kaasa jõudlusele. Sõltuvate tüüpide korral on tüüpide kustutamine oluliselt keerulisem ülesanne.
      \end{itemize}

      Paljude kasutusjuhtude jaoks on edutamine piisav. Edutamine muudab tüübisüsteemi oluliselt võimsamaks ja väljendusrikkamaks, ohverdamata samas lihtsust ja nõudmata programmeerijalt oluliselt teistmoodi tüübisüsteemiga kohanemist.
  \peatykk{Awfuli süntaks}\label{syntaks}
    Selles peatükis kirjeldame Awfuli süntaksit.
    \subsection{Süntaksi formaalne spetsifikatsioon}
    Toome konkreetse süntaksi formaalse spetsifikatsiooni. Lisaks püstkriipsule, mis tähistab valikut kahe variandi vahel, on kasutatud ka sümboleid $A^*=\epsilon\mid AA^*$ ja $A?=\epsilon\mid A$ (kus $\epsilon$ tähistab tühja sõnet).

    Käesolev süntaksi spetsifikatsioon ei tegele leksiliste detailidega, nagu tühikud, reavahetused, kommentaarid ning muutujanimede, tähtede ja täisarvude leksiline struktuur. Neid detaile selgitame peatüki lõpus jaotistes~\ref{kommentaarid}-\ref{muutujanimed}.

    Loetavuse huvides on keele elementide tähistused ning süntaksi kirjeldamiseks kasutatav notatsioon tavalises kirjatüübis. Keele võtmesõnad ja sümbolid on helehallis fikseeritud laiusega kirjatüübis.

    \begin{equation*}
      \begin{tabular}{llll}
        Fail & $P$ & $::=$ & $I^*D^*C^*\Delta^*$
      \end{tabular}
    \end{equation*}

    Awfuli fail koosneb imporditavate failide nimekirjast ning andmetüüpide, klasside ja funktsioonide deklaratsioonidest.

    \begin{equation*}
      \begin{tabular}{llll}
        Import & $I$ & $::=$ & {\color{helehall}\verb!Load!} $x${\color{helehall}\verb!.awf!}
      \end{tabular}
    \end{equation*}

    Tähega \verb!x! tähistame süntaksi spetsifikatsioonis ükskõik millist nime: kas siis faili, tüübi, tüübimuutuja, konstruktori, struktuuri välja, definitsiooni või lokaalse muutuja oma. Nimede lekstilist struktuuri kirjeldame jaotises~\ref{muutujanimed}.

    \begin{equation*}
      \begin{tabular}{llll}
        Andmetüüp & $D$ & $::=$ & $S\mid A\mid B$
      \end{tabular}
    \end{equation*}

    Andmetüüp võib olla struktuur, algebraline andmetüüp või hargnev andmetüüp. Hargnevate andmetüüpe sisulist poolt tutvustame alamjaotises~\ref{hargnevad}. Käsolevas peatükis toome ainult süntaksi.

    \begin{equation*}
      \begin{tabular}{llll}
        Struktuur & $S$ & $::=$ & {\color{helehall}\verb!Struct!} $xt\phi$
      \end{tabular}
    \end{equation*}

    Struktuuri deklaratsioon sisaldab nime, tüübimuutujaid ja väljasid.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutujad & $t$ & $::=$ & $(${\color{helehall}\verb![!}$\tau(${\color{helehall}\verb!,!} $\tau)^*${\color{helehall}\verb!]!}$)?$
      \end{tabular}
    \end{equation*}

    Iga tüübimuutuja korral on kohustuslik märkida tema liik. Kui tüübimuutujate nimekiri on tühi, tuleb kandilised sulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutuja koos liigiga & $\tau$ & $::=$ & $x$ {\color{helehall}\verb!:!} $L$
      \end{tabular}
    \end{equation*}

    Nagu ka Idrises märgitakse tüüpe ja liike ühe mitte kahe kooloniga.

    \begin{equation*}
      \begin{tabular}{llll}
        Liik              & $L$   & $::=$ & $L_a\mid L_n$                                                       \\
                          & $L_0$ & $::=$ & {\color{helehall}\verb!(!}$L_a${\color{helehall}\verb!)!}$\mid L_n$ \\
        Liigi rakendamine & $L_a$ & $::=$ & $L_0$ $L_0$ $L_0^*$                                                       \\
        Liigi nimi        & $L_n$ & $::=$ & {\color{helehall}\verb"!"}$?x$
      \end{tabular}
    \end{equation*}

    Liikide süntaks on lihtne, koosnedes ainult nimedest ja rakendamisest. Edutamise teel saadud liikide ette käib hüüumärk.

    \begin{equation*}
      \begin{tabular}{llll}
        Väljad või argumendid & $\phi$ & $::=$ & $(${\color{helehall}\verb!(!}$v(${\color{helehall}\verb!,!} $v)^*${\color{helehall}\verb!)!}$)?$ \\
        Muutuja koos tüübiga  & $v$    & $::=$ & $x$ {\color{helehall}\verb!:!} $T$
      \end{tabular}
    \end{equation*}

    Struktuuri väljade ja funktsiooni argumentide süntaks on identne. Juhul, kui struktuuril ei ole väljasid või funktsioonil ei ole argumente, tuleb ümarsulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüüp                        & $T$   & $::=$ & $T_a\mid T_n\mid T_c\mid T_i$ \\
                                    & $T_0$ & $::=$ & {\color{helehall}\verb!(!}$T_a${\color{helehall}\verb!)!}$\mid T_n\mid T_c\mid T_i$ \\
        Tüübi rakendamine           & $T_a$ & $::=$ & $T_0$ $T_0$ $T_0^*$ \\
        Tüübi nimi ja liigirakendus & $T_n$ & $::=$ & {\color{helehall}\verb"!"}$?x\gamma$ \\
        Tüübitaseme täht            & $T_c$ & $::=$ & {\color{helehall}\verb"!"}$c$ \\
        Tüübitaseme täisarv         & $T_i$ & $::=$ & {\color{helehall}\verb"!"}$i$
      \end{tabular}
    \end{equation*}

    Tüüpide süntaks on sarnane liikide omaga, aga keerulisem selle tõttu, et tüüpide puhul lisandub eksplitsiitne liigirakendamine, mis on liigipolümorfsete tüüpide korral kohustuslik liigituletuse vältimiseks, ning tüübitaseme primitiivid. Tähega $c$ tähistame süntaksi spetsifikatsioonis tähemärki. Tähtede (\verb!Char!) ümber käivad topeltjutumärgid (näiteks \verb#"!"#). Reavahetuse märk on \verb!"\n"!. Hetkel toetab Awful ainult ASCII standardi tähti.

    \begin{equation*}
      \begin{tabular}{llll}
        Täisarv & $i$ & $::=$ & {\color{helehall}\verb!-!}$?n$
      \end{tabular}
    \end{equation*}

    Tähega $n$ tähistame süntaksi spetsifikatsioonis naturaalarvu (kaasa arvatud null).

    \begin{equation*}
      \begin{tabular}{llll}
        Liigirakendus & $\gamma$ & $::=$ & $(${\color{helehall}\verb"["}$L(${\color{helehall}\verb","}$L)^*${\color{helehall}\verb"]"}$)?$
      \end{tabular}
    \end{equation*}

    Liigirakenduse puhul antakse liigiparameetrite konkreetsed väärtused ette kandilistes sulgudes tüübi nime järel. Juhul, kui tüüp ei ole liigipolümorfne, tuleb kandilised sulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Algebraline andmetüüp              & $A$ & $::=$ & {\color{helehall}\verb!Algebraic!} $xt${\color{helehall}\verb!(!}$a${\color{helehall}\verb!,!} $a(${\color{helehall}\verb!,!} $a)^*${\color{helehall}\verb!)!} \\
        Algebralise andmetüübi konstruktor & $a$ & $::=$ & $x(${\color{helehall}\verb!(!}$T(${\color{helehall}\verb!,!} $T)^*${\color{helehall}\verb!)!}$)?$
      \end{tabular}
    \end{equation*}

    Algebraline andmetüüp, nagu ka struktuur, algab nimest ja tüübimuutujate nimekirjast. Sellele järgneb nimekiri vähemalt kahest konstruktorist. Algebralise andmetüübi konstruktor, erinevalt struktuuri omast, ei anna väljadele nimesid.

    \begin{equation*}
      \begin{tabular}{llll}
        Hargnev andmetüüp               & $B$ & $::=$ & {\color{helehall}\verb!Branching!} $x${\color{helehall}\verb"[!"}$x\gamma${\color{helehall}\verb!]!}$t${\color{helehall}\verb!(!}$b${\color{helehall}\verb!,!} $b(${\color{helehall}\verb!,!} $b)^*${\color{helehall}\verb!)!} \\
        Hargneva andmetüübi konstruktor & $b$ & $::=$ & {\color{helehall}\verb"!"}$x$ $x^*$ {\color{helehall}\verb!->!} $x\phi$
      \end{tabular}
    \end{equation*}

    Hargnev andmetüüp algab nimest. Sellele järgneb kandilistes sulgudes liik, mille järgi hargnetakse. Kuna hargnev andmetüüp võib hargneda ainult üle liigi, millel on lõplik arv tüübikonstruktoreid, peab see tingimata olema edutamise teel saadud liik ning liigi nimele peab eelnema hüüumärk. Liigile, üle mille andmetüüp hargneb, järgneb ülejäänud tüübimuutujate nimekiri ja konstruktorite nimekiri. Konstruktor koosneb edutamise teel saadud tüübi nimest, tüübimuutujate nimekirjast, konstruktori nimest ja väljadest.

    \begin{equation*}
      \begin{tabular}{llll}
        Klass  & $C$ & $::=$ & {\color{helehall}\verb!Class!} $x${\color{helehall}\verb!{!}$\tau${\color{helehall}\verb!}!}$(${\color{helehall}\verb!<!}$x${\color{helehall}\verb!>!}$)?(${\color{helehall}\verb!(!}$M(${\color{helehall}\verb!,!} $M)^*${\color{helehall}\verb!)!}$)?$ \\
        Meetod & $M$ & $::=$ & $xtk$ {\color{helehall}\verb!:!} $T$
      \end{tabular}
    \end{equation*}

    Tüübiklassi deklaratsioon algab nimest ning tüübimuutujast koos liigiga looksulgudes. Päritav klass on võimalik spetsifitseerida nurksulgudes. Seejärel tuleb meetodite nimekiri, mis võib olla ka tühi, mis juhul tuleb ümarsulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Kitsendused & $k$      & $::=$ & $(${\color{helehall}\verb!<!}$\kappa(${\color{helehall}\verb!,!} $\kappa)^*${\color{helehall}\verb!>!}$)?$ \\
        Kitsendus   & $\kappa$ & $::=$ & $x$ $x$
      \end{tabular}
    \end{equation*}

    Kitsendused pannakse nurksulgudesse. Juhul kui kitsedusi ei ole, tuleb nurksulud ära jätta. Kitsendus koosneb klassi nimest ja kitsendatava tüübimuutuja nimest.

    \begin{equation*}
      \begin{tabular}{llll}
        Definitsioon / esindaja & $\Delta$ & $::=$ & $F\mid I$
      \end{tabular}
    \end{equation*}

    Faili viimases osas defineeritakse funktsioone ja luuakse klasside esindajaid.

    \begin{equation*}
      \begin{tabular}{llll}
        Definitsioon & $F$ & $::=$ & {\color{helehall}\verb!Def!} $xtk\phi$ {\color{helehall}\verb!:!} $T$ {\color{helehall}\verb!=!} $E$
      \end{tabular}
    \end{equation*}

    Funktsiooni definitsioon sisaldab nime, tüübimuutujaid, kitsendusi, argumentide nimekirja, tüüpi ja avaldist. Argumentide nimekiri on süntaktiline suhkur, mis parandab definitsioonide loetavust.

    \begin{verbatim}Def Id[T : Star](x : T) : T = x
Def Id[T : Star] : Function T T = x -> x\end{verbatim}

    Need kaks definitsiooni on ekvivalentsed ning esimene teisendatakse parsimise järel teiseks.

    \begin{equation*}
      \begin{tabular}{llll}
        Avaldis & $E$   & $::=$ & $\alpha\mid\lambda\mid\mu\mid\Lambda_0\mid\Lambda_1\mid x\mid c\mid i\mid m$ \\
                & $E_0$ & $::=$ & {\color{helehall}\verb!(!}$\alpha${\color{helehall}\verb!)!}$\mid${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$\mid${\color{helehall}\verb!(!}$\mu${\color{helehall}\verb!)!}$\mid\Lambda_0\mid${\color{helehall}\verb!(!}$\Lambda_1${\color{helehall}\verb!)!}$\mid x\mid c\mid i\mid${\color{helehall}\verb!(!}$m${\color{helehall}\verb!)!}
      \end{tabular}
    \end{equation*}

    Avaldis võib olla rakendamine, lambda-avaldis, mustrisobitus-avaldis, muutujanimi, täht, täisarv või jäägiklassiringi element. Lisaks on keeles olemas süntaktiline suhkur listide jaoks.

    \begin{equation*}
      \begin{tabular}{llll}
        Jäägiklassiringi element & $m$ & $::=$ & $n$ {\color{helehall}\verb!#!} $n$
      \end{tabular}
    \end{equation*}

    Jäägiklassiringi elemendi (\verb!Modular!) puhul kirjutatakse ringi moodul numbri järele, eraldatuna {\color{helehall}\verb!#!} sümboliga.

    \begin{equation*}
      \begin{tabular}{llll}
        Funktsiooni rakendamine & $\alpha$ & $::=$ & $E_0$ $E_0$ $E_0^*$
      \end{tabular}
    \end{equation*}

    Funktsiooni rakendamine assotsieerub vasakult paremale ning järjekorda saab muuta ümarsulgudega täpselt nagu Haskellis.

    \begin{equation*}
      \begin{tabular}{llll}
        Lambda & $\lambda$ & $::=$ & $x$ {\color{helehall}\verb!->!} $E$
      \end{tabular}
    \end{equation*}

    Lambda-avaldis koosneb muutujanimest, millele järgneb nool ja avaldis.

    \begin{equation*}
      \begin{tabular}{llll}
        Mustrisobitus & $\mu$    & $::=$ & {\color{helehall}\verb!Match!} $E$ {\color{helehall}\verb!{!}$(M_a\mid M_c\mid M_i)${\color{helehall}\verb!}!} \\
                      & $M_a$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_a)^*\delta?$ \\
                      & $\mu_a$  & $::=$ & $x$ $x^*$ {\color{helehall}\verb!->!} $E$ \\
        Vaikevalik    & $\delta$ & $::=$ & {\color{helehall}\verb!,!} {\color{helehall}\verb!Default ->!} $E$ \\
                      & $M_c$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_c)^*\delta$ \\
                      & $\mu_c$  & $::=$ & c {\color{helehall}\verb!->!} $E$ \\
                      & $M_i$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_i)^*\delta$ \\
                      & $\mu_i$  & $::=$ & i {\color{helehall}\verb!->!} $E$ \\
                      & $M_m$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_i)^*\delta?$ \\
                      & $\mu_m$  & $::=$ & m {\color{helehall}\verb!->!} $E$
      \end{tabular}
    \end{equation*}

    Mustrisobitus algab võtmesõnaga \verb!Match! ja avaldisega, seejärel on looksulgudes harude nimekiri. Juhul, kui tegu on algebraliste andmetüüpide või jäägiklassiringi elementide mustrisobitusega ($M_a$ ja $M_m$), on vaikevalik (\verb!Default!) mittekohustuslik. Juhul, kui tegu on primitiivide mustrisobitusega ($M_c$ ja $M_i$), on vaikevalik kohustuslik.

    \begin{equation*}
      \begin{tabular}{llll}
        Tühi list      & $\Lambda_0$ & $::=$ & {\color{helehall}\verb!List!} \\
        Mittetühi list & $\Lambda_1$ & $::=$ & {\color{helehall}\verb!List!} {\color{helehall}\verb!(!}$E(${\color{helehall}\verb!,!}$E)^*${\color{helehall}\verb!)!}
      \end{tabular}
    \end{equation*}

    Listide süntaktiline suhkur algab sõnaga \verb!List! ning järgneb ümarsulgudes komadega eraldatud elementide loetelu. Juhul, kui list on tühi, on kohustuslik ümarsulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Esindaja        & $I$ & $::=$ & {\color{helehall}\verb!Instance!} $x${\color{helehall}\verb!{!}$T_n x^*${\color{helehall}\verb!}!}$k(${\color{helehall}\verb!(!}$m(${\color{helehall}\verb!,!} $m)^*${\color{helehall}\verb!)!}$)?$ \\
        Meetodi teostus & m   & $::=$ & $x$ $x^*$ {\color{helehall}\verb!=!} $E$
      \end{tabular}
    \end{equation*}

    Esindaja korral tuleb märkida klassi nimi, tüübi nimi koos tüübimuutujatega, kitsenduste nimekiri ja meetodite teostuste nimekiri. Meetodi teostus koosneb meetodi nimest, muutujate nimekirjast ja avaldisest. Võimalus otse meetodi nime järel muutujate nimesid kirjutada, et vähendada lambda-avaldiste arvu, on jällegi süntaktiline suhkur. See teisendatakse enne nime- ja tüübikontrolli lambda-avaldisteks.

    Süntaks ei ole taandetundlik. Põhjuseks oli parseri teostuse lihtsus, aga ka soov anda kasutajale vabadus koodi paigutuses. Lisaks vähendab mitte-taandetundlikkus parsimisvigade ohtu suuremate kooditükkide kopeerimisel ühest kohast teise. Antud otsuse peamiseks puuduseks on liigsed sulud ja eraldajad (näiteks \verb!Match! avaldises), mida taandetundlik süntaks oleks aidanud vältida.
    \subsection{Kommentaarid}\label{kommentaarid}
      Kommentaaride süsteem on sarnane Haskellile ja C keelele, selle vahega, et kasutatakse teistsuguseid sümboleid. Üherealist kommentaari alustatakse graavise sümboliga.

      \begin{verbatim}Def Id[T : Star](x : T) : T = T `Ühikfunktsioon\end{verbatim}

      Mitmerealist kommentaari alustatakse lainelise joone ja kaldkriipsuga, ning lõpetatakse kaldkriipsu ja lainelise joonega. Nagu ka Haskellis võib mitmerealisi kommentaare teineteise sisse paigutada.

      \begin{verbatim}~/ Awful on funktsionaalne keel. /~\end{verbatim}
    \subsection{Muutujanimede leksiline struktuur}\label{muutujanimed}
      Keel on tõstutundlik. Erinevalt Haskellist ei ole piiratud, mis nimed peavad algama suur- ja millised väiketähega. Failid, liigid, tüübid, tüübimuutujad, konstruktorid, struktuuride väljad, klassid, definitsioonide nimed ja lokaalsed muutujad võivad kõik alata kas suur- või väiketähega vastavalt kasutaja soovile.

      Nimedes on lubatud ülakoma, numbrid (välja arvatud esimeses positsioonis), ladina tähed ja alakriips. ASCII standardis mitte-esinevad sümbolid ei ole nimedes lubatud, küll aga tohib neid kasutada kommentaarides.

      Üksik alakriips tähistab, nagu ka Haskellis, nimetamata muutujat.
  \peatykk{Keele kirjeldus ja näited}\label{manual}
    Awful on deklaratiivne, puhas, funktsionaalne keel.

    Kuna töö teemaks oli tüübisüsteemi arendamine mitte kompileerimisega seotud problemaatika, sai kirjutatud ainult interpretaator ning kompileerimise võimalust ei ole. Tüübisüsteem on siiski staatiline: koodifaile on võimalik tüübikontrollida ka ilma väärtustajat käivitamata ning tüükontroll toimub enne väärtustamist mitte selle käigus.

    Erinevalt Haskellist, mis kasutab laiska väärtustamist, on Awful agara väärtustamisega. Laisa väärtustamise puhul väärtustatakse avaldised alles siis, kui nende tulemusi vaja on, samas kui agar väärtustamine tähendab, et kohe funktsiooni kutsel väärtustatakse kõik argumendid~\cite{Sem}. Agara väärtustamise valiku põhjuseks, nagu ka selle põhjuseks, et keel on interpreteeritud mitte kompileeritud, oli see, et töö fookuses oli tüübisüsteem ning väärtustamise viis on selle seisukohast ebatähtis. Seega sai valik langetatud lihtsama variandi kasuks.
    \subsection{Awfuli interpretaatori kasutajaliides}
      Interpretaatori lähtekood, mis on kirjutatud Haskellis, ja ka keelega kaasas käivad teegid, asuvad aadressil

      \begin{verbatim}github.com/LiisiKerik/Awful\end{verbatim}

      Interpretaatori kompileerimiseks tuleb kompileerida fail \verb!Awful.hs!.

      \begin{verbatim}ghc Awful.hs\end{verbatim}

      Awful annab kasutajale kaks käsklust, mida koodifailidele ja avaldistele rakendada: \verb!check!, mis teostab tüübikontrolli, ning \verb!eval!, mis väärtustab avaldise. Käsklus \verb!check! võtab argumendiks failinime ning tüübikontrollib faili sisu ja kõik selle impordid.

      \begin{verbatim}./Awful check Standard.awf\end{verbatim}

      Käsklus \verb!eval! võtab argumendiks nimekirja failinimedest ja avaldise ning tüübikontrollib failid ja kõik nende impordid. Seejärel väärtustatakse avaldis keskkonnas, kus on saadaval kasutaja antud failide nimekirjast leitud definitsioonid.

      \begin{verbatim}./Awful eval Standard.awf Algebra.awf "Fmap (Add 1) (Complex 2 5)"\end{verbatim}

      Interpreteeritav avaldis peab olema tüübist, mis on \verb!Writeable! klassi esindaja, ning tulemus kuvatatakse \verb!Write! meetodi abil.
    \subsection{Koodifailid ja importimine}
      Kõik Awfuli koodifailid lõpevad laiendiga \verb!.awf!. Faile saab importida kasutades võtmesõna \verb!Load!. Impordid peavad olema faili alguses ja nende omavaheline järjekord ei ole oluline.

      \begin{verbatim}Load Algebra.awf
Load Standard.awf\end{verbatim}

      Ringsõltuvused failide vahel on keelatud. Nende olemasolul antakse kasutajale veateade, kus kuvatakse nimekiri tsükli moodustavatest failidest.
    \subsection{Nimekonfliktid}
      Awfuli nimekontrolli olulisemad aspektid on järgmised:

      \begin{itemize}
        \item
          Programmis esinevaid nimesid -- liikide, tüüpide, konstruktorite, struktuuri väljade, klasside, definitsioonide, tüübimuutujate ja lokaalsete muutujate nimesid -- kogutakse ühte nimekontrolli-keskkonda. See tähedab, et sama nime ei tohi jagada ka täiesti erineva otstarbega konstruktsioonid, näiteks tüüp ja definitsioon, kuigi sellele ei oleks põhimõttelisi takistusi.
        \item
          Sama programmi kahes erinevas moodulis ei tohi esineda ühesugust globaalset nime, isegi juhul kui impordisuhted failide vahel on sellised, et tegelikult nimekonflikti ei teki. Tegu oli teostuse lihtsusest lähtuva otsusega.
        \item
          Kui moodul \verb!B! impordib mooduli \verb!A!, tehakse nimekontroll enne mooduli \verb!A! peal. See tähendab, et mõni lokaalne nimi moodulis \verb!A! võib ühtida mõne globaalse nimega moodulis \verb!B!, aga mitte vastupidi.
        \item
          Erinevalt Haskellist ei luba Awful muutujate varjutamist (ing. k. \textit{shadowing}). Näiteks lambda-avaldis \verb!f = \x -> \x -> x! on Haskellis lubatud (olenevalt kompilaatori seadistustest võib see resulteeruda hoiatuses). Sisemine \verb!x! varjutab välimise ning \verb!f 0 1! tulemuseks on \verb!1!. Samas Awfulis on analoogne avaldis \verb!x -> x -> x! keelatud.
      \end{itemize}
    \subsection{Liigid ja andmetüübid}
      Haskellis on olemas tavalised algebralised andmetüübid ja üldistatud algebralised andmetüübid. Awfuli lähenemine andmetüüpidele on teistsugune. Keel pakub kasutajale kolme erinevat viisi uusi andmetüüpe luua: struktuurid, algebralised andmetüübid (mis mõnevõrra erinevad Haskelli omadest) ja hargnevad andmetüübid. Kõigil on erinev otstarve.

      Awful nõuab, et andmetüübid oleks deklareeritud enne klasse ja definitsioone. Andmetüüpide deklaratsioonide omavaheline järjekord ei ole aga oluline isegi kui nende vahel on sõltuvusi.
      \subsubsection{Keelde sisse ehitatud liigid}
        Keelde on sisse ehitatud liigid \verb!Star! ja \verb!Arrow!, mis on analoogsed vastavalt Haskelli liikidega \verb!*! ja \verb!->!. Lisaks on Awfuli liigi- ja tüübisüsteemi rikastatud edutamise abil. Edutamisest on antud põhjalik ülevaade peatükis~\ref{edutamine} ning Haskelli ja Awfuli edutamise erinevusi käsitleb alamjaotis~\ref{kitsendused}.
      \subsubsection{Struktuurid}
        Struktuurid on mõeldud andmetüüpide jaoks, millel on täpselt üks konstruktor. Konstruktori nimi ühtib tüübi nimega automaatselt. Kohustuslik on kirja panna struktuuri väljade nimed.

        \begin{verbatim}Struct Complex[T : Star](Real : T, Imaginary : T)\end{verbatim}

        Juhul, kui struktuur ei kasuta tüübipolümorfismi, tuleb kandilised sulud lihtsalt ära jätta. Sama kehtib ka struktuuri väljade kohta: juhul kui struktuuril ei ole ühtegi välja, tuleb ära jätta ümarsulud väljade loeteluga.

        \begin{verbatim}Struct Trivial\end{verbatim}

      \subsubsection{Algebralised andmetüübid}
        Juhul, kui kasutaja tahab kirjutada ühe konstruktoriga andmetüüpi, on selleks struktuurid. Algebralised andmetüübid on sarnased Haskelli omadega, selle vahega, et kasutajalt nõutakse vähemalt kahte konstruktorit. Konstruktorite loetelu käib tüübimuutujate nimekirja järel ümarsulgudes.

        \begin{verbatim}Algebraic Either[T : Star, U : Star](Left T, Right U)\end{verbatim}

        Kuna algebraliste andmetüüpide puhul on andmetel kaks või enam erinevat kuju, ei ole nende jaoks võimalust spetsifitseerida väljade nimesid -- need ei oleks tüübiturvalised. Kui struktuurist saab andmed kätte väljade nimede abil, siis algebraliste andmetüüpide jaoks tuleb kasutada mustrisobituse avaldist, mida on kirjeldatud alamjaotises~\ref{match}.
      \subsubsection{Keelde sisse ehitatud andmetüübid}
        Lisaks tähtedele (\verb!Char!), funktsioonidele (\verb!Function!), piiramata suurusega täisarvudele (\verb!Int!) ja jäägiklassiringidele (\verb!Modular!) on Awfulis ka ilma standardteeki importimata saadaval järgmised andmetüübid:

        \begin{verbatim}Algebraic Comparison(LT, EQ, GT)
Algebraic List[T : Star](Empty_List, Construct_List(T, List T))
Algebraic Logical(False, True)
Algebraic Maybe[T : Star](Nothing, Wrap(T))
Algebraic Nat(Zr, Next(Nat))
Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Väiksem-võrdne-suurem võrdlustulemuse tüüp \verb!Comparison! on keelde sisse ehitatud, sest keelde on sisse ehitatud ka primitiivide (tähtede ja täisarvude) võrdlus. Listid, loogikaväärtused ja paarid on keelde sisse ehitatud põhjusel, et neid on vaja \verb!Writeable! klassi jaoks, mille kaudu on teostatud avaldise väärtustamise tulemuste kasutajasõbralik esitamine. \verb!Maybe! on lisatud sisse ehitatud klassi \verb!Field! (korpus) jaoks, sest pöördelemendi tehte tulemus antakse \verb!Maybe! monaadi all, kuna kõik korpused peale triviaalse sisaldavad mittepööratavaid elemente. Naturaalarvude tüüp \verb!Nat! on lisatud, sest jäägiklassiringid nõuavad tüübitaseme naturaalarvusid.

        Kuna kõik nimetatud struktuurid ja algebralised andmetüübid on edutatavad, kaasneb nendega ka vastavate edutamise teel saadud liikide ja tüüpide kasutamise võimalus.
      \subsubsection{Hargnevad andmetüübid}\label{hargnevad}
        Kui Awfuli struktuurid ja algebralised andmetüübid on võrdlemisi sarnased Haskelli algebralistele andmetüüpidele mõningate väikeste erinevuste ja piirangutega, siis hargnevad andmetüübid on oluliselt teistsugused. Seega selgitame neid põhjalikult ja toome mitu näidet.

        Hargnevad andmetüübid on viis andmetüüpide konstrueerimiseks, mis on mõeldud asendama teatud üldistatud algebraliste andmetüüpide rakendusi ilma tüübisüsteemile oluliselt keerukust lisamata. Meenutame edutamisest rääkivas peatükis~\ref{edutamine} toodud näiteid üldistatud algebraliste andmetüüpide rakendustest: nende abil saab konstrueerida näiteks staatilise pikkusega vektoreid, üldistatud ennikuid ja mitmemõõtmelisi staatilise suurusega tabeleid. Paljud nendest kasulikest näidetest ei vaja tegelikult üldistatud algebraliste andmetüüpide suurt paindlikkust, vaid järgivad väga kitsast spetsiifilist mustrit:

        Olgu meil edutatav andmetüüp nimega $D$, millel on $l$ tüübimuutujat ja $m$ andmekonstruktorit.

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!data!} $D$ $t_1$ \ldots $t_l$ {\color{helehall}\verb!=!} $C_1$ $T_{11}$ \ldots $T_{1n_1}$ {\color{helehall}\verb!|!} \ldots {\color{helehall}\verb!|!} $C_m$ $T_{m1}$ \ldots $T_{mn_m}$
          \end{tabular}
        \end{equation*}

        siis selle abil konstrueeritud üldistatud algebraline andmetüüp on tihti järgmisel kujul:

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!data!} $G$ {\color{helehall}\verb!::!} $D$ $K_1$ \ldots $K_l$ {\color{helehall}\verb!->!} $L_1$ {\color{helehall}\verb!->!} \ldots {\color{helehall}\verb!->!} $L_a$ {\color{helehall}\verb!where!} \\
            \verb!  !$E_1$ {\color{helehall}\verb!::!} $U_{11}$ {\color{helehall}\verb!->!}\ldots {\color{helehall}\verb!->!} $U_{1b_1}$ {\color{helehall}\verb!->!} $G$ {\color{helehall}\verb!(!}$C_1$ $v_{11}$ \ldots $v_{1n_1}${\color{helehall}\verb!)!} $u_1$ \ldots $u_a$ \\
            \verb!  !\ldots \\
            \verb!  !$E_m$ {\color{helehall}\verb!::!} $U_{m1}$ {\color{helehall}\verb!->!}\ldots {\color{helehall}\verb!->!} $U_{mb_m}$ {\color{helehall}\verb!->!} $G$ {\color{helehall}\verb!(!}$C_1$ $v_{m1}$ \ldots $v_{mn_m}${\color{helehall}\verb!)!} $u_1$ \ldots $u_a$
          \end{tabular}
        \end{equation*}

        Tüübikonstruktori $G$ esimene argument on liigist $D$ (rakendatuna mingitele teistele liikidele juhul kui $D$ võtab argumente). Iga $D$ andmekonstruktori $C_i$ kohta luuakse üks $G$ andmekonstruktor $E_i$. Tüübimuutujad $\{u_1,\ldots,u_a,v_{i1},\ldots v_{in_i}\}$ on kõik erinevad ning argumentide tüübid $(U_{i1},\ldots,U_{ib_i})$ ei sisalda ühtegi tüübimuutujat peale nende, mida resultaattüübis mainitakse. Andmekonstruktori $E_i$ resultaattüübi esimene argument on $D$ vastav konstruktor $C_i$ rakendatuna sobivale arvule tüübimuutujatele ning ülejäänud argumendid on lihtsalt tüübimuutujad. Kõik $G$ andmekonstruktorid näevad välja identsed kui välja arvata esimene argument.

        Awful võimaldab hargnevate andmetüüpide abil kirjutada andmetüüpe, mis vastavad kõigile ülalpool loetletud kitsendustele. Ütleme, et andmetüüp $G$ \textit{hargneb} tüübi $D$ järgi. Tüüpi $G$ saab Awfulis kirja panna järgnevalt:

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!Branching!} $G${\color{helehall}\verb![!}$D$ $K_1$ \ldots $K_l${\color{helehall}\verb!][!}$u1$ {\color{helehall}\verb!:!} $L_1${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $u_a$ {\color{helehall}\verb!:!} $L_a${\color{helehall}\verb!](!} \\
            \verb!  !$C_1$ $v_{11}$ \ldots $v_{1n_1}$ {\color{helehall}\verb!->!} $E_1${\color{helehall}\verb!(!}$F_{11}$ {\color{helehall}\verb!:!} $U_{11}${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $F_{1b_1}$ {\color{helehall}\verb!:!} $U_{1b_1}${\color{helehall}\verb!),!}\\
            \verb!  !\ldots{\color{helehall}\verb!,!}\\
            \verb!  !$C_m$ $v_{m1}$ \ldots $v_{mn_m}$ {\color{helehall}\verb!->!} $E_m${\color{helehall}\verb!(!}$F_{m1}$ {\color{helehall}\verb!:!} $U_{m1}${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $F_{mb_m}$ {\color{helehall}\verb!:!} $U_{mb_m}${\color{helehall}\verb!))!}
          \end{tabular}
        \end{equation*}

        Toome esimeseks hargnevate andmetüüpide näiteks staatilise pikkusega vektorid.

        \begin{verbatim}Branching Array[!Nat][T : Star](
  !Zr -> Empty_Array,
  !Next N -> Construct_Array(Head : T, Tail : Array N T))\end{verbatim}

        Esimesed kandilised sulud näitavad, millise liigi järgi hargnemine toimub. Antud juhul toimub hargnemine naturaalarvude järgi. Seejärel loetleme teised vajalikud tüübimuutujad koos liikidega: antud juhul on meil üks tüübimuutuja \verb!T!, mis tähistab vektori elementide tüüpi. Seejärel loome naturaalarvu-liigi kummagi tüübikonstruktori jaoks ühe andmekonstruktori. Nullile vastab tühi vektor; mittenullile vastab vektor, mis koosneb peast ja ühe võrra lühemast sabast. Nagu ka struktuuride korral, on kohustuslik ette anda väljade nimed. Hargneva andmetüübi esimese tüübiargumendi fikseerimisel saame ühe kindla struktuuri ning seega on väljade küsimine alati tüübiturvaline.

        Toome teiseks näiteks üldistatud ennikud.

        \begin{verbatim}Branching Tuple[!List Star](
  !Empty_List -> Empty_Tuple,
  !Construct_List T L ->
    Construct_Tuple(Head_Tuple : T, Tail_Tuple : Tuple L))\end{verbatim}

        Hargneme üle listide. Kuna Awfulis puudub liigituletus, on tarvis märkida, et hargneme üle listide, mille elemendid on tüübid liigist \verb!Star!. Listidel on kaks konstruktorit ja ka üldistatud ennikul on kaks konstruktorit. Tühjale tüüpide listile vastab tühi ennik. Tüüpide listile, mis koosneb tüübist \verb!T! ja sabast \verb!L!, vastab ennik, mille pea on tüüpi \verb!L! ja saba on ühe võrra lühem ennik, mis koosneb tüüpidest \verb!L!.

        Hargnevate andmetüüpide peamine eelis on see, et teades esimest tüübiargumenti, näiteks teades, kas vektor on pikkusega \verb"!Zr" või \verb"!Next N", teame kohe, millise konstruktori abil on andmed konstrueeritud ja milliseid väljasid on sealt võimalik kätte saada.

        Hargnevate andmetüüpide seatavatel rangetel piirangutel on ka olulisi puudusi. Üheks lihtsaks näiteks on üldistatud \verb!Either!. Kui meil on võimalus teha suvalise arvu tüüpide konjunktsiooni, tekib küsimus, kas saaksime teha ka suvalise arvu tüüpide disjunktsiooni. Haskellis on see võimalik.

        \begin{verbatim}data Either' :: [*] -> * where
  Left' :: t -> Either' (t : l)
  Right' :: Either' l -> Either' (t : l)\end{verbatim}

        Paneme tähele, et see üldistatud algebraline andmetüüp ei vasta hargnevatele andmetüüpidele seatud kitsendustele. Mõlema konstruktori resultaattüübis on esimene argument mittetühi list ja väärtust tüüpi \verb!Either' []! ei ole üleüldse võimalik konstrueerida. Tegu on kasuliku tüübiga, mida Awfuli hargnevad andmetüübid ei võimalda.
    \subsection{Tüübiklassid}
      Uue tüübiklassi loomine käib võtmesõnaga \verb!Class!, millele järgneb klassi nimi, tüübimuutuja nimi ja liik, päritav klass (kui seda on), ja nimekiri meetoditest koos tüüpidega.

      \begin{verbatim}Class Functor{F : Arrow Star Star}(
  Fmap[T : Star, U : Star] :
    Function (Function T U) (Function (F T) (F U)))\end{verbatim}

      Vahel on kasulikud ka ilma meetoditeta klassid. Sisuliselt on tegu predikaatidega tüüpide peal ja nad on kasulikud kirjeldamaks tüüpide omadusi. Üks lihtne näide on klass \verb!Commutative!, mille esindajat saab kirjutada märkimaks, et tüüp, mis on ring, on lisaks teatud tingimustel kommutatiivne. Kuna antud juhul ei ole tüübimuutuja nimetamine vajalik, lubab Awful selle asemele kirjutada alakriipsu.

      \begin{verbatim}Class Commutative{_ : Star}<Ring>\end{verbatim}

      Siinkohal tasub märkida, et täpselt nagu ka teiste klassidega, ei kontrollita selliste predikaatide puhul kasutaja kirjutatud klassiesindajate vastavust nõutud kitsendustele. Awful ei ole tõestusassistent ega paku võimalusi selliste omaduste tõestamiseks. See, et tüüp kuulub klassi \verb!Commutative!, ei ole garantii, et tegu on tõepoolest kommutatiivse ringiga, juhul kui programmeerija on vea teinud.
      \subsubsection{Pärilus}
        Awful võimaldab ainult ühest pärilust. Mitmene pärilus on plaanis teostada edasise töö käigus.

        Seda, et üks klass pärib teist, märgitakse nurksulgude abil:

        \begin{verbatim}Class Finite{T : Star}<Ord>(All : List T)\end{verbatim}

        Näiteks antud juhul eeldab klass \verb!Finite! (mis lubab \verb!All! meetodi abil saada list lõpliku andmetüübi kõigist võimalikest väärtustest) klassi \verb!Ord!.
      \subsubsection{Klassi meetodite tüübikitsendused}
        Vahel on vaja kirjutada klassi, mille meetodid sisaldavad tüübikitsendusi. Hea näide on klass \verb!Mat!, mis on mõeldud üldistamaks erinevaid ruutmaatrikseid ning sisaldab endas adjunktmaatriksi, karakteristliku polünoomi, determinandi ja vektoriga korrutamise meetodeid. Tema meetodites esinevaid tüübimuutujaid on vaja kitsendada kitsendustega \verb!Ring! ja \verb!Commutative!, sest näiteks maatriksi ja vektori korrutamist ei ole võimalik defineerida, kui allolev struktuur ei ole ring, ja determinant nõuab kommutatiivset ringi.

        \begin{verbatim}Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> :
    Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> :
    Function (Array N T) (Function (F N T) (Array N T)))\end{verbatim}
      \subsubsection{Keelde sisse ehitatud klassid}
        Neli klassi on saadaval ka ilma standardteeki importimata:

        \begin{verbatim}Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Ord{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(
  Write_Brackets : Function T (Pair (List Char) Logical))\end{verbatim}

        Klass \verb!Ord! on sarnane Haskelli samanimelise klassiga, selle vahega, et Awfulis ei ole klassi \verb!Eq!.

        Klass \verb!Writeable! on mõeldud andmestruktuuride stringideks teisendamiseks. Meetod \verb!Write_Brackets! tagastab paari sõnest ja loogikaväärtusest. Loogikaväärtus näitab, kas avaldisele on sulgusid ümber vaja või mitte juhul kui ta on mõne teise avaldise komponent. Meetodi \verb!Write_Brackets! kaudu on teostatud avaldiste väärtustamise tulemuste kuvamine.

        Klassid \verb!Ring! ja \verb!Field! on tuttavad algebrast: tegu on (mitte tingimata kommutatiivse) ringi ja korpusega. Klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu ringi elemendiks, on mõeldud defineerimaks nulli (\verb!Convert 0!) ja ühikut (\verb!Convert 1!), aga ka selleks, et oleks mugav suvalises ringis elementi täisarvulise konstandiga korrutada.
    \subsection{Definitsioonid ja esindajad}
      Nagu ka andmetüüpide ja klasside korral, ei ole definitsioonide omavaheline järjekord oluline.
      \subsubsection{Tehted primitiividega}
        Keelde on sisse ehitatud järgmised klasside \verb!Ord!, \verb!Ring! ja \verb!Writeable! esindajad:

        \begin{equation*}
          \begin{tabular}{l|cccc}
                           & \verb!Field! & \verb!Ord! & \verb!Ring! & \verb!Writeable! \\\hline
            \verb!Char!    &              & \linnuke   &             &                  \\
            \verb!Int!     &              & \linnuke   & \linnuke    & \linnuke         \\
            \verb!Modular! & \linnuke     & \linnuke   & \linnuke    & \linnuke
          \end{tabular}
        \end{equation*}

        Lisas on olemas ka funktsioonid \verb!Div! ja \verb!Mod!, mis annavad vastavalt täisarvulise jagatise ja jäägi. Turvalisuse huvides on mõlema funktsiooni tulemus \verb!Maybe! all juhuks kui jagaja on null.
      \subsubsection{Defineerimata käitumine}
        Defineerimata käitumist saab märkida erilise muutuja abil, mille nimi on \verb!Crash!. \verb!Crash! on sarnane Haskelli \verb!undefined! muutujaga selle poolest, et mõlemad on parameetriliselt polümorfsed üle suvalise tüübi liigist \verb!Star! (\verb!*!), selleks et neid saaks panna suvalisse kohta veel kirjutamata kooditüki asenduseks, või luua funktsioone mille käitumine ongi osade sisendite korral defineerimata.

        Nende kahe muutuja toime on aga erinev selle tõttu, et Haskell on laisk ja Awful on agar keel. Näiteks Haskelli avaldis \verb!fst (0, undefined)! annab \verb!0!, aga Awfuli analoogne avaldis \verb!First (Pair 0 Crash)! resulteerub tulemuses \verb!Crash!.
      \subsubsection{Definitsioonid}
        Definitsioon algab võtmesõnaga \verb!Def!, millele järgneb funktsiooni nimi, tüübimuutujate nimekiri, kitsenduste nimekiri, argumentide nimekiri, tulemuse tüüp ja avaldis. Ühikfunktsiooni definitsioon näeb välja selline:

        \begin{verbatim}Def Id[T : Star](x : T) : T = x\end{verbatim}

        Toome ka ühe näite definitsioonist, kus esineb kitsendusi. Juhul, kui \verb!T! on ring, saame tüübi \verb!T! jaoks \verb!Convert! meetodiga defineerida nulli.

        \begin{verbatim}Def Zero[T : Star]<Ring T> : T = Convert 0\end{verbatim}
      \subsubsection{Esindajad}
        Esindajat deklareeritakse, sarnaselt Haskellile, sõnaga \verb!Instance!.

        \begin{verbatim}Instance Ord{Trivial}(Compare _ _ = EQ)\end{verbatim}

        Tüübi nimi, mille jaoks esindajad defineeritakse, ning vajaduse korral ka tüübimuutujad, käivad looksulgudesse. Nurksulgudes saab anda kitsendusi.

        \begin{verbatim}Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)\end{verbatim}

        Juhul, kui mõnele tüübimuutujale ei ole tarvis kitsendusi anda, saab selle asemele kirjutada alakriipsu.

        \begin{verbatim}Instance Functor{Function _}(Fmap f g x = f (g x))\end{verbatim}

        Juhul, kui tegu on ilma meetoditeta klassiga, jäetakse ära ümarsulud meetodite nimekirjaga.

        \begin{verbatim}Instance Commutative{Int}\end{verbatim}
    \subsection{Avaldised}
      Awfuli avaldis võib olla muutujanimi, primitiiv, funktsiooni rakendamine, lambda-avaldis või mustrisobitusavaldis. Selles jaotises räägime põhjalikumalt lambda-avaldistest ja mustrisobitusest.
      \subsubsection{Lambda-avaldised}
        Funktsionaalse programmeerimiskeelena sisaldab Awful loomulikult lambda-avaldisi. Mustrisobituse võimalust funktsiooni argumentides ei ole veel teostatud, aga seda on tulevikus plaanis lisada. Süntaks on sarnane Haskelli omaga, aga ei ole vajalik \verb!\! sümbol enne muutujanime. Toome siinkohal näite lambda-avaldist kasutavast funktsioonist.

        \begin{verbatim}Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T =
  Fmap (z -> Multiply z y) (Inverse x)\end{verbatim}

        Süntaktiline suhkur korraga kahe muutuja andmiseks Awfulis puudub. Kui Haskellis saab kirjutada \verb!\ x y -> x!, siis Awfulis peab kirjutama \verb!x -> y -> x!.
      \subsubsection{Mustrisobitus}\label{match}
        Mustrisobitus töötab tähtede, täisarvude ja algebraliste andmetüüpide peal.

        \begin{verbatim}Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}\end{verbatim}

        Saab kirjutada ka \verb!Default! juhu, mida kasutatakse, kui ükski eelnev variant ei sobinud. See vaikevalik tuleb alati kirjutada mustrisobituse viimaseks juhuks.

        \begin{verbatim}Def Max[T : Star]<Ord T>(x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Turvalisuse tagamiseks kontrollitakse iga \verb!Match! avaldise puhul, kas kõik võimalikud juhud on käsitletud. Kattuvad või puuduvad juhud annavad vea. See tähendab, et \verb!Default! juhtum on kohustuslik tähtede ja täisarvude mustrisobituses, ning ka algebraliste andmetüüpide jaoks juhul kui eelnevalt ei ole kõiki võimalikke juhtusid käsitlenud.

        Erinevalt Haskellist ei luba Awful kirjutada keerulisema struktuuriga mustrisobitust, näiteks sobitada sama \verb!Match! avaldisega tühja, 1-elemendilist ja 2-elemendilist listi. Sellise otsuse põhjuseks oli teostamise lihtsus.

        Samuti ei luba Awful \verb!Match! avaldist üle struktuuri (selle asemel tuleb kasutada väljade nimesid, ja tulevikus on plaanis lisada võimalus teha struktuuride mustrisobitust otse funktsiooni argumendis) ega üle hargneva andmetüübi (selle asemel on võimalik kasutada tüübiklasse viisil, mis on kirjeldatud jaotises~\ref{tyybiklassihakk}).
    \subsection{Tüübiklasside kasutamine tüübimuutujate mustrisobituseks}\label{tyybiklassihakk}
      Vaatlesime, kuidas luua hargnevate andmetüüpide abil staatilise pikkusega vektoreid ja üldistatud ennikuid. Kuidas aga selliste andmetüüpide jaoks funktsioone kirjutada? Näiteks kuidas kirjutada \verb!Fmap! meetodit vektorite jaoks?

      Vektorite struktuur on sarnane listidele, selle vahega, et pikkus on tüübi osa. Listide \verb!Fmap! on teostatud järgmiselt:

      \begin{verbatim}Instance Functor{List}(
  Fmap f x =
    Match x {
      Empty_List -> List,
      Construct_List y z -> Construct_List (f y) (Fmap f z)})\end{verbatim}

      Oleks loogiline analoogselt teostada ka vektorite \verb!Fmap! meetodit. Haskellis olekski see võimalik.

      \begin{verbatim}instance Functor (Array n) where
  fmap f x =
    case x of
      Empty_Array -> Empty_Array,
      Construct_Array y z -> Construct_Array (f y) (fmap f z)\end{verbatim}

      Awful aga sellist teostust ei luba, sest Awfuli \verb!Match! avaldis töötab ainult tavaliste algebraliste andmetüüpide peal. Ning ka Haskellis on \verb!case! avaldise kasutamisega probleeme. Üks näite on klassi \verb!Applicative! meetod \verb!pure!, mis on tüüpi \verb!t -> f t!. Kuidas teostada \verb!pure! meetodit, kui tal ei ole ühtegi argumenti, mille peal mustrisobitust teostada?

      Üks variant oleks mustrisobitus tüübimuutuja \verb!n! peal, mis tähistab vektori pikkust. Ei Haskell ega Awful ei toeta sellist lähenemist, kuigi Awfulis on kavas selline võimalus tulevikus lisada. Seni saab aga kasutada vahendit, mis on keeles juba olemas -- tüübiklasse.

      \begin{verbatim}Class Functor_Array{N : !Nat}(
  Fmap_Array[T : Star, U : Star] :
    Function (Function T U) (Function (Array N T) (Array N U)))
Instance Functor_Array{!Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(
  Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)\end{verbatim}

      Loome abiklassi \verb!Functor_Array! üle naturaalarvulise tüübimuutuja. See sisaldab sama meetodit mis \verb!Functor!, ainult et konkreetse pikkusega vektori jaoks. Seejärel loome abiklassi esindajad nii nulli kui ka mittenulli jaoks. Lõpuks muudame vektori klassi \verb!Functor! esindajaks, kasutades \verb!Functor_Array! meetodit.

      Sellel meetodil on kaks peamist puudust. Esiteks peab programmeerija kirjutama palju abiklasse. Teiseks resulteeruvad need abiklassid ebavajalikes kitsendustes:

      \begin{verbatim}Def Square_Array[N : !Nat, T : Star]<Functor_Array N, Ring T> :
  Function (Array N T) (Array N T) =
    Fmap Square\end{verbatim}

      Siinkohal oleks kitsendus \verb!Functor_Array N! tegelikult täiesti ebavajalik. Kõik naturaalarvulised tüübid on klassi \verb!Functor_Array! esindajad ning seega tüübimuutuja \verb!N! võiks antud juhul täiesti kitsendamata olla. Oleks hea, kui selline ebavajalik kitsendus oleks võimalik ära jätta -- või kui oleks võimalik vektorite ja teiste hargnevate andmetüüpide funktsioone teostada otse tüübimuutuja peal mustrisobitust tehes -- ning tulevikus on plaanis Awfulisse selliseid võimalusi lisada.

      Toome veel ühe näite sellest, kuidas kasutada tüübiklasse kirjutamaks funktsioone, mis töötavad hargnevate andmetüüpide peal. Järgnev kood võimaldab teha üldistatud ennikud klassi \verb!Ord! esindajaks:

      \begin{verbatim}Class Ord_Tuple{L : !List Star}(
  Compare_Tuple : Function (Tuple L) (Function (Tuple L) Comparison))
Instance Ord{Tuple L}<Ord_Tuple L>(Compare = Compare_Tuple)
Instance Ord_Tuple{!Empty_List[Star]}(Compare_Tuple _ _ = EQ)
Instance Ord_Tuple{!Construct_List[Star] T L}<Ord T, Ord_Tuple L>(
  Compare_Tuple x y =
    Compare
      (Pair (Head_Tuple x) (Tail_Tuple x))
      (Pair (Head_Tuple y) (Tail_Tuple y)))\end{verbatim}

      Kitsendus \verb!Ord_Tuple L! kannab teavet selle kohta, et kõik listi \verb!L! kuuluvad tüübid kuuluvad klassi \verb!Ord!. Seda kitsendust, erinevalt kõigi naturaalarvude peal kehtivatest kitsendustest, ei oleks enam võimalik lihtsalt ära jätta. Siiski on praegune teostus äärmiselt kohmakas ja paljusõnaline. Võimalikest lahendustest antud probleemile räägime jaotises~\ref{eemaldadatyybiklassihakk}.
  \peatykk{Teostuse detailid}
    Awfuli interpretaator on kirjutatud Haskellis. See on võrdlemisi tüüpilise arhitektuuriga, koosnedes lekserist, parserist, nimekontollijast, tüübikontrollijast ja väärtustajast. Lisaks on eraldi moodul, mis vastutab kasutajaliidese ja moodulisüsteemi eest.
    \subsection{Parser}
      Awful kasutab aplikatiivset parsimist. Selles jaotises refereerime lühidalt monaadilist~\cite{Mon} ja aplikatiivset~\cite{App} parsimist ning selgitame, kuidas Awfuli parser on teostatud.
      \subsubsection{Parserite andmetüüp}\label{parserityyp}
        Selleks, et saaks kasutada aplikatiivset või monaadilist parsimist, tuleb kirjutada parserite andmetüüp. Toome siinkohal parserite andmetüübi, mis lisaks erinevatele võimalikele väljundtüüpidele ei piira ka sisendi tüüpi ega veateadete andmise viisi.

        \begin{verbatim}newtype Parser s m t = Parser {parser :: s -> m (t, s)}\end{verbatim}

        Selline parser võtab sisendteksti tüüpi \verb!s! ning annab tulemuseks väljundi tüüpi \verb!t! ja parsimata jäänud osa sisendekstist, kusjuures väljund antakse monaadi \verb!m! all.

        Sisend \verb!s! võib olla tähtede nimekiri, aga võib olla ka mõni keerulisem struktuur. Praktikas on oluliselt lihtsam parsida teksti, mille peal on eelnevalt tehtud leksiline analüüs, et parser ei peaks tegelema selliste detailidega nagu nimede ja arvude tähthaaval kokku korjamine või kommentaarid. Lisaks parsitavale tekstile võib olla kasulik kaasas kanda ka lisainfot, näiteks teavet selle kohta, kui kaugele on teksti ebaõnnestunud parsimiskatsete käigus ette vaadatud.

        Monaad \verb!m! on vajalik selle tõttu, et parsimine võib ka ebaõnnestuda või rohkem kui ühe tulemuse anda. See monaad võib olla näiteks \verb!Maybe! (juhul kui meid ei huvita, miks täpselt parsimine ebaõnnestus) või \verb!Either e! (juhul kui vajame veateateid tüüpi \verb!e!). Aga monaad \verb!m! võib olla ka näiteks list, juhul kui on tarvis mitmest parsimist.
      \subsubsection{Monaadiline parsimine}
        Parsereid saab vaadelda monaadidena~\cite{Mon}.

        Juhul, kui \verb!m! on funktor, on tüüp \verb!Parser s m! samuti funktor. Intuitiivselt tähendab see, et tüüpi \verb!t! väljundiga parseri puhul saame väljundile eduka parsimise korral rakendada funktsiooni tüüpi \verb!t -> u! ja saame niiviisi parseri väljundtüübiga \verb!u!.

        \begin{verbatim}instance Functor m => Functor (Parser s m) where
  fmap f (Parser p) = Parser (\x -> fmap (first f) (p x))\end{verbatim}

        Funktsioon \verb!first! moodulist \verb!Data.Bifunctor! rakendab funktsiooni paari (või mõne muu bifunktori) esimesele elemendile.

        Juhul, kui \verb!m! on monaad, on tüüp \verb!Parser s m! samuti monaad. Operaator \verb!>>=!, mis võtab argumendiks parseri \verb!p! ja funktsiooni \verb!f!, rakendab sisendtekstile parserit \verb!p! ning, saades tulemuseks väärtuse \verb!r! ja teksti \verb!x!, parsib teksti \verb!x! parseriga \verb!f r!. Meetod \verb!return! teeb väärtusest \verb!r! parseri, mis ei muuda sisendteksti ja annab parsimise tulemuseks sellesama väärtuse \verb!r!.

        \begin{verbatim}instance Monad m => Monad (Parser s m) where
  Parser p >>= f = Parser (p >=> \(r, x) -> parser (f r) x)
  return r = Parser (\x -> return (r, x))\end{verbatim}

        Operaator \verb!>=>!, mis on defineeritud teegis \verb!Control.Monad!, käitub järgmiselt:

        \begin{verbatim}p >=> f = \x -> p x >>= f\end{verbatim}

        Monaad võimaldab muuhulgas parserite järjestikust kombineerimist. Juhul kui soovime parsida teksti alguses parseriga \verb!p!, mille väljund on tüüpi \verb!t!, ja seejärel parsida [ülejäänud teksti parseriga \verb!q!, mille väljund on tüüpi \verb!u!, ning võtta tulemused kokku üheks väärtuseks funktsiooni \verb!f :: t -> u -> v! abil, saab seda teha parseriga \verb!ap (fmap f p) q!. Funktsioon \verb!ap! on tüüpi \verb!m (t -> u) -> m t -> m u!, kus \verb!m! on monaad. 

        Lisaks parserite järjestikusele kombineerimisele on tarvis ka võimalust kahe või enama parseri vahel valida. Seda on võimalik teha klassi \verb!MonadPlus! abil, mis on \verb!Monad! alamklass. \verb!MonadPlus! sisaldab assotsiatiivset operatsiooni \verb!mplus! ja selle operatsiooni ühikut \verb!mzero!.

        \begin{verbatim}instance MonadPlus m => MonadPlus (Parser s m) where
  mplus (Parser p) (Parser q) = Parser (\x -> mplus (p x) (q x))
  mzero = Parser (\_ -> mzero)\end{verbatim}

        Meetod \verb!mplus! võtab argumendiks kaks parserit ja üritab rakendada esimest. Kui esimene parser ebaõnnestub, üritatakse rakendada teist. \verb!mzero! on parser, mis alati ebaõnnestub.
      \subsubsection{Aplikatiivne parsimine}\label{appars}
        Iga tüübikonstruktor, mis on monaad, on ka aplikatiivne funktor. Ka parserid on aplikatiivsed funktorid~\cite{App}.

        \begin{verbatim}instance Monad m => Applicative (Parser s m) where
  Parser p <*> q = Parser (p >=> \(f, x) -> first f <$> q x)
  pure r = Parser (\x -> pure (r, x))\end{verbatim}

        Loetleme siinkohal \verb!Applicative! klassi esindajate jaoks saada olevaid operaatoreid, mida saab kasutada parserite järjestikuseks kompositsiooniks.

        \begin{itemize}
          \item
            \begin{verbatim}(<$>) :: Functor f => (t -> u) -> f t -> f u\end{verbatim}

            Tegu on meetodi \verb!fmap! operaatorkujuga.
          \item
            \begin{verbatim}(<*>) :: Applicative f => f (t -> u) -> f t -> f u\end{verbatim}

            Parserite järjestikust kompositsiooni \verb!ap (fmap f p) q! on aplikatiivse funktori operaatorite abil võimalik kirja panna kui \verb!f <$> p <*> q!.
          \item
            \begin{verbatim}(<$) :: Functor f => t -> f u -> f t\end{verbatim}

            See \verb!fmap! sarnane operaator on kasulik juhul, kui meid huvitab teiseks argumendiks oleva parseri õnnestumine või ebaõnnestumine, aga mitte selle tulemus.
          \item
            \begin{verbatim}(<*) :: Applicative f => f t -> f u -> f t
(*>) :: Applicative f => f t -> f u -> f u\end{verbatim}

            Need \verb!(<*>)! sarnased operaatorid eiravad vastavalt teise ja esimese parseri parsimistulemust. Operaatorid \verb!<$!, \verb!<*! ja \verb!*>! on kasulikud parsimaks näiteks võtmesõnu, operaatoreid, sulgusid ja eraldajaid.
        \end{itemize}

        Klassi \verb!MonadPlus! asemel võib erinevate alternatiivide vahel valimiseks kasutada ka klassi \verb!Alternative!, mis eeldab klassi \verb!Applicative!. Klass \verb!Applicative! on peaaegu identne klassiga \verb!MonadPlus!. Ainsaks sisuliseks vaheks on see, et kui \verb!MonadPlus! eelduseks on \verb!Monad!, siis \verb!Alternative! eelduseks on \verb!Applicative!, mis on vähem piirav eeldus.

        Klassis \verb!Alternative! on funktsiooni \verb!mplus! ja konstandi \verb!mzero! asemel samade tüüpidega operaator \verb!<|>! ja konstant \verb!empty!.

        \begin{verbatim}instance Alternative m => Alternative (Parser s m) where
  Parser p <|> Parser q = Parser (\x -> p x <|> q x)
  empty = Parser (\_ -> empty)\end{verbatim}

        Aplikatiivne parsimine on vähem võimas kui monaadiline. Komponeerides parsereid operaatori \verb!>>=! abil võib teise parseri käitumine oleneda esimese parseri tagastatud parsimistulemusest; aplikatiivse parsimise korral ei ole see võimalik. Siiski on aplikatiivne parsimine paljudeks rakendusteks piisav.
      \subsubsection{Awfuli parseri teostus}
        Awful kasutab aplikatiivset parsimist. Awfuli parser järgib alamjaotises~\ref{parserityyp} kirjeldatud mustrit, et parser on funktsioon, mis tagastab monaadi all paari parsimistulemisest ning järelejäänud sisendist.

        \begin{verbatim}newtype Parser t = Parser {parser :: State -> Either Location (t, State)}\end{verbatim}

        Sisendiks on tüüp nimega \verb!State!, mis koosneb lekseri väljastatud süntaksiüksuste (ing. k. \textit{token}) nimekirjast ja lisaks asukohast, mis ütleb, kui kaugele on teksti ette vaadatud. See teave on vajalik andmaks võimalikult täpse asukohaga veateateid.

        \begin{verbatim}data State = State Tokens Location\end{verbatim}

        Tulemus antakse \verb!Either Location! monaadi all. Veateate tüübiks on seega \verb!Location!, mis ütleb, kust alates ei õnnestunud teksti enam edasi parsida.

        Parserite järjest komponeerimine (ning seega ka klassi \verb!Applicative! teostus) on täpselt sama mis jaotises~\ref{appars}. Küll aga muudab vigade asukohtade leidmine keerulisemaks valiku alternatiivide vahel~\cite{Err}. Valik kahe võimaliku parsimisviisi vahel ja alati ebaõnnestuv parser on Awfulis teostatud järgnevalt:

        \begin{verbatim}instance Alternative Parser where
  Parser p <|> Parser q =
    Parser
      (\x ->
        case p x of
          Left l -> q (update_location x l)
          Right r -> Right r)
  empty = Parser (\(State _ l) -> Left l)\end{verbatim}

        Kui toimub valik kahe alternatiivi vahel, proovime enne esimest parserit. Juhul, kui see õnnestub, tagastamegi vastava tulemuse. Juhul, kui esimene parser ebaõnnestub, tunduks loomulik lihtsalt samale sisendile teist parserit rakendada. Siis aga tekib probleem veateadete asukohtadega. Juhul, kui esimene parser jõuab kaugemale kui teine, aga mõlemad ebaõnnestuvad, ütleks selline süsteem, et viga juhtus varem kui tegelikult. Näiteks kui grammatika lubab sõnet \verb!"Catamorphism"! või \verb!"Category"!, aga parser saab sõne \verb!"Catastrophe"!, tahaksime kasutajale öelda, et viga juhtus tähemärgil \verb!5!, kus ebaõnnestus sõne \verb!"Catamorphism"! parsimine, mitte tähemärgil \verb!4!, kus ebaõnnestus sõne \verb!"Category"! parsimine.

        Ka kahest vea-asukohast suurima leidmine ei aita. Oletame, et tahame parsida teksti reegliga \verb!many p <* end!, kus \verb!p! parsib sõnet \verb!"aa"! ja \verb!end! nõuab, et kogu tekst oleks parsitud. Siis teksti \verb!"ab"! korral antaks vea asukohaks \verb!1! mitte \verb!2!. Parser \verb!p! ebaõnnestub tähemärgil \verb!2!. Parser \verb!many p! õnnestub andes tulemuseks tühja listi ja jätab jäägiks kogu teksti \verb!"ab"!. Rakendades sellele parserit \verb!end!, mis ei mäleta, kui kaugele parser \verb!p! jõudis, tulebki välja, nagu oleks viga kohe teksti alguses, kuigi tegelikult jõudis esimene parser kaugemale.

        Selleks jätabki Awfuli parser alati meelde kõige suurema asukoha, kuhu mõnel katsel edukalt jõuti, ning see asukoht väljastataksegi programmeerijale veateates. Uue kõige kaugema vea-asukoha arvutamist teostab funktsioon \verb!update_location!.

        \begin{verbatim}update_location :: State -> Location_0 -> State
update_location (State a b) c = State a (max b c)\end{verbatim}
    \subsection{Nimekontroll}
      Awful paneb nimekontrollil kõik nimed ühte keskkonda. Iga faili läbib nimekontrollija kaks korda. Esimesel läbimisel korjatakse keskkonda kõik globaalsed nimed:

      \begin{itemize}
        \item
          Andmetüüpide nimed
        \item
          Andmekonstruktorite nimed
        \item
          Struktuuride ja hargnevate andmetüüpide väljade nimed
        \item
          Klasside nimed
        \item
          Meetodite nimed
        \item
          Definitsioonide nimed
      \end{itemize}

      Teisel läbimisel kontrollitakse lokaalseid nimesid:

      \begin{itemize}
        \item
          Iga andmetüübi jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest ja teineteisest.

          \begin{itemize}
            \item
              Iga hargneva andmetüübi haru jaoks kontrollitakse, kas kõik antud harus sisse toodud tüübimuutujate nimed on erinevad globaalsetest nimedest, kogu hargneva andmetüübi jaoks kehtivatest tüübimuutujatest ja teineteisest.
          \end{itemize}
        \item
          Iga klassi jaoks kontrollitakse, kas klassi päises deklareeritud tüübimuutuja on erinev globaalsetest nimedest.

          \begin{itemize}
            \item
              Iga meetodi jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest, klassi päises deklareeritud tüübimuutujast ja teineteisest.
          \end{itemize}
        \item
          Iga definitsiooni ja esindaja jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest ja teineteisest.

          \begin{itemize}
            \item
              Iga avaldise jaoks kontrollitakse, kas iga uus sisse toodud lokaalne muutuja on erinev teistest antud skoobis kehtivatest nimedest.

              \begin{itemize}
                \item
                  Funktsiooni rakendamise korral kontrollitakse seda tingimust eraldi funktsiooni jaoks ja seejärel argumendi jaoks.
                \item
                  Lambda-avaldise korral kontrollitakse, kas muutuja nimi on erinev teistest antud skoobis kehtivatest nimedest. Seejärel kontrollitakse lambda-avaldise keha uue keskkonna all, mis on saadud vanast keskkonnast vastava muutuja lisamise teel.
                \item
                  Mustrisobitus-avaldise korral kontrollitakse sobitatav avaldis. Seejärel kontrollitakse kõik harud.

                  \begin{itemize}
                    \item
                      Iga haru jaoks kontrollitakse, kas mustrisobituse jaoks sisse toodud muutujate nimed on erinevad teistest antud skoobis kehtivatest nimedest ja teineteisest.
                    \item
                      Haru resultaadiks olevat avaldist kontrollitakse uues keskkonnas, kuhu on lisatud ka mustrisobituse jaoks sisse toodud muutujate nimed.
                  \end{itemize}
              \end{itemize}
          \end{itemize}
      \end{itemize}
    \subsection{Tüübikontroll}
      Awful võimaldab andmetüüpe, klasse ning definitsioone ja esindajaid kirjutada ükskõik millises järjekorras, olenemata nende omavahelistest sõltuvustest. Selle tõttu läbib tüübikontrollija nii andmetüübid, klassid kui ka definitsioonid ja esindajad kaks korda.
      \subsubsection{Andmetüübid}
        
      \subsubsection{Klassid}
        
      \subsubsection{Definitsioonid ja esindajad}
        
    \subsection{Väärtustamine}
      Awfulis kustutatakse tüübikontrolli järel avaldiste tüübid. Väärtustaja kasutab avaldisi, mille küljes ei ole teavet tüüpide kohta.
      \subsubsection{Struktuurid}
        Väärtustajas on struktuur esitatud tüübi \verb!Map! abil. Struktuur on esitatud kui \verb!Map!, kus sõnedele (väljade nimedele) vastavad avaldised. Struktuuri välja leidmiseks kasutab väärtustaja \verb!Data.Map! mooduli meetodit \verb!lookup!.
      \subsubsection{Algebralised andmetüübid}
        Algebralise andmetüübi esitus väärtustajas on list väljade sisust, millele on lisatud konstruktori nimi. Konstruktori nimi on algebraliste andmetüüpide puhul erinevalt struktuurist vajalik, sest seda kasutatakse mustrisobitusel õige haru leidmiseks.
      \subsubsection{Hargnevad andmetüübid}
        Kuna hargnevate andmetüüpide peal ei tehta mustrisobitust ja nende puhul on vaja väljade nimesid, siis nende esitamiseks kasutab väärtustaja sama viisi mis struktuuride jaoks.
      \subsubsection{Funktsiooni rakendamine}
        Awful on agar keel. See tähendab, et juba enne funktsiooni rakendamise tulemuste arvutamist väärtustatakse kõik argumendid.
      \subsubsection{Defineerimata käitumine}
        Muutuja \verb!Crash! on keelde sisse ehitatud muutuja, mis esineb tüüpimiskeskkonnas, aga seda ei ole lisatud väärtustamiskeskkonda. Väärtustaja annab tulemuse \verb!Maybe! monaadi all, ning kui muutuja väärtustamiskeskkonnast leidmine ebaõnnestub (mis võib juhtuda ainult muutuja \verb!Crash! korral), antakse väärtustamise tulemuseks \verb!Nothing! ja kasutajale kuvatakse, et väärtustamise lõpptulemuseks oli \verb!Crash!.
      \subsubsection{Lambda-avaldised}
        Awfulis puudub let-avaldis ja Awfuli väärtustaja ei võimalda hetkel väärtustamiskeskkonda lokaalseid muutujaid lisada. Seetõttu on lambda-avaldise rakendamine teostatud asendamise abil: väärtustatakse argument, funktsiooni kehas asendatakse muutujanime kõik esinemised väärtustatud argumendiga, ja seejärel väärtustatakse tulemuseks olev avaldis.
      \subsubsection{Mustrisobitus}
        Mustrisobitus-avaldis on väärtustajas esitatud tüübi \verb!Map! abil, nagu ka struktuur. Alguses väärtustatakse sobitatav avaldis. Seejärel leitakse õige haru meetodi \verb!lookup! abil. Juhul, kui tegu on mustrisobitusega, mis toob sisse uusi lokaalseid muutujaid, asendatakse need muutujad vastavate avaldistega. Seejärel väärtustatakse tulemuseks olev avaldis.
      \subsubsection{Meetodid ja kitsendused}
        Kuna Awfuli väärtustajal ei ole teavet tüüpide kohta, ei saa meetodite puhul väärtustamise ajal otsustada, millist meetodi teostust on tarvis. Näiteks nähes nime \verb!Write_Brackets!, ei teaks väärtustaja, kas tegu on tähemärkide, täisarvude või mõne muu tüübi kirjutamise meetodiga.

        Jaotistes~\ref{peidetudargumendid} ja~\ref{haskklass} selgitasime, kuidas tüübiklassid võimaldavad anda sarnase otstarbega funktsioonidele sama nime ning lubavad vältida osade argumentide kirjutamist. Selleks, et saaks väärtustada ilma tüübiannotatsioonideta avaldisi, teostatakse tüübikontrolli järel vastupidine protsess~\cite{How}. Meetodite nimed täpsustatakse, nii et iga tüübi jaoks, mis on klassi esindaja, oleks meetodil unikaalne nimi. Kitsendused teisendatakse argumentideks. Kitsendatud funktsioonidele antakse lisa-argumendid.

        Näiteks kui meil on klass

        \begin{verbatim}Class C{T : Star}(f : T -> T)\end{verbatim}

        ning täisarvud ja kompleksarvud on selle klassi esindajad

        \begin{verbatim}Instance C{Int}(f = Negate)
Instance C{Complex T}<C T>(f = Complex (f (Real x)) (f (Imaginary x)))\end{verbatim}

        siis avaldis

        \begin{verbatim}f (Complex 1 0)\end{verbatim}

        teisendatakse enne väärtustamist järgmisele kujule:

        \begin{verbatim}f{Complex} f{Int} (Complex 1 0)\end{verbatim}

        Kui kasutaja jaoks on meetod \verb!f! ühe argumendiga funktsioon, siis väärtustaja näeb kitsendusi lisa-argumentidena. Näiteks meetodi \verb!f! teostus kompleksarvude jaoks näeb väärtustajas välja järgnev:

        \begin{verbatim}f{Complex} f{T} x = Complex (f{T} (Real x)) (f{T} (Imaginary x))\end{verbatim}
  \peatykk{Edasine töö}
    Awfuli peamisteks edasisteks eesmärkideks on võimalus kohelda liike kui kategooriaid ja klasse kui alamliike. Lisaks on kavas ka muud täiendused parandamaks keele kasutuskõlblikkust.
    \subsection{Liik kui kategooria}
      Tüüpe saab vaadelda kui kategooriat. Kategooria objektid on tüübid ning nooled tüüpide $T$ ja $U$ vahel on funktsioonid tüüpi $T$ \verb!->! $U$. Noolte kompositsiooniks on funktsioonide kompositsioon ja iga objekti (tüübi) ühiknool on vastava tüübi peal opereeriv ühikfunktsioon~\cite{Car, Fas}. Selline vaade tüüpidele kui kategooriale on võimalik ka Awfuli puhul.

      Kategooriatena saab aga vaadelda ka teisi liike peale liigi \verb!Star!, näiteks paaride liiki (mis annab meile korrutiskategooria) ja liiki \verb!Arrow!.
      \subsubsection{Kategooriate defineerimiseks vajalikud keele täiendused}
        Selleks, et liikide jaoks saaks defineerida noolte tüüpi, noolte kompositsiooni ja ühiknoolt, oleks Awfulit vaja täiendada järgmistel viisidel:

        \begin{itemize}
          \item
            Haskellis saab kategooriate defineerimiseks kasutada tüübiklasse, kuna Haskell võimaldab luua tüübiklasse, mis töötavad liikide mitte tüüpide peal, ning võimaldab tüübiklassi sees tüüpe defineerida. Awfuli tüübiklassid selliseid võimalusi hetkel ei paku. Üks võimalus Awfulis kategooriaid defineerida oleks tüübiklasse vastavalt täiendada. Teine võimalus oleks luua uus konstruktsioon tüübiklassidele sarnase süntaksiga, mis oleks mõeldud spetsiaalselt kategooriate defineerimiseks. Liigi \verb!Star! kategooria võik selles süntaksis välja näha näiteks niiviisi:

            \begin{verbatim}Category{Star}(
  T -> U = Function T U,
  Compose f g x = f (g x),
  Id x = x)\end{verbatim}

            Operaatoriga \verb!->! tähistame suvalise kategooria noole tüüpi, meetod \verb!Compose! tähistab noolte kompositsiooni ja meetod \verb!Id! tähistab ühiknoolt.
          \item
            Nagu näeme järgmistes jaotistes, on paljude kasulike kategooriate noolte tüübid liigipolümorfsed. Awfuli tüübisüsteemi on tegelikult juba ehitatud tugi liigipolümorfsete tüüpide jaoks, sest liigipolümorfsed tüübid on parametriseeritud andmetüüpide, näiteks listide edutamise vältimatu tagajärg. Tegu ei ole aga võimalusega, mida kasutajal on võimalik otse kasutada uute andmetüüpide loomisel -- süntaks ei võimalda liigimuutujaid kasutada.

            Keelt oleks tarvis täiendada viisil, mis lubaks kasutajal liigipolümorfseid andmetüüpe luua. Plaanis on lubada liigimuutujate sisse toomine topeltkandiliste sulgude abil, näiteks \verb![[K, L]]!. Süntaks võtab eeskuju tüübimuutujate omast, selle vahega, et kui tüübimuutujate puhul tuleb märkida liigid, siis liigimuutujate puhul ei ole sortide täpsustamist tarvis. Kuna ei ole plaanis lubada polümorfismi üle argumente nõudvate liigikonstruktorite, on kõik liigimuutujad ühest sordist.

            Lisaks on vaja sisse ehitada liigipolümorfsete funktsioonide tugi, mida hetkel ei ole. Seda on tarvis põhjusel, et liigipolümorfsete tüüpide andmekonstruktorid ja väljad on samuti liigipolümorfsed.
          \item
            Samuti selgub järgmiste jaotiste näiteid vaadeldes, et praegused võimalused tüübimuutujate sisse toomiseks ei ole piisavad. Vahel, kui meil on ainult ühe tüübikonstruktoriga liik, on kasulik teostada tüübi mustrisobitust otse seal, kus deklareerime tüübimuutujaid. Toome näiteks liigi \verb"!Wrapper", millel on ainult üks tüübikonstruktor \verb"!Wrapper". Tahame struktuuri \verb!Example! puhul kirjutada mitte \verb"[W : Wrapper K]", vaid \verb"[!Wrapper T : !Wrapper K]", selleks, et saaks tüübi \verb"!Wrapper" argumenti kasutada.

            \begin{verbatim}Struct Wrapper[T : Star](Unwrap : T)
Struct Example[[K]][!Wrapper T : !Wrapper K](f : T -> T)\end{verbatim}
          \item
            Tüübikonstruktorite liigi \verb!Arrow! kategooria kirjutamisel tekib vajadus anda andmekonstruktorile polümorfset argumenti. Seega peab keel lubama tüüpe, mis sisaldavad mitte ainult kogu tüübi peal kehtivaid üldsuse kvantoreid, vaid ka üldsuse kvantoreid, mis kehtivad ainult ühe funktsiooniargumendi peal, näiteks

            \begin{verbatim}Fun_Hom[F : Arrow Star Star, G : Arrow Star Star] :
  (Forall [T : Star] F T -> G T) -> Fun_Hom F G\end{verbatim}.
        \end{itemize}

        Järgnevates alamjaotistes toome mõned näited kategooriatest, mida võiks Awfulis defineerida saada.
      \subsubsection{Vastandkategooria}
        Kategooria \verb!K! vastandkategooria on kategooria, mis sisaldab samu objekte (tüüpe), aga kõik nooled on ümber pööratud. Vastandkategooria jaoks loome struktuuri

        \begin{verbatim}Struct Opp[T : Star](Opp' : T)\end{verbatim}

        Edutamise teel saadakse sellest ühe argumendiga liigikonstruktor \verb"!Opp" ning liigipolümorfne tüübikonstruktor \verb"!Opp" liiki \verb"K -> !Opp K", kus \verb!K! on suvaline liik. Lisaks objektidele on kategooria jaoks vaja ka nooli. Loome noolte jaoks tüübi

        \begin{verbatim}Struct Opp_Hom[[K]][!Opp T : !Opp K, !Opp U : !Opp K](Opp_Hom' : U -> T)\end{verbatim}

        Juhul, kui liik \verb!K! on kategooria, on kategooria ka liik \verb"!Opp K".

        \begin{verbatim}Category{!Opp K}<Category K>(
  T -> U = Opp_Hom T U,
  Compose (Opp_Hom f) (Opp_Hom g) = Opp_Hom (Compose g f),
  Id = Opp_Hom Id)\end{verbatim}
      \subsubsection{Korrutiskategooria}
        Korrutiskategooria moodustatakse kahest kategooriast \verb!K! ja \verb!L! niiviisi, et uue kategooria objektid (tüübid) on paarid, mille esimene element on kategooriast \verb!K! ja teine element kategooriast \verb!L!. Korrutiskategooria nooled on paarid kategooria \verb!K! ja kategooria \verb!L! noolte paaridest.

        Meil on juba olemas paaride tüüp ja andmekonstruktor. Sellest saab edutamise teel kahe argumendiga liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"K -> L -> !Pair K L", kus \verb!K! ja \verb!L! on suvalised liigid.

        \begin{verbatim}Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Loome paaride noolte tüübi:

        \begin{verbatim}Struct Pair_Hom[[K, L]][!Pair T U : !Pair K L, !Pair V W : !Pair K L](
  First_Hom : T -> V,
  Second_Hom : U -> W)\end{verbatim}

        Paaride kategooria kood näeks välja niiviisi:

        \begin{verbatim}Category{!Pair K L}<Category K, Category L>(
  T -> U = Pair_Hom T U,
  Compose (Pair_Hom f g) (Pair_Hom h i) =
    Pair_Hom (Compose f h) (Compose g i),
  Id = Opp_Hom Id)\end{verbatim}
      \subsubsection{Tüübikonstruktorite kategooria}
        Ka tüübikonstruktorid on kategooria, eeldusel et tulemuseks olevad tüübid moodustavad kategooria. Loome tüübikonstruktorite noolte tüübi, mis on liigipolümorfne üle tüübikonstruktori argumendi ja tulemuse liikide \verb!K! ja \verb!L! ning võtab kaks argumenti \verb!F! ja \verb!G! liigist \verb!Arrow K L!. Andmekonstruktor võtab argumendiks ühe funktsiooni, mis on polümorfne üle tüübi \verb!T! liigist \verb!K! ja mille tüüp on \verb!F T -> G T!.

        \begin{verbatim}Struct Fun_Hom[[K, L]][F : Arrow K L, G : Arrow K L](
  Fun_Hom'[T : K] : F T -> G T)
Category{Arrow K L}<Category L>(
  T -> U = Fun_Hom T U,
  Compose (Fun_Hom f) (Fun_Hom g) = Fun_Hom (Compose f g),
  Id = Fun_Hom Id)\end{verbatim}
    \subsection{Klass kui alamliik}
      Funktsioonid vajavad sageli kitsendusi. Näiteks kui meil on polünoomide tüüp \verb!Polynomial T!, siis enamik kasulikke definitsioone ja klasse, mida polünoomide jaoks kirjutada saab, nõuavad, et tüüp \verb!T! oleks kommutatiivne ring.

      Üks kasulik funktsioon, mida saab kirjutada tüübi \verb!F T! jaoks, kus \verb!F! on funktor ja \verb!T! on ring, on kõigi elementide sama väärtusega korrutamine. Niiviisi saame kirjutada skalaariga korrutamise funktsiooni paljude vektorruumide jaoks, näiteks kompleksarvud, maatriksid, kvaternionid ja vektorid. Toome siinkohal funktsiooni, mis korrutab kõik \verb!y! elemendid vasakult väärtusega \verb!x!. (Korrutamise järjekord on oluline juhul kui \verb!T! ei ole kommutatiivne ring.)

      \begin{verbatim}Def Multiply_left
  [T : Star, F : Arrow Star Star]<Functor F, Ring T>(x : T, y : F T) : F T =
    Fmap (Multiply x) y\end{verbatim}

      Ka polünoome saab arvuga läbi korrutada. Kuid erinevalt vektoritest ja maatriksitest, millel on kindel struktuur, mis jääb skalaariga korrutamise muutumatuks, koosneb polünoom kordajate listist, ning selle listi pikkus võib arvuga korrutamise käigus muutuda, juhul kui see arv annab kõige kõrgema liikme kordajaga korrutades tulemuseks nulli.

      Võtame näiteks polünoomi $p(x)=2x+3$ jäägiklassiringis mooduliga $4$. Korrutades polünoomi $p$ väärtusega $2$, saame tulemuseks $3p(x)=2$, sest $2$ ja $2$ on ringis mooduliga $4$ nullitegurid. Algse polünoomi kordajate list on pikkusega $2$, aga tulemuse kordajate listi pikkus on kõigest $1$. Seega võiks \verb!Fmap f! polünoomide korral pärast listi igale elemendile funktsiooni \verb!f! rakendamist eemaldada kõrgematesse kordajatesse tekkinud nullid, et polünoom oleks ka pärast arvuga korrutamist normaalkujul. Seda aga ei ole võimalik saavutada standartses Haskellis ega ka Awfulis, sest meetodi \verb!Fmap! tüüp on \verb!(T -> U) -> F T -> F U!, kus \verb!F! on funktor ning \verb!T! ja \verb!U! on kitsendamata tüübimuutujad. Samas \verb!Fmap! meetodi teostus polünoomide jaoks, mis kustutaks pärast funktsiooni rakendamist ebavajalikud nullid, nõuaks, et \verb!U! oleks ring (et oleks võimalik nulliga võrdlemine).

      Teine näide tüübikonstruktorist, mille puhul oleks klasside meetoditele lisakitsendusi vaja, on \verb!Set!~\cite{Cat}. Kuna \verb!Set T! peal töötavad funktsioonid eeldavad, et \verb!T! kuulub klassi \verb!Ord!, tekib tüübikonstruktori \verb!Set! jaoks \verb!Fmap! meetodi kirjutamisel sama probleem mis polünoomide puhul.
      \subsubsection{Kitsenduste liik Haskellis}
        Üks võimalik lahendus antud probleemile Haskellis on kitsenduste liik \verb!Constraint!. Näiteks saab Haskellis üldisema funktorite tüübi kirja panna järgmisel viisil~\cite{Cat}:

        \begin{verbatim}class Functor' f where
  type FConstraint f t :: Constraint
  fmap' :: (FConstraint f t, FConstraint f u) => (t -> u) -> f t -> f u\end{verbatim}

        Klass \verb!Functor'! sisaldab tüüpi \verb!FConstraint!, mis võimaldab anda \verb!f! argumendile kitsendusi. Kõik tüübid, mis on klassi \verb!Functor! esindajad, on ka klassi \verb!Functor'! esindajad. Lisaks saab klassi \verb!Functor'! esindajaks teha selliseid tüübikonstruktoreid nagu \verb!Set!, mille operatsioonid seavad tüübiargumendile kitsendusi.

        \begin{verbatim}instance Functor' Set where
  type FConstraint Set t = Ord t
  fmap' f x = fromList (fmap f (elems x))\end{verbatim}
      \subsubsection{Klass alamliigina}
        Liigi \verb!K! peal töötavat klassi saab vaadelda liigi \verb!K! alamliigina. Muuhulgas võimaldab see teha kitsendatud operatsioonidega tüüpe tüübiklasside esindajateks ilma kitsenduste liiki kasutamata.

        Toome näite sellest, kuidas see võiks toimida klassi \verb!Functor! jaoks. Muudame klassi \verb!Functor! liigipolümorfseks, andes talle liigimuutujad \verb!K! ja \verb!L!. Tüübimuutuja \verb!F! liik on nüüd mitte \verb!Arrow Star Star! vaid \verb!Arrow K L! arvestamaks sellega, et funktor ei pruugi olla liigi \verb!Star! endofunktor~\cite{Cat}, vaid võib olla funktor kahe suvalise liigi vahel, mille jaoks on defineeritud kategooria koos vastava noole tüübiga.

        Meetodi \verb!Fmap! t on sarnane mis enne, selle vahega, et tüübimuutujate \verb!T! ja \verb!U! liik on nüüd \verb!K!. Meetod \verb!Fmap! tavalise funktori korral on meetod, mis võtab argumendiks funktsioon tüüpi \verb!T -> U! ja teeb sellest funktsiooni \verb!F T -> F U!. Üldistatult saab seda vaadata kui meetodit, mis võtab argumendiks liigi \verb!K! noole tüüpide \verb!K! ja \verb!U! jaoks ning tagastab liigi \verb!L! noole tüüpide \verb!F T! ja \verb!F U! jaoks.

        \begin{verbatim}Class Functor[[K, L]]{F : Arrow K L}(
  Fmap[T : K, U : K] : (T -> U) -> F T -> F U)\end{verbatim}

        Juhul, kui kohtleme klasse alamliikidena, saab tüübikonstruktori \verb!Set! liiki panna kirja kui \verb!Arrow Ord Star!, mis võimaldab teha \verb!Set! klassi \verb!Functor! esindajaks.
    \subsection{Mitmene pärilus}
      Awfuli tüübiklasside kõige olulisem puudus võrreldes Haskelli omadega on mitmese päriluse puudumine. Edasise töö käigus on plaanis täiendada Awfuli tüübiklasse toetamaks mitmest pärilust.
    \subsection{Mustrisobitus tüübimuutujate peal}\label{eemaldadatyybiklassihakk}
      Hetkel on ainus viis hargnevate andmetüüpide peal funktsioone teostada kasutada abitüübiklasse -- seda lahendust kirjeldasime jaotises~\ref{tyybiklassihakk}. Selle asemel on kavas võimaldada mustrisobituavaldist tüübimuutujate peal. Mustrisobitus tüübimuutuja mitte andmetüübi enda peal võimaldaks ilma abiklasse kirjutamata ka selliseid meetodeid, millel ei ole argumente ja mille jaoks ei ole mustrisobitus argumentide peal seega põhimõtteliselt võimalik. Toome siinkohal näite vektorite tüübist kui \verb!Applicative! klassi esindajast.

      \begin{verbatim}Instance Applicative{Array N}(
  Apply =
    Match N {
      !Zr -> _ -> _ -> Empty_Array,
      !Next N' ->
        Construct_Array f x -> Construct_Array y z ->
          Construct_Array (f y) (Apply x z)},
  Lift x =
    Match N {!Zr -> Empty_Array, !Next N' -> Construct_Array x (Lift x)})\end{verbatim}
    \subsection{Meetodi teostuse eksplitsiitne täpsustamine}
      Kavas on lisada võimalus eksplitsiitselt täpsustada meetodi teostus. Pöördume tagasi alamjaotises~\ref{haskstd} toodud näite juurde meetodist, mille teostust ei ole võimalik tüübist tuletada.

      \begin{verbatim}Class Bug{T : Star}(bug : Int)\end{verbatim}

      Juhul, kui võimaldada avaldiste sees meetodi teostust eksplitsiitselt täpsustada, näiteks \verb!bug{Char}! või \verb!bug{Int}! või \verb!bug{List T}! või \verb!bug{T}!, ei ole tüübi mittetuletatavus enam takistuseks meetodi kasutamisele.
    \subsection{Kasutusmugavus ja süntaktiline suhkur}
      Magistritöö raames keskendus töö tüübiklasside ja edutamise arendamisele ning töö skoobist jäid välja mõned keele võimalusi otseselt mitte laiendavad, aga kasutusmugavuse seisukohast olulised aspektid. Järgmised täiendused on plaanis tulevikus teostada, et muuta keel loetavamaks ja kasutajasõbralikumaks.
      \subsubsection{Operaatorid}
        Hetkel on Awfuli süntaksi kõige suuremaks probleemiks operaatorite puudumine. See põhjustab pikemate avaldiste raskestiloetavust. On plaanis lisada võimalus lubada kasutajal binaarseid operaatoreid defineerida, sealhulgas ka tüübikonstruktorite jaoks (näiteks et oleks võimalik lühemalt kirja panna funktsiooni ja paari tüüpi).
      \subsubsection{Süntaktiline suhkur tüübitaseme naturaalarvude jaoks}
        Üks edutamise oluline rakendus on tüübitaseme naturaalarvud. Kuna neid esineb võrdlemisi palju (näiteks vektorite ja maatriksite puhul), on oluline, et kui kasutaja tahab näiteks kirjutada funktsiooni, mis töötab kolmemõõtmeliste vektorite peal, saaks ta vektorite pikkuseks kirjutada \verb!3! mitte \verb"!Next (!Next (!Next !Zr))".
      \subsubsection{Struktuuride mustrisobitus}
        Operaatorite puudumise järel on Awfuli liigpikkade avaldiste ja halva loetavuse teine olulisim allikas struktuuride mustrisobituse puudumine. Selle tõttu on vaja sageli väljade nimesid kasutada.

        \begin{verbatim}Instance Bifunctor{Pair}(Bimap f g x = Pair (f (First x)) (g (Second x)))\end{verbatim}

        Tulevikus on plaanis lisada struktuuride mustrisobituse võimalus:

        \begin{verbatim}Instance Bifunctor{Pair}(Bimap f g (Pair x y) = Pair (f x) (g y))\end{verbatim}
      \subsubsection{Let-avaldis}
        Veel üks oluline viis koodi loetavust parandada on let-avaldis. Kas tegu saab olema järjestikuse let-avaldisega või let-avaldisega, mis lubab rekursiooni, on veel lahtine. Esimese variandi eeliseks on teostuse lihtsus. Järjestikust let-avaldist võib kohelda kui süntaktilist suhkrut lambda-avaldisele ning vastava teisenduse saab teha juba parsimise ajal või vahetult selle järel. Sellisel juhul ei ole vajalik kuidagi täiendada nimekontrolli, tüübikontrolli ega väärtustajat.
      \subsubsection{Detailsemad veateated}
        Hetkel antakse tüübivigade puhul ainult funktsioon, kus viga tekib. Ei öelda täpsemat põhjust. Tulevikus on plaanis veateatele lisada teave selle kohta, millise kahe tüübi unifitseerimine ebaõnnestus.

        Teine veateadete liik, mida saaks oluliselt informatiivsemaks muuta, on veateated, mis tulenevad sellest, et kitsendatud meetodit üritatakse kutsuda väärtuse peal, mille tüübi jaoks need klassikitsendused ei kehti.

        \begin{verbatim}Def Max[T : Star](x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Antud näites on kasutaja unustanud kirjutada tüübikitsenduse, mistõttu funktsioon ei tüüpu. Hetkel öeldakse veateates, et vea põhjustas klass \verb!Ord!, aga kasutajale ei öelda, et vea põhjustas meetod \verb!Compare! ja et tüüp, mille jaoks klassikitsendus täitmata on, on \verb!T!. Kasutaja peab ise välja mõtlema, kas viga tuleb puuduvast tüübimuutuja kitsendusest või hoopis kirjutamata jäänud klassi esindajast. Veateade, mis ütleks, mis tüübi või tüübimuutuja jaoks on kitsendus rahuldamata, aitaks seda laadi vigu kiiremini parandada.
  \peatykk{Kokkuvõte}
    Käesoleva töö teemaks olev keel Awful on staatiliselt tüübitud puhas funktsionaalne programmeerimiskeel. Töö käigus sai loodud Awfuli interpretaator ning kirjutatud keele süntaksi formaalne spetsifikatsioon ja keele kirjeldus koos ülevaatega vajalikest programmeerimiskeelte alastest taustateadmistest.

    Erinevalt Haskellist, kus on kasutusel tavalised algebralised andmetüübid ning üldistatud algebralised algebralised andmetüübid, on Awfulis struktuurid, mis on mõeldud ühe konstruktoriga tüüpide jaoks, algebralised andmetüübid, mis sarnanevad Haskelli algebralistele andmetüüpidele selle erinevusega et nõuavad vähemalt kahte konstruktorit, ning hargnevad andmetüübid, mis võimaldavad teatud piiratud juhtudel asendada üldistatud algebralisi andmetüüpe ilma tüübisüsteemi oluliselt täiendamata.

    Awfuli tüübi- ja liigisüsteemi on täiendatud andmetüüpide edutamisega võttes eeskuju Haskellist. Edutamine muudab tüübisüsteemi rikkalikumaks, võimaldades tüübiturvaliselt luua näiteks tüübitaseme naturaalarvusid ja liste. Käesolev töö näitab, et edutatud liikidele ja tüüpidele leidub kasulikke rakendusi ka keeles, milles puuduvad üldistatud algebralised andmetüübid. Awfuli hargnevad admetüübid võimaldavad paljusid kasulikke edutamise rakendusi, näiteks staatilise pikkusega vektoreid ning üldistatud ennikuid.

    Awfulis on olemas \textit{ad hoc} polümorfism. Awfuli tüübiklassid võtavad üldjoontes eeskuju standartsest Haskellist. Ainus olulisem erinevus on mitmese päriluse puudumine, mis on kavas teostada edasise töö käigus. Käesolev töö näitab muuhulgas, kuidas tüübiklasse saab kasutada loomaks hargnevate andmetüüpide peal töötavad funktsioone, juhul kui keel ei toeta mustrisobitust tüübimuutujate ega hargnevate andmetüüpide peal. Tegu on võttega, mida saab kasutada ka Haskellis nendel juhtudel, kus üldistatud algebraliste andmetüüpide jaoks on vaja kirjutada meetodeid, mis ei võimalda mustrisobitust argumendi peal, näiteks klassi \verb!Applicative! meetod \verb!pure!.

    Edasise töö käigus on plaanis täiendada keelt võimalustega käsitleda liike kui kategooriaid ja klasse kui alamliike. See laseks üldistada teatud tüübiklasse (näiteks \verb!Functor!) ja võimaldaks muuhulgas lahendada probleemi kitsendatud meetoditega, näiteks meetodi \verb!Fmap! teostus tüübi \verb!Set! jaoks, mis nõuab Haskellis kitsenduste liiki. Teised olulisemad täiendused, mis on kavas, on mustrisobitus tüübimuutujate peal (eesmärgiga parandada hargnevate andmetüüpide kasutajasõbralikkust), mitmene pärilus ning võimalus meetodi kutsel teostus eksplitsiitselt spetsifitseerida, näiteks \verb!Add{Int}!. Lisaks on plaanis hulk väiksemaid täiendusi, peamiselt kasutusmugavuse ja süntaksi vallas: operaatorid, süntaktiline suhkur tüübitaseme naturaalarvude jaoks, struktuuride mustrisobitus, let-avaldis ja detailsemad veateated.
  \newpage
  \addcontentsline{toc}{section}{\refname}
  \bibliography{bachelor-thesis}
  \peatykktarn{Litsents}
    \subsection*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele kättesaadavaks tegemiseks}
      Mina, \textbf{Liisi Kerik},

      \begin{enumerate}
        \item
          annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose

          \textbf{\pealkiri}

          mille juhendaja on Härmel Nestra

          \begin{enumerate}
            \item[1.1]
              reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni;
            \item[1.2]
              üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace´i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
          \end{enumerate}
        \item
          olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
        \item
          kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi. 
      \end{enumerate}

      \noindent
      Tartus, 21.05.2018
\end{document}