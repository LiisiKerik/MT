% Institute of Computer Science thesis template
% authors: Sven Laur, Liina Kamm
% last change Tõnu Tamme 09.05.2017
\documentclass[12pt]{article}
\usepackage{CormorantGaramond}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{array}
\usepackage[english, estonian]{babel}
\usepackage[labelsep = period]{caption}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{inconsolata}
\usepackage[utf8x]{inputenc}
\usepackage{listings}
\usepackage{proof}
\usepackage{todonotes}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{xspace}
\addto\captionsestonian{
  \renewcommand\refname{Viidatud kirjandus}
}
\bibliographystyle{plain}
\definecolor{hall}{RGB}{128,128,128}
\definecolor{helehall}{RGB}{192,192,192}
\definecolor{roheline}{RGB}{0,128,0}
\newcommand\peatykk[1]{
  \clearpage
  \section{#1}}
\newcommand\peatykktarn[1]{
  \clearpage
  \section*{#1}
  \addcontentsline{toc}{section}{#1}}
\newcommand\markus[1]{\textcolor{roheline}{\textbf{#1}}}
\begin{document}
  \thispagestyle{empty}
  \begin{center}
    \large
      TARTU ÜLIKOOL\\
      Arvutiteaduse instituut\\
      Informaatika õppekava\\

    \vspace{25mm}

    \Large
      Liisi Kerik

    \vspace{4mm}

    \huge
      Funktsionaalse programmeerimiskeele liigisüsteem

    \vspace{20mm}

    \Large
      Magistritöö (30 EAP)
  \end{center}

  \vspace{2mm}

  \begin{flushright}
    {
      \setlength{\extrarowheight}{5pt}
      \begin{tabular}{rl} 
        Juhendaja: & Härmel Nestra, PhD
      \end{tabular}}
  \end{flushright}
  \vfill
  \centerline{Tartu 2018}
  \newpage
{
\selectlanguage{estonian}
\noindent\textbf{\large Funktsionaalse programmeerimiskeele liigisüsteem}

\vspace*{1ex}

\noindent\textbf{Lühikokkuvõte:} 

\markus{One or two sentences providing a basic introduction to the field, comprehensible to a scientist in
any discipline.}

\markus{Two to three sentences of
more detailed background, comprehensible to scientists in related disciplines.}

\markus{One sentence clearly stating the general problem being addressed by this particular
study.}

\markus{One sentence summarising the main result (with the words ``here we show´´ or their equivalent).}

\markus{Two or three sentences explaining what
the main result reveals in direct
comparison to what was thought to be the case previously, or how the main result adds to previous knowledge.}

\markus{One or two sentences to put the results into a more general context.}

\markus{Two or three sentences to provide a broader perspective, readily comprehensible to a scientist in any discipline, may be included in the first paragraph if the editor considers that the accessibility of the paper is significantly enhanced by their inclusion.}

\vspace*{1ex}

\noindent
\textbf{Võtmesõnad:} funktsionaalprogrammeerimine, liigid, edutamine, tüübisüsteemid

\vspace*{1ex}

\noindent\textbf{CERCS:} P175 Informaatika, süsteemiteooria

\vspace*{1ex}}

{
\selectlanguage{english}
\noindent
\textbf{\large Type Inference for Fourth Order Logic Formulae}

\vspace*{3ex}

\noindent
\textbf{Abstract:}

\noindent
Many interpreting program languages are dynamically typed, such as Visual Basic or Python. As a result, it is easy to write programs that crash due to mismatches of provided and expected data types.  One possible solution to this problem is automatic type derivation during compilation. In this work, we consider study how to detect type errors in the \textsc{Whitespace} language by using fourth order logic formulae as annotations. The main result of this thesis is a new triple-exponential type inference algorithm for the fourth order logic formulae. This is a significant advancement as the question whether there exists such an algorithm was an open question. 
All previous attempts to solve the problem lead lead to logical inconsistencies or required tedious user interaction in terms of interpretative dance. Although the resulting algorithm is slightly inefficient, it can be used to detect obscure programming bugs in the \textsc{Whitespace} language. The latter significantly improves productivity. Our practical experiments showed that productivity is comparable to average Java programmer.   
From a theoretical viewpoint, the result is only a small advancement in rigorous treatment of higher order logic formulae. The results obtained by us do not generalise to formulae with the fifth or higher order. 

\vspace*{1ex}

\noindent
\textbf{Keywords:} functional programming, kinds, promotion, type systems

\vspace*{1ex}

\noindent
\textbf{CERCS:} P175 Informatics, systems theory

\vspace*{1ex}
}
\newpage
  \tableofcontents
  \peatykktarn{Tänusõnad}
    
  \peatykk{Sissejuhatus}
    \markus{What is it in simple terms (title)?} Käesoleva töö eesmärgiks oli arendada funktsionaalse programmeerimiskeele tüübisüsteemi.

    \markus{Why should anyone care?}

    \markus{What was my contribution?} Käesoleva töö tulemuseks on funktsionaalne programmeerimiskeel nimega Awful. Awful on puhasfunktsionaalne interpreteeritud agar keel. Üks keele oluline erinevus teistest funktsionaalsetest programmeerimiskeeltest on viis, kuidas on teostatud andmestruktuurid. Kui Haskellis on olemas algebralised andmetüübid ja üldistatud algebralised andmetüübid, siis Awful asendab

    \markus{What you are doing in each section (a sentence or two per section)}

    Tip: if it's hard for you to start writing, then try to split it to smaller parts, e.g. if the title is ``Type Inference for a Cryptographic Protocol Prover Tool'' then the ``What is it'' can be divided into ``what is type inference'', ``what is cryptographic protocol'' and ``what is the prover tool''. These three can also be split to smaller parts etc.

    \markus{1) Motivatsioon 2) Mis sai valmis; tulemused 3) Mis mitte}
  \peatykk{Tüübiklassid}
    \markus{sissejuhatav lõik: ad hoc polümorfism, mis on, milleks vajalik. paar näidet? lühidalt mainida teiste keelte ad hoc polümorfismi tegemise viise?}

    \markus{mainida, et ad hoc polümorfism on eriti kasulik kui tahta kasutada operaatoreid, nt + ja *}
  \peatykk{Üldistatud algebralised andmetüübid}
    \markus{TODO: kusagil seletada, mis on hargnevate andmetüüpide piirangud võrreldes GADT-ga. Mis kasulikke asju nende abil teha ei saa; näited}
  \peatykk{Tüübitaseme andmed ja edutamine}
    \markus{TODO: siin peatükis on vaja viidata} Selles peatükis refereerime, mis on edutamine ning kuidas see muudab tüübisüsteemi väljendusrikkamaks ja aitab kirjutada tüübiturvalisemat koodi. Kuna autori loodud keelt tutvustatakse alles peatükkides~\ref{syntaks} ja~\ref{manual}, ja kuna Haskell on esimene keel mille tüübisüsteem sisaldab edutamist~\cite{Giv}, on antud peatükis edutamise põhimõtete selgitamiseks kasutatud Haskelli süntaksit.

    Sageli on tüübiturvalisema koodi kirjutamiseks kasulik, kui saab tüüpide tasemel väärtusi kasutada. Näiteks võimaldavad tüübitaseme naturaalarvud luua vektoreid, mille pikkus, erinevalt listide omast, on teada. See võimaldab kirjutada vektorite liitmise või skalaarkorrutise funktsiooni tüübiturvaliselt, ja lisaks kannavad tüübid kasulikku teavet andmete kohta. Näiteks saab funktsiooni tüüpi vaadates kohe teada, et kaks vektorit peavad olema sama pikad, või et vektor ei tohi olla pikkusega null.

    Tüübitaseme andmed aitavad kaasa tüübiturvalisusele, vähendavad korduva koodi hulka ning lisaks aitavad kaasa sellele, et tüübisüsteem oleks väljendusrikkam ja tüübid dokumenteeriks paremini funktsioonide sisu.
    \subsection{Tüübitaseme andmed}
      Mõnedes keeltes, näiteks Agda, Coq ja Idris, kasutatakse tüübitaseme andmete saavutamiseks sõltuvaid tüüpe. Sõltuvatest tüüpidest anname lühikese ülevaate jaotises~\ref{soltuvad}. Keeles, kus sellist võimalust ei ole, saab tüübitaseme andmeid kirjutada otse, näiteks naturaalarvud näeksid Haskelli algebralisi andmetüüpe kasutades välja sellised:

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Sarnasel viisil saab teostada ka näiteks tüübitaseme liste:

      \begin{verbatim}data Empty_List
data Construct_List t l\end{verbatim}

      Toome mõned lihtsad näited sellest, milleks saab tüübitaseme andmeid kasutada. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada.

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua \verb!n! muutuja Boole'i funktsiooni tüüp.

      \begin{verbatim}data Fun :: * -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüübitaseme listide abil saame luua üldistatud ennikuid.

      \begin{verbatim}data Tuple :: * -> * where
  Empty_Tuple :: Tuple Empty_List
  Construct_Tuple :: t -> Tuple l -> Tuple (Construct_List t l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõigi mõõtmete pikkus on tüübi tasemel teada.

      \begin{verbatim}data Array' :: * -> * -> * where
  Empty_Array' :: t -> Array' Empty_List t
  Construct_Array' :: Array n (Array' l t) -> Array' (Construct_List n l) t\end{verbatim}

      Niiviisi teostatud tüübitaseme andmetel on oluline puudus. Liigisüsteem ei ole piisavalt keeruline kirjeldamaks programmeerija tegelikke kavatsusi. Tüübid ei ole piisavalt tugevalt tüübitud. Ei ole liike, mis lubaks kirjeldada, et kohas kus võib esineda näiteks tüüp \verb!Char! või \verb!Int!, ei tohi esineda naturaalarvuline tüüp, ja vastupidi~\cite{Giv}. Tüübikontrollist lähevad läbi koodinäited, mis ei ole programmeerija tegelike kavatsustega kooskõlas, näiteks:

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next t) n\end{verbatim}

      Siin on konstruktori \verb!Construct_Array! tulemuse tüübis vahetusse läinud tüübimuutujad \verb!n! ja \verb!t!. Koodinäide ei tohiks tegelikult tüüpuda. Vältimaks selliseid vigu, oleks vaja liigisüsteemi, mis on piisavalt võimas kirjeldamaks, et tüübikonstruktori \verb!Array! esimene argument peab olema naturaalarv ja teine tavaline tüüp.

      Lisaks eelmainitud peamisele puudusele, on oluline miinus ka see, et programmeerija peab tüüpide tasemel duplitseerima andmeid, mis on algebralise andmetüübi kujul tegelikult juba olemas. Edutamine lahendab need probleemid, lubades andmetüübid "üks tase ülespoole" tõsta: tüüpidest saavad automaatselt liigid ja andmekonstruktoritest saavad vastavate liikide tüübid~\cite{Giv}.
\begin{comment}
  \begin{frame}[fragile]{Promotion}
    The solution is a more expressive kind system. \textit{Promotion} automatically makes new kinds and types from algebraic data types. Everything moves up one level.
    \begin{itemize}
      \item
        Type constructor -> Kind constructor
      \item
        Type parameter (of kind \verb!*!) -> Kind parameter
      \item
        Data constructor -> Type constructor
      \item
        Data constructor argument type -> Type constructor argument kind
    \end{itemize}
  \end{frame}
  \begin{frame}[fragile]{An Example of Promotion}
    \begin{kood}{Lists}
      \begin{verbatim}
data Lst (t :: *) = LNil | LCons t (Lst t)\end{verbatim}
    \end{kood}
    \begin{itemize}
      \item
        Data constructors:
        \begin{itemize}
          \item
            {\color{blue}\verb!LNil :: Lst (t :: *)!}
          \item
            {\color{blue}\verb!LCons :: (t :: *) -> Lst t -> Lst t!}
        \end{itemize}
      \item
        Type constructors:
        \begin{itemize}
          \item
            {\color{blue}\verb!Lst :: * -> *!}
          \item
            {\color{crimson}\verb!LNil :: Lst k!}
          \item
            {\color{crimson}\verb!LCons :: k -> Lst k -> Lst k!}
        \end{itemize}
      \item
        Kind constructor:
        \begin{itemize}
          \item
            {\color{crimson}\verb!Lst :: * -> *!}
        \end{itemize}
    \end{itemize}
  \end{frame}
  \begin{frame}[fragile]{Examples Revisited}
    \begin{kood}{Lists With Type-Level Emptiness Information}
      \begin{verbatim}
data List' :: Bool -> * -> * where
  Empty :: List' False (t :: *)
  Nonempty ::
    (t :: *) -> List' (b :: Bool) t -> List' True t\end{verbatim}
    \end{kood}
    \begin{kood}{Finite Rings}
      \begin{verbatim}
data Fin :: Nat -> * where
  FZero :: Fin (NSucc (n :: Nat))
  FSucc :: Fin (n :: Nat) -> Fin (NSucc n)\end{verbatim}
    \end{kood}
  \end{frame}
  \begin{frame}[fragile]{Examples Revisited}
    \begin{kood}{Vectors}
      \begin{verbatim}
data Vec :: Nat -> * -> * where
  VNil :: Vec NZero (t :: *)
  VCons ::
    (t :: *) -> Vec (n :: Nat) t -> Vec (NSucc n) t\end{verbatim}
    \end{kood}
    \begin{kood}{Boolean Functions (Shannon Expansions)}
      \begin{verbatim}
data Fun :: Nat -> * where
  Constant :: Bool -> Fun NZero
  Branch :: Fun (n :: Nat) -> Fun n -> Fun (NSucc n)\end{verbatim}
    \end{kood}
  \end{frame}
  \begin{frame}[fragile]{Examples Revisited}
    \begin{kood}{Generalised Tuples}
      \begin{verbatim}
data Prod :: [*] -> * where
  PNil :: Prod LNil
  PCons ::
    (t :: *) -> Prod (l :: [*]) -> Prod (LCons t l)\end{verbatim}
    \end{kood}
    \begin{kood}{Generalised Either}
      \begin{verbatim}
data Sum :: [*] -> * where
  SLeft :: (t :: *) -> Sum (LCons t (l :: [*]))
  SRight ::
    ((t :: *) -> Sum (l :: [*])) ->
    Sum (LCons (u :: *) l)\end{verbatim}
    \end{kood}
  \end{frame}
  \begin{frame}[fragile]{Examples Revisited}
    \begin{kood}{Multidimensional Vectors}
      \begin{verbatim}
data Multivec :: [Nat] -> * -> * where
  ZDimensional :: (t :: *) -> Multivec LNil t
  NDimensional ::
    Vec (n :: Nat) (Multivec (l :: [Nat]) (t :: *)) ->
    Multivec (LCons n l) t\end{verbatim}
    \end{kood}
  \end{frame}
  \begin{frame}[fragile]{The New Kind and Type System}
    \begin{tabular}{c||c|c}
            & Old                  & New              \\\hline\hline
      Sort & Not necessary        & \verb!* | * -> k! \\\hline
      Kind & \verb!* | k -> l!    & \verb!Name | k l! \\\hline
      Type & No kind polymorphism & Kind polymorphism
    \end{tabular}
\end{comment}
    \subsection{Edutamine}
      \subsubsection{Andmetüübid, mida saab edutada}
        Edutamisele on mõistlik seada teatud piirangud ning edutada ainult osasid andmetüüpe, mitte kõiki. Piirangud on seotud sooviga kasutada edutamise võimalusi (näiteks tüübitaseme naturaalarvusid ja liste) ilma muutmata tüübisüsteemi keerulisemaks kui hädapärast vajalik. Loetleme siinkohal piirangud, mida on kasutatud Haskellis~\cite{Giv}.

        \begin{itemize}
          \item
            Ei edutata üldistatd algebraliseid andmetüüpe. \markus{Too difficult to promote as they would complicate the kind system with equality constraints and coercions.}
          \item
            Ei edutata primitiive.
          \item
            Ei edutata andmetüüpe, millel on tüübiparameetreid muud liiki kui liik \verb!*!. Juhul kui edutada ainult sellele kitsendusele vastavaid andmetüüpe, on sortide (liigi-tüüpide) süsteem äärmiselt lihtne. Kõik liigimuutujad ühte sorti. See tähendab, et liigipolümorfismi korral ei pea liigimuutujate sorte märkima. Liigikonstruktorite sortideks on lihtsalt naturaalarvud, mis näitavad, mitut liigiargumenti nad vajavad.

            Juhul, kui soovida edutada andmetüüpe, mis sisaldaks tüübiparameetrites mitte ainult liiki \verb!*! vaid ka liigikonstruktorit \verb!->!, ei ole sellele põhimõttelisi takistusi, aga oleks kohe vaja keerulisemat sortide süsteemi. Liigimuutujad võivad olla erinevat sorti. Liigipolümorfismi korral oleks vaja liigimuutujate sorte märkida. Edutamise teostamine muutuks keerulisemaks, samas kui vajadus sellise võimsusega liigisüsteemi järele on küsitav.

            Kui tahta minna veel kaugemale ja edutada andmetüüpe, mis on parametriseeritud üle omakorda edutamise teel saadud liikide, oleks see veel keerulisem. \markus{miks? vaadata uuesti artiklit, kirjeldada mis probleemid tekivad}
          \item
            Loomulikult ei tohi edutada ka andmetüüpe, millel on andmekonstruktoreid, mis võtavad mitte-edutatavat tüüpi argumente. Kuna andmekonstruktorite edutamisel muutub tüüp liigiks, aga mitte-edutatavat tüüpi liigiks muuta ei saa, ei ole see võimalik. Seega andmetüübi mitte-edutatavus levib kõigile teistele andmetüüpidele mis teda otseselt või kaudselt kasutavad.
        \end{itemize}

        Samu piiranguid on kasutatud ka Awful keeles. Reegli asemel, et ei edutata üldistatud algebralisi andmetüüpe, on Awful tüübisüsteemis reegel, et ei edutata
\begin{comment}
    \begin{kysimus}{Should we promote this?}
      \begin{verbatim}
data Fun (t :: *) (u :: *) = Fun (t -> u)\end{verbatim}
    \end{kysimus}
\end{comment}
    \subsection{Edutamisega kaasnev nimekonflikt}
      Haskellis on tihti tavaks, et andmetüübi konstruktori nimi ühtib tüübi nimega, näiteks

      \begin{verbatim}data Pair t u = Pair t u\end{verbatim}

      Kuna andmekonstruktor \verb!Pair! esineb ainult avaldiste tasandil ja sama nimega tüübikonstruktor esineb ainult tüüpide tasandil, ei teki vajadust neil kahel vahet teha. Edutamine muudab olukorda.

      Edutades ülalpool mainitud andmetüüpi, saame lisaks tüübikonstruktorile \verb!Pair! liiki \verb!* -> * -> *! samanimelise tüübikonstruktori liiki \verb!t -> u -> Pair t u!, kus t ja u on liigimuutujad ning \verb!Pair! on edutamise teel saadud liigikonstruktor. Seega on kaks erineva liigi ja otstarbega aga samanimelist tüübikonstruktorit. Nendel vahet tegemiseks on mitmeid erinevaid võimalusi.
      \subsubsection{Eksplitsiitne edutamine vajaduse korral}
        Haskellis kasutatakse juhtudel, kus tekib nimede konflikt, edutamise teel saadud tüübikonstruktori ees ülakoma~\cite{Giv}. Antud näite korral tähistab tüübikonstruktor \verb!Pair! tavalist tüübikonstruktorit liiki \verb!* -> * -> *! ning \verb!'Pair! tähistab edutamise teel saadud tüübikonstruktorit liiki \verb!t -> u -> Pair t u!.

        Tasub mainida ka, et juhul kui kasutaja otsustab Haskellis \verb!-Wall! võtit kasutada, antakse hoiatused kõigi edutamise teel saadud tüübikonstruktorite kohta, mille ette ei ole ülakoma pandud, ka nende kohta, mille puhul ei ole nimekonflikti võimalust~\cite{Gla}.
      \subsubsection{Nimekonflikti vältimine}
        Üks võimalus nimekonflikti lahendada on keelata tüübikonstruktori ja andmekonstruktori nimede ühtimine.

        \begin{verbatim}data Pair t u = MkPair t u\end{verbatim}

        Antud lahendus on lihtne, aga tal on puudusi. Nii on võimalik vältida edutamise eksplitsiitset märkimist, aga samas muutuvad pikemaks tavalised andmekonstruktorid. Programmeerijatele, kes on harjunud tüübikonstruktorit ja andmekonstruktorit sama nimega nimetada, võib olla kergem kohaneda edutamise eksplitsiitse märkimisega kui andmekonstruktorite teisiti nimetamisega.
      \subsubsection{Eksplitsiitne edutamine alati}
        Nimekonflikti saab lahendada ka märkides kõik edutamise teel saadud liigid ja tüübid mõne spetsiaalse sümboliga, näiteks ülalpool mainitud andmetüübi \verb!Pair! deklaratsioon annaks lisaks tavalisele andmekonstruktorile ja tüübikonstruktorile ka 2 argumendi liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"t -> u -> !Pair t u".

        Käesoleva töö autori arvates on tegu hea lahendusega, sest erinevalt eksplitsiitsest edutamisest ainult vajaduse korral näevad edutamise teel saadud tüübikonstruktorid ühtlasemad välja. Lisaks võib edutamise teel saadud liigi- ja tüübikonstruktorite eksplitsiitne eristamine aidata programmeerijat, kes ei ole veel edutamisega harjunud ja ei tunne end kindlalt seda abstraktsiooni kasutades. Täpselt nagu tüüpide juurde märkimine võib vahel koodi isedokumenteeruvusele kaasa aidata, võib seda teha ka edutamise teel saadud tüübikonstruktorite eksplitsiitne märkimine.

        Selle tõttu ongi tegu lahendusega, mis sai valitud käesoleva töö raames loodud programmeerimiskeele jaoks. Awful kasutab edutamise tähistamiseks hüüumärki ning nõuab seda nii edutamise teel saadud liikide kui ka tüüpide ees.
    \subsection{Sõltuvad tüübid}\label{soltuvad}
      Mõnedes keeltes, näiteks Agda, Coq ja Idris, on olemas sõltuvad tüübid. \markus{TODO: viited nende keelte kohta.} Sõltuvad tüübid tähendavad, et tüübid võivad sõltuda väärtustest. Sõltuvad tüübid on võimsamad kui edutamine, pakkudes palju laiemaid võimalusi.
\begin{comment}
 \begin{frame}[fragile]{About Idris}
    \begin{itemize}
      \item
        Purely functional
      \item
        Dependent types
      \item
        Strict by default; optional laziness
      \item
        Totality checking
      \item
        Easy management of side effects
      \item
        Support for EDSL-s
      \item
        Syntax similar to Haskell
      \item
        Parametric polymorphism
      \item
        GADT-s
      \item
        Interfaces
    \end{itemize}
  \end{frame}
  \begin{frame}[fragile]{Creating data types}
    \begin{verbatim}
data List t = Cons t (List t) | Nil
    \end{verbatim}
    \begin{verbatim}
data List : Type -> Type where
  (::) : t -> List t -> List t
  Nil : List t
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Totality checking and assertions}
    \begin{verbatim}
fromInteger x =
  if x == 0 then
    Z
  else
    S (fromInteger (assert_smaller x (x - 1)))
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Dependent types}
    \begin{verbatim}
data Vect : Nat -> Type -> Type where
  (::) : t -> Vect n t -> Vect (S n) t
  Nil : Vect Z t
    \end{verbatim}
    \begin{verbatim}
app : Vect m t -> Vect n t -> Vect (m + n) t
app (x :: xs) ys = x :: app xs ys
app Nil ys = ys
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Mutually recursive functions}
    \begin{verbatim}
mutual
  even : Nat -> Bool
  even (S x) = odd x
  even Z = True
  odd : Nat -> Bool
  odd (S x) = even x
  odd Z = False
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Naming arguments}
    \begin{verbatim}
replicate : (n : Nat) -> t -> Vect n t
replicate (S k) x = x :: replicate k x
replicate Z _ = Nil
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Naming and providing implicit arguments}
    \begin{verbatim}
index :
  {t : Type} ->
  {n : Nat} ->
  Vect n t ->
  Fin n ->
  t
index (x :: _) FZ = z
index (_ :: xs) (FS k) = index xs k
    \end{verbatim}
    \begin{verbatim}
two : Int
two =
  index {t = Int} {n = S (S Z)}
    FZ (2 :: 3 :: Nil)
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{using block}
    \begin{verbatim}
using (x : t, y : t, xs : Vect n t)
  data IsElem : t -> Vect n t -> Type where
    Here : IsElem x (x :: xs)
    There : IsElem x xs -> IsElem x (y :: xs)
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Qualified names}
    \begin{verbatim}
testVec : Vect (S (S (S (S Z)))) Int
testVec = 3 :: 4 :: 5 :: 6 :: Nil
    \end{verbatim}
    \begin{verbatim}
inVect : IsElem 5 Hello.testVec
inVect = There (There Here)
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Laziness}
    \begin{verbatim}
ifThenElse : Bool -> Lazy t -> Lazy t -> t
ifThenElse True x _ = x
ifThenElse False _ y = y
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Infinite data structures}
    \begin{verbatim}
codata Stream : Type -> Type where
  (::) : t -> Stream t -> Stream t
    \end{verbatim}
    \begin{verbatim}
data Stream : Type -> Type where
  (::) : t -> Inf (Stream t) -> Stream t
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Mutually recursive data types}
    \begin{verbatim}
mutual
  data Blue : Type -> Type where
    B : t -> Inf (Red t) -> Blue t
  data Red : Type -> Type where
    R : t -> Inf (Blue t) -> Red t
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Records}
    \begin{verbatim}
record Person where
  constructor MkPerson
  firstName, middleName, lastName : String
  age : Int
    \end{verbatim}
    \begin{verbatim}
fred : Person
fred = MkPerson "Fred" "Joe" "Bloggs" 30
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Updating records}
    \begin{verbatim}
jim : Person
jim =
  record
  {firstName = "Jim", age $= (+ 1)}
  fred
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Nested updates}
    \begin{verbatim}
record Rec_a where
  constructor Constr_a
  field_b : Int
    \end{verbatim}
    \begin{verbatim}
record Rec_x where
  constructor Constr_x
  field_a : Rec_a
    \end{verbatim}
    \begin{verbatim}
update_b_in_x : Rec_x -> Int -> Rec_x
update_b_in_x x b =
  record {field_a -> field_b = c} x
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Alternative to do-notation}
    \begin{verbatim}
m_add : Maybe Int -> Maybe Int -> Maybe Int
m_add x y = do
  x' <- x
  y' <- y
  pure (x' + y')
    \end{verbatim}
    \begin{verbatim}
m_add : Maybe Int -> Maybe Int -> Maybe Int
m_add x y = pure (!x + !y)
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Idiom brackets}
    \begin{verbatim}
m_add : Maybe Int -> Maybe Int -> Maybe Int
m_add x y = pure (+) <*> x <*> y
    \end{verbatim}
    \begin{verbatim}
m_add : Maybe Int -> Maybe Int -> Maybe Int
m_add x y = [|x + y|]
    \end{verbatim}
  \end{frame}
  \begin{frame}[fragile]{Multiple implementations of interfaces}
    \begin{verbatim}
[PlusNatSemi] Semigroup Nat where
  x <+> y = x + y
[MultNatSemi] Semigroup Nat where
  x <+> y = x * y
[PlusNatMonoid] Monoid Nat
  using PlusNatSemi where
    neutral = 0
[MultNatMonoid] Monoid Nat
  using MultNatSemi where
    neutral = 1
    \end{verbatim}
\end{comment}
    \subsection{Edutamise eelised sõltuvate tüüpide ees}
      
\begin{comment}
  \begin{frame}[fragile]{Why Not Dependent Types?}
    For many purposes, promotion is sufficient. It is a simple tool that does the job.
    \begin{itemize}
      \item
        Promotion might be easier for programmers to understand.
      \item
        Dependent types complicate typechecking.
      \item
        Dependent types complicate type inference.
      \item
        Dependent types complicate type erasure.
    \end{itemize}
  \end{frame}
\end{comment}
\begin{comment}
  \begin{frame}[fragile]{Promotion Without GADT-s?}
    Many GADT-s in the examples have a certain pattern:
    \begin{itemize}
      \item
        The kind of the new type constructor \verb!F! starts with \verb!K L1 ... Ln! where \verb!K! is a kind constructor promoted from an algebraic data type.
      \item
        The first type argument of the resulting \verb!F! is a type constructor applied to some type variables.
      \item
        For every constructor \verb!MakeK! of \verb!K!, we write exactly one data constructor. The first type argument of the resulting \verb!F! is constructed with \verb!MakeK!.
      \item
        For each data constructor that we create, the other type arguments of the resulting \verb!F! are type variables.
      \item
        All type variables used in the resulting \verb!F! are different.
    \end{itemize}
    The two examples shown that do not conform to this rule - \verb!Fin! and \verb!Sum! - can also be done by relaxing only the third rule (allowing zero or more than one data constructor of \verb!F! for each type constructor of \verb!K!).
  \end{frame}
  \begin{frame}[fragile]{Why Not GADT-s?}
    \begin{itemize}
      \item
        Simplicity of use for the programmer.
      \item
        Hopefully simplicity of implementation (type checking and type inference)?
    \end{itemize}
    Many useful applications of promoted kinds are achievable with something much less powerful than GADT-s. GADT-s might be an overkill.
  \end{frame}
\end{comment}
  \peatykk{Süntaks}\label{syntaks}
    Siinkohal toome ära konkreetse süntaksi formaalse spetsifikatsiooni. Lisaks grammatikate kirja panemiseks kasutatavale püstkriipsule, mis tähistab valikut kahe variandi vahel, on kasutatud ka sümboleid $A^*=\epsilon|AA^*$ ja $A?=\epsilon|A$.

    Loetavuse huvides on keele elementide tähistused ning süntaksi kirjeldamiseks kasutatav notatsioon tavalises kirjatüübis. Keele võtmesõnad ja sümbolid on helehallis fikseeritud laiusega kirjatüübis. \markus{TODO: otsida siia viide sellele notatsioonile} \markus{TODO: epsilon ei ole sobiv avaldiste jaoks, sest tähistab tühja stringi} \markus{TODO: tüübisüsteemi formaalne spetsifikatsioon? avaldiste semantika?}

    \begin{tabular}{llll}
      Fail & $P$ & $::=$ & $I^*D^*K^*F^*$ \\
      Import & $I$ & $::=$ & {\color{helehall}\verb!Load!} $x${\color{helehall}\verb!.awf!} \\
      Nimi & $x$ &  &  \\
      Andmetüüp & $D$ & $::=$ & $S|A|G$ \\
      Struktuur & $S$ & $::=$ & {\color{helehall}\verb!Struct!} $x\tau\phi$ \\
      Tüübimuutujad & $\tau$ & $::=$ & $(${\color{helehall}\verb![!}$t(${\color{helehall}\verb!,!}$t)^*${\color{helehall}\verb!]!}$)?$ \\
      Tüübimuutuja koos liigiga & $t$ & $::=$ & $x$ {\color{helehall}\verb!:!} $L$ \\
      Liik & $L$ & $::=$ & $\Lambda$ $\Lambda^*|${\color{helehall}\verb"!"}$?x$ \\
       & $\Lambda$ & $::=$ & {\color{helehall}\verb!(!}$\Lambda$ $\Lambda^*${\color{helehall}\verb!)!}$|${\color{helehall}\verb"!"}$?x$ \\
      Struktuuri väljad / muutujad & $\phi$ & $::=$ & $(${\color{helehall}\verb!(!}$\nu(${\color{helehall}\verb!,!}$\nu)^*${\color{helehall}\verb!)!}$)?$ \\
      Muutuja koos tüübiga & $\nu$ & $::=$ & $x$ {\color{helehall}\verb!:!} $T$ \\
      Tüüp & $T$ & $::=$ & $t$ $t^*|${\color{helehall}\verb"!"}$?xl$ \\
       & $t$ & $::=$ & {\color{helehall}\verb!(!}$t$ $t^*${\color{helehall}\verb!)!}$|${\color{helehall}\verb"!"}$?xl$ \\
      Liigirakendus & $l$ & $::=$ & $(${\color{helehall}\verb"["}$L(${\color{helehall}\verb","}$L)^*${\color{helehall}\verb"]"}$)?$ \\
      Algebraline andmetüüp & $A$ & $::=$ & {\color{helehall}\verb!Algebraic!} $x\tau${\color{helehall}\verb!(!}$a${\color{helehall}\verb!,!}$a(${\color{helehall}\verb!,!}$a)^*${\color{helehall}\verb!)!} \\
      Algebralise andmetüübi konstruktor & $a$ & $::=$ & $x(${\color{helehall}\verb!(!}$L(${\color{helehall}\verb!,!}$L)^*${\color{helehall}\verb!)!}$)?$ \\
      Hargnev andmetüüp & $G$ & $::=$ & {\color{helehall}\verb!Branching!} $x${\color{helehall}\verb"[!"}$xl${\color{helehall}\verb!]!}$\tau${\color{helehall}\verb!(!}$H${\color{helehall}\verb!,!}$H(${\color{helehall}\verb!,!}$H)^*${\color{helehall}\verb!)!} \\
      Hargneva andmetüübi haru & $H$ & $::=$ & {\color{helehall}\verb"!"}$x$ $x^*$ {\color{helehall}\verb!->!} $x\phi$ \\
      Klass & $K$ & $::=$ & {\color{helehall}\verb!Class!} $x${\color{helehall}\verb!{!}$t${\color{helehall}\verb!}!}$(${\color{helehall}\verb!<!}$x${\color{helehall}\verb!>!}$)?(${\color{helehall}\verb!(!}$\mu(${\color{helehall}\verb!,!}$\mu)^*${\color{helehall}\verb!)!}$)?$ \\
      Klassi meetod & $\mu$ & $::=$ & $x\tau\kappa$ {\color{helehall}\verb!:!} $L$ \\
      Kitsendused & $\kappa$ & $::=$ & $(${\color{helehall}\verb!<!}$k(${\color{helehall}\verb!,!}$k)^*${\color{helehall}\verb!>!}$)?$ \\
      Kitsendus & $k$ & $::=$ & $x$ $x$ \\
      Definitsioon / instants & $F$ & $::=$ & $\delta|i$ \\
      Definitsioon & $\delta$ & $::=$ &  \\
      Avaldis & $E$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|\lambda|i|M|x$ \\
         & $e$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$i|${\color{helehall}\verb!(!}$M${\color{helehall}\verb!)!}$|x$ \\
         & $\epsilon$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$i|${\color{helehall}\verb!(!}$M${\color{helehall}\verb!)!}$|x$ \\
      Täht & $c$ & &  \\
      Lambda & $\lambda$ & $::=$ & $x$ {\color{helehall}\verb!->!} $E$ \\
      Täisarv & $i$ &  &  \\
      Mustrisobitus & $M$ & $::=$ &  \\
      Instants & $i$ & $::=$ &  \\
    \end{tabular}
\begin{comment}
  data Brnch_0 = Brnch_0 Name [Name] Name [(Name, Type_0)] deriving Show
  data Data_br_0 = Branching_data_0 Name [Kind_0] [(Name, Kind_0)] [Brnch_0] | Plain_data_0 [(Name, Kind_0)] Data_branch_0
  data Data_branch_0 = Algebraic_data_0 [Form_0]
  data Def_0 =
    Basic_def_0 Name [(Name, Kind_0)] [Constraint_0] [(Pattern_1, Type_0)] Type_0 Expression_0 |
    Instance_def_0 Location_0 Name Name [Kind_0] [Pattern_1] [Constraint_0] [(Name, ([Pattern_1], Expression_0))]
  data Expression_branch_0 =
    Application_expression_0 Expression_0 Expression_0
  data Match_Algebraic_0 = Match_Algebraic_0 Name [Pattern_1] Expression_0 deriving Show
  data Match_char_0 = Match_char_0 Char Expression_0 deriving Show
  data Match_Int_0 = Match_Int_0 Integer Expression_0 deriving Show
  data Matches_0 =
    Matches_Algebraic_0 [Match_Algebraic_0] (Maybe (Location_0, Expression_0)) |
    Matches_char_0 [Match_char_0] Expression_0 |
    Matches_Int_0 [Match_Int_0] Expression_0
      deriving Show
\end{comment}
    Süntaks ei ole taandetundlik. Antud otsuse põhjuseks oli parseri teostuse lihtsus, aga ka soov anda kasutajale rohkem vabadust selle osas, kuidas koodi paigutada. Lisaks vähendab mitte-taandetundlikkus parsimisvigade ohtu suuremate kooditükkide kopeerimisel ühest kohast teise. Peamiseks puuduseks on liigsed sulud ja eraldajad (näiteks \verb!Match! avaldises), mida taandetundlik süntaks oleks aidanud vältida.

    Keel on tõstutundlik. Erinevalt Haskellist ei ole piiratud, mis nimed peavad algama suur- ja millised väiketähega. Failid, tüübid, tüübimuutujad, konstruktorid, struktuuride väljad, definitsioonide nimed ja lokaalsed muutujad võivad kõik alata kas suur- või väiketähega vastavalt kasutaja soovile. Nimedes on ASCII sümbolitest lubatud ülakoma, numbrid (välja arvatud esimeses positsioonis), tähed ja alakriips. Lubatud on ka mitte-ASCII sümbolid, näiteks täpitähed. Üksik alakriips on, nagu ka Haskellis, mõeldud nimetamata muutujate jaoks.

    Tähtede (\verb!Char!) ümber käivad topeltjutumärgid (näiteks \verb#"!"#).
  \peatykk{Keele kirjeldus}\label{manual}
    Awful on deklaratiivne, puhasfunktsionaalne keel. Kuna töö põhieesmärgiks oli tüübisüsteemi arendamine, sai kirjutatud ainult interpretaator ning kompileerimise võimalust ei ole. Erinevalt Haskellist on Awful agara väärtustamisega.

    \markus{TODO: 1) rohkem näiteid 2) põhjendada disainivalikuid}
    \subsection{Kommentaarid}
      Kommentaaride süsteem on sarnane Haskellile ja C keelele, selle vahega, et kasutatakse teistsuguseid sümboleid. Üherealist kommentaari alustatakse graavise sümboliga.

      \begin{verbatim}Def Id[T : Star](x : T) : T = T `Ühikfunktsioon\end{verbatim}

      Mitmerealist kommentaari alustatakse lainelise joone ja kaldkriipsuga, ning lõpetatakse kaldkriipsu ja lainelise joonega. Nagu ka Haskellis, võib neid teineteise sisse paigutada.

      \begin{verbatim}~/ Awful on puhasfunktsionaalne interpreteeritud agar keel. /~\end{verbatim}

    \subsection{Moodulid ja importimine}
      Kõik Awful koodifailid lõpevad laiendiga \verb!.awf!. Awful'is on olemas lihtne moodulite süsteem. Mooduleid saab importida kasutades võtmesõna \verb!Load!. Impordid peavad olema faili alguses ja nende järjekord ei ole oluline.

      \begin{verbatim}Load Algebra.awf
Load Standard.awf\end{verbatim}

      Nimekonfliktide tuvastamise teostuse lihtsuse huvides ei ole lubatud, et kahes erinevas moodulis oleks mõni ühine muutujanimi, isegi juhul kui tegelikku võimalust nimekonfliktiks ei ole.
    \subsection{Andmetüübid}
      Haskellis on kaks viisi uusi andmetüüpe luua: tavalised algebralised andmetüübid ja üldistatud algebralised andmetüübid. Awful keele lähenemine andmetüüpidele on teistsugune. Keel pakub kasutajale kolme erinevat viisi uusi andmetüüpe luua: struktuurid, algebralised andmetüübid ja hargnevad andmetüübid. Ükski neist ei ole teisega asendatav, kõigil on erinev otstarve.

      Awful nõuab, et andmetüübid oleks deklareeritud enne klasse ja definitsioone. Andmetüüpide deklaratsioonide omavaheline järjekord ei ole aga oluline isegi kui nende vahel on sõltuvusi.
      \subsubsection{Struktuurid}
        Struktuurid on mõeldud andmetüüpide jaoks, millel on täpselt üks konstruktor. Konstruktori nimi ühtib tüübi nimega automaatselt. Erinevalt Haskellist on kohustuslik kirja panna struktuuri väljade nimed.

        \begin{verbatim}Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Juhul, kui struktuur ei kasuta tüübipolümorfismi, tuleb kandilised sulud lihtsalt ära jätta. Sama kehtib ka struktuuri väljade kohta: juhul kui struktuuril ei ole ühtegi välja, tuleb ära jätta ümarsulud väljade loeteluga.

        \begin{verbatim}Struct Trivial\end{verbatim}

      \subsubsection{Algebralised andmetüübid}
        Algebralised andmetüübid on sarnased Haskelli omadega, selle vahega, et kasutajalt nõutakse vähemalt kahte konstruktorit. Juhul, kui kasutaja tahab kirjutada ühe konstruktoriga andmetüüpi, on selleks struktuurid.

        Kuna algebraliste andmetüüpide puhul on andmetel kaks või enam erinevat kuju, ei ole nende jaoks võimalust spetsifitseerida väljade nimesid. Kui struktuurist saab andmed kätte väljade nimede abil, siis algebraliste andmetüüpide jaoks tuleb kasutada mustrisobituse avaldist, mida on kirjeldatud alamjaotises~\ref{match}.
      \subsubsection{Hargnevad andmetüübid}
        \markus{Kirjutada võrdlus GADT-ga. Mis on eelised ja mis on puudused?}
      \subsubsection{Keelde sisse ehitatud andmetüübid}\label{sisseehitatudalgebralised}
        Lisaks tähtedele (\verb!Char!), funktsioonidele (\verb!Function!) ja täisarvudele (\verb!Int!) on Awful keeles ka ilma standardteeki importimata saadaval järgmised andmetüübid:

        \begin{verbatim}Algebraic Comparison(LT, EQ, GT)
Algebraic List[T : Star](Empty_List, Construct_List(T, List T))
Algebraic Maybe[T : Star](Nothing, Wrap(T))
Algebraic Nat(Zr, Next(Nat))\end{verbatim}

        Kuna kõik need andmetüübid on edutatavad, kaasneb nendega ka vastavate edutamise teel saadud liikide ja tüüpide kasutamise võimalus.
    \subsection{Tüübiklassid}
      Uue tüübiklassi loomine käib võtmesõnaga \verb!Class!, millele järgneb klassi nimi, tüübimuutuja nimi ja liik, päritav klass (kui seda on), ja nimekiri meetoditest koos tüüpidega.

      \begin{verbatim}Class Functor{F : Arrow Star Star}(
  Fmap[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))\end{verbatim}

      Vahel on kasulikud ka ilma meetoditeta klassid. Sisuliselt on tegu predikaatidega tüüpide peal ja nad on kasulikud kirjeldamaks tüüpide omadusi. Üks lihtne näide on klass \verb!Commutative!, mille instantsi saab kasutada märkimaks, et tüüp, mis on ring, on lisaks teatud tingimustel kommutatiivne.

      \begin{verbatim}Class Commutative{T : Star}<Ring>\end{verbatim}
      \subsubsection{Pärilus}
        Magistritöö skoobi piiratuse tõttu võimaldab Awful ainult ühest pärilust. Seda, et üks klass pärib teist, märgitakse nurksulgude abil:

        \begin{verbatim}Class Finite{T : Star}<Ord>(All : List T)\end{verbatim}

        Näiteks antud juhul eeldab klass \verb!Finite! (mis lubab \verb!All! meetodi abil saada list lõpliku andmetüübi kõigist võimalikest väärtustest) klassi \verb!Ord!.
      \subsubsection{Kitsendused}
        
      \subsubsection{Klassi meetodite tüübikitsendused}
        Vahel on vaja kirjutada klassi, mille meetodid sisaldavad tüübikitsendusi. Hea näide on klass \verb!Mat!, mis on mõeldud üldistamaks erinevaid ruutmaatrikseid ning sisaldab endas adjunktmaatriksi, karakteristliku polünoomi, determinandi ja vektoriga korrutamise meetodeid. Tema meetodites esinevaid tüübimuutujaid on vaja kitsendada kitsendustega \verb!Ring! ja \verb!Commutative!, sest näiteks maatriksi ja vektori korrutamist ei ole võimalik defineerida, kui allolev struktuur ei ole ring, ja determinant nõuab kommutatiivset ringi.

        \begin{verbatim}Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> :
    Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> :
    Function (Array N T) (Function (F N T) (Array N T)))\end{verbatim}
      \subsubsection{Keelde sisseehitatud klassid}\label{klassmaatriks}
        Neli klassi on saadaval ka ilma standardteeki importimata:

        \begin{verbatim}Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Ord{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(
  Brackets : Function T (List Char),
  Write : Function T (List Char))\end{verbatim}

        Klass \verb!Ord! on sarnane Haskelli samanimelise klassiga, selle vahega, et Awful'is ei ole klassi \verb!Eq!.

        Klass \verb!Writeable! on mõeldud andmestruktuuride stringideks teisendamiseks meetodi \verb!Write! abil; \verb!Brackets! on abimeetod, mis paneb avaldise sulgudesse välja arvatud juhul kui tegu on üksiku konstandiga.

        Klassid \verb!Ring! ja \verb!Field! on tuttavad algebrast: tegu on lihtsalt (mitte tingimata kommutatiivse) ringi ja korpusega. Klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu ringi elemendiks, on mõeldud defineerimaks nulli (\verb!Convert 0!) ja ühikut (\verb!Convert 1!), aga ka selleks, et oleks mugav suvalises ringis elementi täisarvulise konstandiga korrutada.
    \subsection{Keelde sisseehitatud definitsioonid ja instantsid}
      Lisaks alamjaotises~\ref{sisseehitatudalgebralised} loetletud algebraliste andmetüüpide konstruktoritele, on ilma standardteeki importimata võimalik kasutada järgmisi keelde sisseehitatud muutujaid ja instantse:
      \subsubsection{Ühikfunktsioon}
        Keelde on sisse ehitatud ühikfunktsioon.

        \begin{verbatim}Def Id[T : Star](x : T) : T = x\end{verbatim}
      \subsubsection{Täisarvude võrdlus ja aritmeetika}
        Keelde on sisse ehitatud klasside \verb!Ord! ja \verb!Ring! instantsid täisarvude jaoks. Lisaks on olemas ka funktsioonid \verb!Div! ja \verb!Mod!, mis annavad vastavalt täisarvulise jagamise jagatise ja jäägi. Turvalisuse huvides on mõlema funktsiooni tulemus \verb!Maybe! all juhuks kui jagaja on null.
      \subsubsection{Tähtede võrdlus}
        Keelde on sisse ehitatud klassi \verb!Ord! instants tähtede jaoks.
      \subsubsection{Täisarvude stringiks teisendamine}
        Keelde on sisse ehitatud klassi \verb!Writeable! instants täisarvude jaoks.
      \subsubsection{Defineerimata käitumine}
        Defineerimata käitumist saab märkida erilise muutuja abil, mille nimi on \verb!Crash!. \verb!Crash! on sarnane Haskelli \verb!undefined! muutujaga selle poolest, et mõlemad on parameetriliselt polümorfsed üle suvalise tüübi liigist \verb!*!, selleks et neid saaks panna suvalisse kohta veel kirjutamata kooditüki asenduseks, või luua funktsioone mille käitumine ongi osade argumendiväärtuste korral defineerimata.

        Käitumine väärtustamisel on aga erinev selle tõttu, et Haskell on laisk ja Awful on agar keel. Näiteks Haskelli avaldis \verb!fst (0, undefined)! annab \verb!0!, aga Awfuli analoogne avaldis \verb!First (Pair 0 Crash)! resulteerub tulemuses \verb!Crash!.
    \subsection{Definitsioonid ja instantsid}
      \markus{TODO}
      \subsubsection{Definitsioonid}
        
      \subsubsection{Instantsid}
        
    \subsection{Avaldised}
      \markus{TODO: tekst}
      \subsubsection{Lambda-avaldised}
        Funktsionaalse programmeerimiskeelena sisaldab Awful loomulikult lambda-avaldisi. Süntaks on sarnane Haskelli omaga, selle vahega, et kuna mustrisobituse võimalust funktsiooni argumentides ei ole veel teostatud, ei ole vajalik \verb!\! sümbol enne muutujanime.

        \begin{verbatim}Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>
  (x : F T, y : T) : F T =
    Fmap (z -> Multiply z y) x\end{verbatim}
      \subsubsection{Mustrisobitus}\label{match}
        Mustrisobitus töötab tähtede, täisarvude ja algebraliste andmetüüpide peal.

        \begin{verbatim}Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}\end{verbatim}

        Saab kirjutada ka \verb!Default! juhu, mida kasutatakse, kui ükski eelnev variant ei sobinud.

        \begin{verbatim}Def Max[T : Star]<Ord T>(x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Turvalisuse tagamiseks kontrollitakse iga \verb!Match! avaldise puhul, kas kõik võimalikud juhud on käsitletud. Kattuvad või puuduvad juhud annavad vea. See tähendab, et \verb!Default! juhtum on kohustuslik tähtede ja täisarvude mustrisobituses, ning ka algebraliste andmetüüpide jaoks juhul kui eelnevalt ei ole kõiki võimalikke juhtusid käsitlenud.

        Erinevalt Haskellist ei luba Awful kirjutada keerulisema struktuuriga mustrisobitust, näiteks sobitada sama \verb!Match! avaldisega tühja, 1-elemendilist ja 2-elemendilist listi. Sellise otsuse põhjuseks oli teostamise lihtsus.

        Samuti ei luba Awful \verb!Match! avaldist üle struktuuri (selle asemel tuleb kasutada väljade nimesid, ja tulevikus on plaanis lisada võimalus teha struktuuride mustrisobitust otse funktsiooni argumendis) ega üle hargneva andmetüübi (selle asemel on võimalik kasutada tüübiklasse viisil, mis on kirjeldatud alamjaotises~\ref{tyybiklassihakk}).
      \subsubsection{Tüübiklasside kasutamine tüübimuutujate mustrisobituseks}\label{tyybiklassihakk}
        
    \subsection{Teegid}
      
      \subsubsection{Standardteek}
        
      \subsubsection{Algebrateek}
        
    \subsection{Interpretaatori kompileerimine ja kasutajaliides}
      Interpretaatori kompileerimiseks tuleb kompileerida fail \verb!Awful.hs!.

      \begin{verbatim}ghc Awful.hs\end{verbatim}

      Awful annab kasutajale kaks käsklust mida koodifailidele ja avaldistele rakendada: \verb!check!, mis teostab tüübikontrolli, ning \verb!eval!, mis väärtustab avaldise.

      Käsklus \verb!check! võtab argumendiks failinime ning tüübikontrollib mooduli ja kõik selle impordid.

      \begin{verbatim}./Awful check Standard.awf\end{verbatim}

      Käsklus \verb!eval! võtab argumendiks nimekirja failinimedest ja avaldise ning tüübikontrollib moodulid ja kõik nende impordid. Seejärel väärtustatakse avaldise keskkonnas, kuhu on lisatud kõik moodulitest saadud definitsioonid.

      \begin{verbatim}./Awful eval Standard.awf Algebra.awf "Pair Trivial (Complex 0 0)"\end{verbatim}

      Tulemus väljastatakse otse niiviisi, kuidas avaldised on väärtustajas sisemiselt esitatud. Tulemuste ilusal kujul väljastamine on plaanis teostada tulevikus.
  \peatykk{Teostuse detailid}
    Awful keele interpretaator on üsna interpretaatori jaoks üsna tüüpilise arhitektuuriga, koosnedes lekserist, parserist, nimekontollijast, tüübikontrollijast ja väärtustajast. Lisaks on eraldi moodul, mis vastutab kasutajaliidese ja moodulisüsteemi eest. \markus{mis klasse, teeke jne kasutan?}
    \subsection{Parser}
      \markus{kirjutada Alternative klassi kohta, mida kasutan parsimiseks}
      \subsubsection{Aplikatiivne parsimine}
        
      \subsubsection{Monaadiline parsimine}
        
    \subsection{Tüübikontroll}
      Awful võimaldab andmetüüpe, klasse ning definitsioone ja instantse kirjutada ükskõik millises järjekorras, olenemata nende omavahelistest sõltuvustest. Selle tõttu läbib tüübikontrollija nii andmetüübid, klassid kui ka definitsioonid ja instantsid kaks korda.
      \subsubsection{Andmetüübid}
        
      \subsubsection{Klassid}
        
      \subsubsection{Definitsioonid ja instantsid}
        
    \subsection{Väärtustamine}
      Awful keele väärtustaja kasutab avaldisi, mille küljes ei ole tüübiinfot.
\begin{comment}
    Add_Int_expression_2 |
    Add_Int'_expression_2 Integer |
    Algebraic_expression_2 String [Expression_2] |
    Application_expression_2 Expression_2 Expression_2 |
    Field_expression_2 String |
    Function_expression_2 Pattern_0 Expression_2 |
    Match_expression_2 Expression_2 Matches_2 |
    Struct_expression_2 (Map' Expression_2) |
\end{comment}
      \subsubsection{Struktuurid}
        
      \subsubsection{Algebralised andmetüübid}
        Algebralise andmetüübi esitus väärtustajas on list väljade sisust, millele on lisatud konstruktori nimi. Konstruktori nimi on algebraliste andmetüüpide puhul erinevalt struktuurist vajalik, sest seda kasutatakse mustrisobitusel õige haru leidmiseks.
      \subsubsection{Defineerimata käitumine}
        Muutuja \verb!Crash! on keelde sisseehitatud muutuja, mis esineb tüüpimiskeskkonnas, aga seda ei ole lisatud väärtustamiskeskkonda. Väärtustaja annab tulemuse \verb!Maybe! monaadi all, ning kui muutuja väärtustamiskeskkonnast leidmine ebaõnnestub (mis võib juhtuda ainult muutuja \verb!Crash! korral), antakse tulemuseks \verb!Nothing! ja kasutajale kuvatakse, et väärtustamise lõpptulemuseks oli \verb!Crash!.
      \subsubsection{Struktuuri väljade leidmine}
        
      \subsubsection{Mustrisobitus}
        
      \subsubsection{Lambda-avaldised}
        
      \subsubsection{Klasside meetodid}
        
    \subsection{Moodulisüsteem}
      
  \peatykk{Edasine töö}
    \subsection{Liik kui kategooria}
      ~\cite{Cat}.
    \subsection{Klass kui alamliik}
      
    \subsection{Kasutusmugavus}
      Magistritöö mahu tõttu keskendus töö tüübiklasside ja edutamise arendamisele ning töö skoobist jäid välja mõned väikesed, keele võimalusi otseselt mitte laiendavad, aga kasutusmugavuse seisukohast olulised aspektid. Need on plaanis tulevikus teostada, et muuta keeles kirjutatud kood loetavamaks ja kasutajasõbralikumaks.
      \begin{itemize}
        \item
          Võimaldada eksplitsiitset tüübirakendamist, et säästa kasutajale liigsete abi-definitsioonide tegemise vaeva
      \end{itemize}
      \subsubsection{Operaatorid ja tüübioperaatorid}
        
      \subsubsection{Mustrisobitus funktsioonide argumentides}
        
      \subsubsection{Väärtustamise tulemuste trükkimine}
        Anda interpreteerimise tulemused prettyprinditud kujul (\verb!Writeable! klassi abil)
      \subsubsection{Tüübisünonüümid}
        
      \subsubsection{Tüübirakendamine}
        
    \subsection{???}
      \markus{Tüübiklassihäki eemaldamine}
    \subsection{Süntaksi kasutajapoolsete täienduste võimalus}
      
  \peatykk{Kokkuvõte}
    \markus{what did you do?}

    \markus{What are the results?}

    \markus{future work?}
  \newpage
  \bibliography{bachelor-thesis}
  \addcontentsline{toc}{section}{\refname}
  \peatykktarn{Litsents}
    \subsection*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele kättesaadavaks tegemiseks}
      Mina, \textbf{Liisi Kerik},

      \begin{enumerate}
        \item
          annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose

          \textbf{Funktsionaalse programmeerimiskeele liigisüsteem}

          mille juhendaja on Härmel Nestra

          \begin{enumerate}
            \item[1.1]
              reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni;
            \item[1.2]
              üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace´i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
          \end{enumerate}
        \item
          olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
        \item
          kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi. 
      \end{enumerate}

      \noindent
      Tartus, 21.05.2018
\end{document}