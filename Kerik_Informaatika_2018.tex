% Institute of Computer Science thesis template
% authors: Sven Laur, Liina Kamm
% last change Tõnu Tamme 09.05.2017
\documentclass[12pt]{article}
\usepackage{CormorantGaramond}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage[english, estonian]{babel}
\usepackage[labelsep = period]{caption}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{inconsolata}
\usepackage[utf8x]{inputenc}
\usepackage{proof}
\usepackage{todonotes}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{xspace}
\addto\captionsestonian{
  \renewcommand\refname{Viidatud kirjandus}}
\bibliographystyle{plain}
\def\pealkiri{Funktsionaalse programmeerimiskeele liigisüsteem}
\definecolor{ereroheline}{RGB}{0,255,0}
\definecolor{hall}{RGB}{128,128,128}
\definecolor{helehall}{RGB}{192,192,192}
\definecolor{must}{RGB}{0,0,0}
\definecolor{roheline}{RGB}{0,128,0}
\newcommand\peatykk[1]{
  \clearpage
  \section{#1}}
\newcommand\peatykktarn[1]{
  \clearpage
  \section*{#1}
  \addcontentsline{toc}{section}{#1}}
\newcommand\markus[1]{\textcolor{roheline}{\textbf{#1}}}
\begin{document}
  \thispagestyle{empty}
  \begin{center}
    \large
      TARTU ÜLIKOOL\\
      Arvutiteaduse instituut\\
      Informaatika õppekava

    \vspace{25mm}

    \Large
      Liisi Kerik

    \vspace{4mm}

    \huge
      \pealkiri

    \vspace{20mm}

    \Large
      Magistritöö (30 EAP)
  \end{center}

  \vspace{2mm}

  \begin{flushright}
    \begin{tabular}{rl} 
      Juhendaja: & Härmel Nestra, PhD
    \end{tabular}
  \end{flushright}
  \vfill
  \centerline{Tartu 2018}
  \newpage
  \noindent
  \textbf{\large\pealkiri}

  \vspace*{1ex}

  \noindent
  \textbf{Lühikokkuvõte:} 

  \noindent
  Staatilised tüübisüsteemid võimaldavad leida programmidest vigu juba enne koodi käivitamist ja aitavad seega kaasa töökindlama koodi kirjutamisele. Paljud funktsionaalsed keeled, näiteks Haskell~\cite{Gla} ja Idris~\cite{The_Idr}, on staatiliselt tüübitud.

  Mida väljendusrikkam on keele tüübisüsteem, seda rohkem vigu on võimalik juba tüübikontrolli ajal leida. Osad keeled, näiteks Idris, kasutavad sõltuvaid tüüpe, mis muudavad tüübisüsteemi võimsaks aga ka keeruliseks. Hiljuti Haskellis sisse toodud edutamine võimaldab tõsta tüübisüsteemi väljendusrikkust ilma sõltuvate tüüpideta~\cite{Giv}.

  Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud funktsionaalne programmeerimiskeel, mille tüübisüsteemi on rikastatud edutamise abil.

  Käsoleva töö tulemuseks olev keel Awful näitab, et edutamise teel saadud liikide ja tüüpidele on palju kasulikke rakendusi ka keeles, milles puuduvad üldistatud algebralised andmetüübid.

  Awful kasutab üldistatud algebraliste andmetüüpide abil piiravamat aga oluliselt lihtsamat uut andmetüüpide konstrueerimise viisi. \textit{Hargnevad andmetüübid} võimaldavad konstrueerida paljusid kasulikke tüüpe, näiteks staatilise pikkusega vektoreid, mille jaoks Haskellis või Idrises kasutataks üldistatud algebralisi andmetüüpe.

  \vspace*{1ex}

  \noindent
  \textbf{Võtmesõnad:} andmetüübid ja struktuurid, funktsionaalprogrammeerimine, liigid, polümorfism, edutamine, tüübisüsteemid

  \vspace*{1ex}

  \noindent
  \textbf{CERCS:} P175 Informaatika, süsteemiteooria

  \vspace*{3ex}

  {
    \selectlanguage{english}
    \noindent
    \textbf{\large A Kind System for a Functional Programming Language}

    \vspace*{1ex}

    \noindent
    \textbf{Abstract:}

    \noindent
    \markus{TODO: siia tõlkida eestikeelne abstract, pärast seda kui see on korralikuks tehtud}

    \vspace*{1ex}

    \noindent
    \textbf{Keywords:} data types and structures, functional programming, kinds, polymorphism, promotion, type systems

    \vspace*{1ex}

    \noindent
    \textbf{CERCS:} P175 Informatics, systems theory

    \vspace*{1ex}}
  \newpage
  \tableofcontents
  \peatykktarn{Tänusõnad}
    
  \peatykk{Sissejuhatus}
    Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud funktsionaalne programmeerimiskeel. Dünaamiliselt tüübitud keeltes, nagu näiteks Python ja Wolfram Language~\cite{Wol}, selguvad kõik vead programmi töö käigus. Klassikalisteks näideteks vigadest, mis programmi töö käigus juhtuda võivad, on funktsiooni kutsumine vale tüüpi argumendi peal, massiivi indekseerimine liiga suure arvuga või nulliga jagamine. Staatiliselt tüübitud keeltes, nagu Haskell~\cite{Gla} ja Idris~\cite{The_Idr}, aitab tüübikontroll ennetada osasid programmi jooksutamise käigus tekkivaid vigu ja soovimatut käitumist. Staatiline tüübikontroll muudab koodi tüübiturvalisemaks.

    Turingi-täieliku keele puhul ei saa tüübikontroll, mille termineerumine on alati tagatud, ennetada kõiki vigu, ilma samas osasid korrektseid programme kõrvale heitmata. See tähendab, et iga tüübikontrolli-algoritm, mis alati termineerub ja on täielik (kiidab heaks kõik korrektsed programmid), peab lubama osasid ebakorrektseid programme~\cite{Typ}. Mida väljendusrikkam on tüübisüsteem, seda rohkem vigu on võimalik ennetada. Näiteks on osades programmeerimiskeeltes massiivide pikkuste ja indekseerimisega seotud vead dünaamilised, aga osades keeltes on saadaval staatilise pikkusega vektorid, mille puhul vektori pikkus on märgitud tema tüübis ja seega näiteks programm, kus üritatakse leida skalaarkorrutist kahest erineva pikkusega vektorist, tunnistatakse ebakorrektseks juba enne käivitamist.

    Kuna staatiline tüübikontroll ennetab osasid programmi töö käigus tekkivaid vigu, vähendab see soovimatu käitumise, programmi kokku jooksmise ja turvaaukude ohtu. Seega on tüübisüsteemid suure praktilise tähtsusega.

    Käesoleva töö tulemuseks on staatiliselt tüübitud funktsionaalne programmeerimiskeel nimega Awful. Awfuli tüübisüsteem sisaldab parameetrilist polümorfismi ja ühe muutuja tüübiklasse ning tüübisüsteemi on rikastatud edutamise abil, võttes eeskuju Haskellist~\cite{Giv}. Üks oluline erinevus teistest keeltest on andmetüübid. Kui Haskellis on olemas algebralised andmetüübid ja üldistatud algebralised andmetüübid, siis Awfuli viis lasta kasutajal uusi andmetüüpe deklareerida on oluliselt erinev. Awful toob sisse \textit{hargnevad andmetüübid}, mis on piiravamad kui üldistatud algebralised andmetüübid aga on samas ka oluliselt lihtsamad ja paljude rakenduste jaoks piisavad.

    Käesolevas töös alustame sellest, et meenutame lühidalt, mis on tüübiklassid ja üldistatud algebralised andmetüübid. Selgitame tüübitaseme andmeid ja edutamist ning toome näiteid sellest, kuidas edutamine muudab tüübisüsteemi väljendusrikkamaks. Meenutame lühidalt ka sõltuvaid tüüpe ja vaatleme, kuidas need võrdlevad edutamisega.

    Töö teises pooles tutvustame käesoleva töö teemaks olevat keelt Awfulit. Spetsifitseerime keele süntaksi. Kirjeldame keelt, põhjendame disainivalikuid ja toome koodinäiteid. Viimases peatükis räägime täiendustest ja parandustest, mida on tulevikus kavas teostada. Peamised plaanitavad täiendused on liikide käsitlemine kategooriatena ning klasside käsitlemine alamliikidena, aga lisaks on plaanis teostada ka väiksemaid keele kasutusmugavuse seisukohast olulisi täiendusi.
  \peatykk{\textit{Ad hoc} polümorfism ja tüübiklassid}
    Parameetriline polümorfism võimaldab käsitleda koos andmeid, millel on sama struktuur aga erinevat tüüpi sisu. Näiteks ei ole tarvis keeles, kus on olemas parameetriline polümorfism, luua kahte erinevat andmetüüpi tähtede ja täisarvude listide jaoks. Selle asemel võib luua parametriseeritud andmetüübi, mille abil saab konstrueerida ükskõik millise sisuga liste. Sellise andmetüübi jaoks saab kirjutada ka parameetriliselt polümorfseid funktsioone. Näiteks käitub listide konkateneerimine samamoodi olenemata sellest, kas konkateneerime tähtede või täisarvude liste.

    Parameetriline polümorfism ei ole ainus polümorfismi liik mida programmeerimiskeeled kasutavad. Teine oluline abstraktsioon on \textit{ad hoc} polümorfism~\cite{Fun}.
    \subsection{\textit{Ad hoc} polümorfism}
      Kui parameetrilise polümorfismi korral tegeleme andmetüüpide ja funktsioonidega, millel on samasugune struktuur ja käitumine olenemata sellest, mis tüüpi andmetega tegeletakse, siis \textit{ad hoc} polümorfism võimaldab kokku võtta funktsioone, millel on sarnane otstarve aga mis käituvad erinevat tüüpi andmete peal erinevalt.

      Üks lihtne näide on aritmeetikatehted. Aritmeetikatehteid on tarvis paljude erinevate tüüpide jaoks. Me võime liita ja korrutada täisarvusid, jäägiklassiringide elemente, loogikaväärtusi, vektoreid, kompleksarvusid, maatrikseid, harilikke murdusid, polünoome, kvaternione ja pajusid muid tüüpe. Kõigi puhul on liitmise ja korrutamise teostused erinevad, aga siiski on mugav kui kõigi jaoks on võimalik kasutada samu funktsiooninimesid ja operaatoreid. Kontekstist on enamasti selge, mida liidetakse või korrutatakse, ning seega arvukalt erinevaid liitmisfunktsiooni nimesid või operaatoreid ainult muudab koodi pikemaks ja vähem loetavaks.

      Eriti kasulik on \textit{ad hoc} polümorfism siis, kui on tarvis parameetriliselt polümorfse funktsiooni sees erineva teostusega aga sarnase otstarbega funktsioone kasutada. Näiteks juhul kui Haskellis ei oleks \textit{ad hoc} polümorfismi, peaks vektorite liitmise funktsiooni kirja panema järgneval viisi:

      \begin{verbatim}add_array :: (t -> t -> t) -> Array n t -> Array n t -> Array n t
add_array _ Empty_Array Empty_Array = Empty_Array
add_array add_t (Construct_Array x a) (Construct_Array y b) =
  Construct_Array (add_t x y) (add_array add_t a b)\end{verbatim}

    Lisaargument \verb!add_t!, mis ütleb, kuidas täpselt vektorite elemente liita, tuleks anda igal \verb!add_array! kutsel. See muudaks koodi pikemaks. Õnneks on Haskellis, ja ka paljudes teistes keeltes, olemas \textit{ad hoc} polümorfism, mis võimaldab selle ebavajaliku lisaargumendi likvideerida -- erinevaid tüüpe saab liita sama funktsiooninime (või operaatoriga) ja keel suudab ise tuvastada, millist liitmist rakendada. Haskelli \textit{ad hoc} polümorfism on teostatud tüübiklasside abil~\cite{How}.
    \subsection{Tüübiklassid Haskellis}
      Toome alguses lihtsa näite tüübiklassist, selgitades, kuidas eelmise jaotise näide vektorite liitmisest tüübiklasside olemasolul muutub. Seejärel selgitame, millised piirangud Haskell tüübiklassidele seab.

      Kui tahame luua funktsiooni \verb!add!, mis töötaks erinevate andmetüüpide jaoks, peab see funktsioon olema tüübiklassi meetod. Loomegi selle jaoks lihtsa, ühe meetodiga tüübiklassi \verb!Addible!. Tüübiklassid võivad sisaldada ka mitut meetodit, aga selles näites piirdume lühiduse huvides ainult ühega.

      \begin{verbatim}class Addible t where
  add :: t -> t -> t\end{verbatim}

      See klassideklaratsioon ütleb, et kui tüüp \verb!t! kuulub klassi \verb!Addible!, on tema jaoks defineeritud meetod \verb!add! tüüpi \verb!t -> t -> t!. Nüüd ütleme, et vektor on selle klassi \textit{esindaja} (ing. k. \textit{instance}).

      \begin{verbatim}instance Addible t => Addible (Array n t) where
  add Empty_Array Empty_Array = Empty_Array
  add (Construct_Array x a) (Construct_Array y b) =
    Construct_Array (add x y) (add a b)\end{verbatim}

      Esimene rida ütleb, et vektor üle tüübi \verb!t! on liidetav parajasti siis kui tüüp \verb!t! ise on liidetav. Järgmised kaks rida defineerivad meetodi \verb!add!. Erinevus võrreldes eelmise versiooniga on see, et nüüd ei ole enam vaja pikka tüübispetsiifilist funktsiooninime \verb!add_array! ega lisaargumenti \verb!add_t!. Kui varem oleksime pidanud täisarvuliste vektorite liitmiseks kutsuma funktsiooni \verb!add_array (+)!, siis nüüd piisab sellest, et kutsume lihtsalt funktsiooni \verb!add! ja Haskelli kompilaator tuletab ise, millist \verb!add! meetodi implementatsiooni on mõeldud ja milliseid lisaargumente ta vajab.

      Tüübiklasside puhul, nagu ka klasside puhul objektorienteeritud keeltes, on olemas pärilus. Toome näiteks Haskelli \verb!Control.Applicative! teegis defineeritud klassi \verb!Applicative!, mille esindajad peavad alati kuuluma ka klassi \verb!Functor!.

      \begin{verbatim}class Functor f => Applicative f where
  (<*>) :: f (t -> u) -> f t -> f u
  pure  :: t -> f t\end{verbatim}

      Kirjeldame nüüd detailsemalt, milliseid võimalusi Haskelli tüübiklassid pakuvad ja millised piirangud on neile seatud. Haskell 2010 standard spetsifitseerib tüübiklassid järgnevalt~\cite{Has}.
      \begin{itemize}
        \item
          Klassi deklaratsioon on kujul \verb!class! $cx$ \verb!=>! $C$ $u$ \verb!where! $cdecls$, kus $C$ on uue klassi nimi, $u$ on tüübimuutuja, $cx$ spetsifitseerib, mis klassid klass $C$ pärib, ja $cdecls$ sisaldab klassi meetodeid. Kui päritavate klasside nimekiri $cx$ on tühi, tuleb sümbol \verb!=>! ära jätta. Meetodite nimekiri $cdecls$ võib olla ka tühi, mis juhul tohib (aga ei ole kohustuslik) võtmesõna \verb!where! ära jätta.
        \item
          Päritavaid klasse spetsifitseerides tohib kasutada ainult tüübimuutujat $u$, mis on klassi deklareerides sisse toodud, ja mitte ühtegi teist tüüpi ega ka mitte mõnda uut tüübimuutujat. Näiteks ei tohi kirjutada

          \begin{verbatim}class Bug Int => Bug' t\end{verbatim}

          või

          \begin{verbatim}class Bug u => Bug' t\end{verbatim}
        \item
          Pärilussuhetes ei tohi tekkida tsüklit. Klasside pärilussuhted moodustavad suunatud atsüklilise graafi.
        \item
          Haskell võimaldab mitmest pärilust, ehk tüübiklassil võib olla rohkem kui üks vanem.

          \begin{verbatim}class (A t, B t) => C t\end{verbatim}
        \item
          Iga meetodi deklaratsioon on kujul $v_i$ \verb!::! $cx_i$ \verb!=>! $t_i$, kus $v_i$ on meetodi nimi, $t_i$ on meetodi tüüp ja $cx_i$ on tüübimuutujatele seatavate kitsenduste nimekiri.
        \item
          Tüüp $t_i$ peab sisaldama klassi päises sisse toodud tüübimuutujat $u$. Põhjuseks on see, et vastasel juhul ei ole võimalik klassi meetodi kutsel tuletada, millise tüübi jaoks mõeldud teostust kasutada. Toome näite, mis juhtuks, kui lubada meetodite tüüpe, mis ei vasta sellele kitsendusele.

          \begin{verbatim}class Bug t where
  bug :: Int
instance Bug Char where
  bug = 0
instance Bug Int where
  bug = 1\end{verbatim}

          Kui kasutatakse meetodit \verb!bug!, ei ole tüüpimisalgoritmil võimalik teada, kas tegu on meetodi \verb!bug! teostusega \verb!Char!, \verb!Int! või mõne muu tüübi jaoks. Seetõttu ei ole sellist avaldist ka võimalik väärtustada. Ka eksplitsiitne tüübiannotatsioon ei aita, sest sellise meetodi tüüp on sama kõigi teostuste korral.
        \item
          Kitsenduste nimekiri $cx_i$ tohib kitsendada ainult tüübimuutujaid, mis on sisse toodud tüübis $t_i$. Ei tohi kitsendada tüüpe, mis ei ole tüübimuutujad, näiteks

          \begin{verbatim}class Bug t where
  bug :: Bug' Int => t\end{verbatim}

          Ei tohi tuua kitsendustes sisse tüübimuutujaid, mida tüübis $t$ ei esine, näiteks

          \begin{verbatim}class Bug t where
  bug :: Bug' u => t\end{verbatim}

          Ei tohi kitsendada ka klassi päises deklareeritud tüübimuutujat $u$, näiteks

          \begin{verbatim}class Bug t where
  bug :: Bug' t => t\end{verbatim}
        \item
          $cdecls$ võib sisaldada ka operaatorite assotsieerumissuuna ja prioriteedi deklaratsioone (ing. k. \textit{fixity declaration}) ning vaikedefinitsioone klassi meetodite jaoks.
      \end{itemize}

      Klasside esindajad on spetsifitseeritud järgnevalt.

      \begin{itemize}
        \item
          
        \item
          
        \item
          
        \item
          
        \item
          
        \item
          
        \item
          
        \item
          
      \end{itemize}

      Haskellil on ka palju laiendusi, mis võimaldavad tüübiklasside vallas paindlikkust lisada. \markus{TODO: jätkata sellega, et kirjeldada natuke neid laiendusi}
    \subsection{Tüübiklassid Awfulis}
      Ka käesoleva töö teemaks olev keel Awful võimaldab \textit{ad hoc} polümorfismi tüübiklasside abil. Awful on tüübiklasside osas piiravam kui Haskell 2010 standard järgmistes aspektides:

      \begin{itemize}
        \item
          Lubatud on ainult ühene pärilus. Mitmene pärilus on plaanis lisada edasise töö käigus.
        \item
          Ei ole võimalust lisada vaikedefinitsioone klassi meetodite jaoks.
      \end{itemize}

      \markus{mis kitsendused on tüübiklassidel ja esindajatel Awful-is?}

      \markus{näiteid tüübiklasside kasutusest}
  \peatykk{Üldistatud algebralised andmetüübid}
    \markus{TODO: kusagil seletada, mis on hargnevate andmetüüpide piirangud võrreldes GADT-ga. Mis kasulikke asju nende abil teha ei saa; näited.}

    \markus{Alustuseks näiteid sellest, kuidas saab tavalisi andmetüüpe (nt nat ja list) GADT süntaksiga kirja panna?}
  \peatykk{Tüübitaseme andmed ja edutamine}
    Selles peatükis refereerime, mis on edutamine ning kuidas see muudab tüübisüsteemi väljendusrikkamaks ja aitab kirjutada tüübiturvalisemat koodi. Kuna käesoleva töö autori loodud keelt tutvustatakse alles peatükkides~\ref{syntaks} ja~\ref{manual}, ning kuna Haskell on esimene keel, mille tüübisüsteem sisaldab edutamist~\cite{Giv}, on antud peatükis edutamise põhimõtete selgitamiseks kasutatud Haskelli süntaksit.

    Sageli on tüübiturvalisema koodi kirjutamiseks kasulik, kui saab tüüpide tasemel väärtusi kasutada. Näiteks võimaldavad tüübitaseme naturaalarvud luua vektoreid, mille pikkus, erinevalt listide omast, on juba tüübikontrolli ajal teada. Vektorite pikkustega seotud vead tulevad sellisel juhul välja juba tüübikontrollis, enne interpreteerimist või kompileerimist.

    See võimaldab kirjutada näiteks vektorite liitmise või viimase elemendi leidmise funktsiooni tüübiturvaliselt. Juhul, kui kirjutada neid funktsioone listide abil, ei ole kuidagi tagatud, et programmeerija ei kutsu vektorite liitmise funktsiooni välja kahe erineva pikkusega listi peal või ei kutsu viimase elemendi leidmise funktsiooni tühja listi peal.

    Lisaks kannavad tüübid kasulikku teavet funktsioonide sisendite ja väljundite kohta, ning mida väljendusrikkam tüübisüsteem on seda detailsemalt saavad funktsioonide tüübid funktsioonide sisu kirjeldada. Näiteks juhul kui keeles on võimalik kasutada tüübitaseme naturaalarve, saab vektorite liitmise funktsiooni tüüpi vaadates kohe teada, et kaks vektorit peavad olema sama pikad. Vaadates vektori viimase elemendi leidmise funktsiooni tüüpi, on kohe aru saada, et vektor ei tohi olla pikkusega null.

    Tüübitaseme andmed parandavad tüübiturvalisust, vähendavad korduva koodi hulka ning lisaks aitavad kaasa sellele, et tüübisüsteem oleks väljendusrikkam ja tüübid dokumenteeriks paremini funktsioonide sisu.
    \subsection{Tüübitaseme andmed}\label{tyybitasemeandmed}
      Mõnedes keeltes, näiteks Idris~\cite{The_Idr}, saab tüübitaseme andmete saavutamiseks kasutada sõltuvaid tüüpe. Sõltuvatest tüüpidest anname lühikese ülevaate jaotises~\ref{soltuvad}. Keeles, kus sõltuvaid tüüpe ei ole, on tüübitaseme andmeid võimalik kirjutada algebraliste andmetüüpide abil~\cite{Giv}. Tüübitaseme naturaalarvud näeksid Haskelli algebralisi andmetüüpe kasutades välja sellised:

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Sarnasel viisil saab teostada ka näiteks tüübitaseme liste:

      \begin{verbatim}data Empty_List
data Construct_List t l\end{verbatim}

      Tegu on tühjade tüüpidega, millel puuduvad andmekonstruktorid ja mis on mõeldud spetsiaalselt tüübitaseme andmete rolli täitmiseks.

      Toome mõned lihtsad näited andmetüüpidest, mille konstrueerimiseks on vaja tüübitaseme andmeid. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada. Neil on kaks konstruktorit: üks tühja vektori jaoks, ja teine vektori jaoks pikkusega \verb!n + 1!, mis võtab argumendiks pea ja \verb!n!-elemendilise saba.

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua suvalise arvu muutujatega Boole'i funktsiooni tüüp. \verb!0! muutuja Boole'i funktsioon on üks konstant. \verb!n + 1! muutuja Boole'i funktsioon saab esitada kahe \verb!n! muutuja Boole'i funktsiooni abil (jääkfunktsioonid, mille saame, asendades esimese muutuja vastavalt konstandiga \verb!False! või \verb!True!).

      \begin{verbatim}data Fun :: * -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid, mis sarnanevad struktuuri poolest üleelmises näited toodud vektoritele, selle vahega, et nad võivad sisaldada erinevat tüüpi andmeid.

      \begin{verbatim}data Tuple :: * -> * where
  Empty_Tuple :: Tuple Empty_List
  Construct_Tuple :: t -> Tuple l -> Tuple (Construct_List t l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: * -> * -> * where
  Empty_Array' :: t -> Array' Empty_List t
  Construct_Array' :: Array n (Array' l t) -> Array' (Construct_List n l) t\end{verbatim}

      Tüübitaseme andmed on kasulikud selleks, et saaks kirjutada tüübiturvalisemaid funktsioone. Näiteks kui tahame kirjutada vektorite liitmise funktsiooni, siis juhul kui kasutada vektorite esitamiseks liste, siis on tarvis arvestada ohuga, et programmeerija annab funktsiooni sisendiks erineva pikkusega listid. Erineva pikkusega listid resulteeruvad defineerimata käitumises või erindis programmi töö käigus ning tüüpimise ajal ei ole seda võimalik ennetavalt tuvastada.

      Tüübitaseme andmete olemasolul saab vektorite liitmise funktsiooni kirjutada eelpool näiteks toodud \verb!Array! tüübi peal, ning see tagab, et iga vektorite liitmise funktsiooni kutse puhul kontrollitakse juba tüüpimise ajal, et mõlemad argumendid oleks sama pikad.
    \subsection{Tüübid, liigid ja sordid}
      Niiviisi teostatud tüübitaseme andmetel on oluline puudus. Tüübisüsteem ei ole piisavalt keeruline kirjeldamaks programmeerija tegelikke kavatsusi. Ei ole võimalust kirjeldada, et kohas kus võib esineda näiteks tüüp \verb!Char! või \verb!Int!, ei tohi esineda naturaalarvuline tüüp, ja vastupidi -- ehk tüübid ei ole piisavalt tugevalt tüübitud~\cite{Giv}. Tüübikontrollist lähevad läbi koodinäited, mis ei ole programmeerija tegelike kavatsustega kooskõlas, näiteks:

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next t) n\end{verbatim}

      Siin on konstruktori \verb!Construct_Array! tulemuse tüübis vahetusse läinud tüübimuutujad \verb!n! ja \verb!t!. Koodinäide ei tohiks tegelikult tüüpuda, sest need tüübimuutujad on täiesti erineva otstarbega. Vältimaks seda laadi vigu, oleks vaja tüübisüsteemi, mis on piisavalt võimas kirjeldamaks, et tüübikonstruktori \verb!Array! esimene argument peab olema naturaalarv ja teine tavaline tüüp, ja et tüübikonstruktorit \verb!Next! saab rakendada ainult naturaalarvule.

      Selleks, et tüübitaseme naturaalarvusid, tüübitaseme liste ja teisi tüübitaseme andmeid saaks kasutada turvalisemalt, on vaja võimsamat liigisüsteemi. Liigid on tüüpide jaoks sama, mis tüübid väärtuste jaoks -- tegu on tüüpide tüüpidega. Ka liikidel võivad omakorda olla tüübid ja neid nimetatakse sortideks~\cite{Typ}.

      Tuntud liigikonstruktorid Haskellis on näiteks liik \verb!*! ja liigikonstruktor \verb!->!, mille kaudu konstrueeritakse tüübikonstruktorite liike. Need tagavad, et tüübikonstruktoreid rakendataks õigele arvule õigetele argumentidele, näiteks et programmeerija ei üritaks kirjutada tüüpi \verb!Int List!.

      Võimsam liigisüsteem, mis sisaldaks lisaks eelmainitud liikidele ka kõigi tüübitaseme andmete liike (näiteks naturaalarvude liiki ja listide liiki), aitaks vältida selliseid vigu nagu selles jaotises toodud näites.

      See, et jaotises~\ref{tyybitasemeandmed} kirjeldatud viis tüübitaseme andmeid luua ei ole piisavalt tüübiturvaline, ei ole selle ainus nõrk külg. Lisaks eelmainitud peamisele puudusele, on oluline miinus ka see, et programmeerija peab tüüpide tasemel duplitseerima andmeid, mis on väärtuste tasemel tegelikult juba olemas (näiteks on tüübitaseme naturaalarvud samasuguse struktuuriga mis väärtuste taseme naturaalarvud).

      Edutamine lahendab mõlemad probleemid, muutes tüübi- ja liigisüsteemi võimsamaks ning tagades, et programmeerija ei peaks ise käsitsi tüübitaseme andmeid kirjutama. Järgmistes jaotistes räägimegi sellest, kuidas edutamine töötab, kuidas see muudab tüübisüsteemi ja millised andmetüübid on edutatavad.
    \subsection{Edutamine}
      Edutamine tõstab sobivad andmetüübid automaatselt "`üks tase ülespoole"'. Andmetüübi edutamisel tehakse tüübikonstruktorist liigikonstruktor, kusjuures tüübiparameetritest saavad liigiparameetrid. Andmekonstruktoritest saavad vastava liigi tüübikonstruktorid, kusjuures argumentide tüüpidest saavad tüübikonstruktorite argumentide liigid~\cite{Giv}.
      \subsubsection{Edutamise näiteid}
        Võtame esimeseks näiteks lihtsa andmetüübi, kus puudub polümorfism: naturaalarvud.

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        Ilma edutamiseta saab siit tüübi \verb!Nat :: *! ning kaks andmekonstruktorit \verb!Zr! tüüpi \verb!Nat! ja \verb!Next! tüüpi \verb!Nat -> Nat!. Edutamise olemasolul saab lisaks ka liigi \verb!Nat! ning kaks tüübikonstruktorit \verb!Zr! liiki \verb!Nat! ja \verb!Next! liiki \verb!Nat -> Nat!.

        Vaatleme keerulisemat näidet: liste.

        \begin{verbatim}data List (t :: *) = Empty_List | Construct_List t (List t)\end{verbatim}

        Ilma edutamiseta saab sellest andmetüübist tüübikonstruktori \verb!List :: * -> *! ning kaks andmekonstruktorit \verb!Empty_List! tüüpi \verb!List (t :: *)! ja \verb!Construct_List! tüüpi \verb!(t :: *) -> List t -> List t!. Edutamise olemasolul saab sellest andmetüübist lisaks ka ühe argumendiga liigikonstruktori \verb!List! ning kaks tüübikonstruktorit \verb!Empty_List! liiki \verb!List k! ja \verb!Construct_List! liiki \verb!k -> List k -> List k!.

        Listide puhul tuleb mängu polümorfism. Parametriseeritud tüüp muutub parametriseeritud liigiks. Tüübipolümorfsetest andmekonstruktoritest saavad liigipolümorfsed tüübikonstruktorid.

        Standartne Haskell edutamist ei sisalda ning edutamise jaoks on vaja kasutada keele laiendusi. Vajalikud laiendused on \verb!DataKinds! (edutamine) ja \verb!KindSignatures! (liigisignatuurid) ning, kuna paljud edutamise rakendused nõuavad üldistatud algebralisi andmetüüpe, ka \verb!GADTs!. Liigipolümorfismi jaoks on lisaks vajalik laiendus \verb!PolyKinds!.
      \subsubsection{Andmetüübid, mida saab edutada}\label{kitsendused}
        Edutamisele on mõistlik seada teatud piirangud ning edutada ainult osasid andmetüüpe, mitte kõiki. Piirangud on seotud sooviga kasutada edutamise võimalusi (näiteks tüübitaseme naturaalarvusid ja liste) ilma muutmata tüübisüsteemi keerulisemaks kui hädapärast vajalik. Loetleme siinkohal piirangud, mida on kasutatud Haskellis~\cite{Giv}.

        \begin{itemize}
          \item
            Ei edutata üldistatud algebraliseid andmetüüpe, kuna see muudaks liigisüsteemi keerulisemaks tuues sisse liikide võrdsuskitsendused (ing. k. \textit{equality constraints}).
          \item
            Ei edutata primitiive, näiteks tähti ja täisarvusid. Primitiivide edutamisega ei kaasne tegelikult sisulisi raskusi, küll aga võib neile praktiliste rakenduste leidmine nõua teisi keele täiendusi, mis ei ole sama lihtsad. Haskellis on primitiivide edutamata jätmise põhjuseks see, et keele laienduse autorite arvates ei ole primitiivide edutamine kasulik kui ei ole võimalik edutada tüübitasemele ka tehteid primitiividega (näiteks \verb!Int! tüüpi täisarvude liitmist).
          \item
            Ei edutata andmetüüpe, millel on tüübiparameetreid muud liiki kui liik \verb!*!. Juhul kui edutada ainult sellele kitsendusele vastavaid andmetüüpe, on sortide süsteem äärmiselt lihtne. Kõik liigimuutujad on ühte sorti. See tähendab, et liigipolümorfismi korral ei pea liigimuutujate sorte märkima. Liigikonstruktori sort on lihtsalt naturaalarv, mis näitab, mitut argumenti liigikonstruktor vajab.

            Juhul, kui soovida edutada andmetüüpe, mis sisaldaks tüübiparameetrites mitte ainult liiki \verb!*! vaid ka liigikonstruktorit \verb!->!, ei ole sellele põhimõttelisi takistusi, aga selline täiendus nõuaks keerulisemat sortide süsteemi. Liigimuutujad võivad olla erinevat sorti. Liigipolümorfismi korral oleks vaja liigimuutujate sorte märkida. Edutamise teostamine muutuks keerulisemaks, samas kui vajadus sellise võimsusega liigisüsteemi järele on küsitav.

            Kui tahta minna veel kaugemale ja edutada andmetüüpe, mis on parametriseeritud üle omakorda edutamise teel saadud liikide, oleks see veel keerulisem. Sellisel juhul oleks vaja \textit{topeltedutamist} -- tüübid, mis ei ole parametriseeritud üle edutamise teel saadud liikide, tuleks edutada kaks taset ülespoole -- või peaks tüübid ja liigid sõltuvad olema.
          \item
            Ei edutata liigipolümorfseid tüüpe, kuna sellisel juhul oleks vajalik sordipolümorfism.
          \item
            Loomulikult ei tohi edutada andmekonstruktoreid, mis võtavad mitte-edutatavat tüüpi argumente. Andmekonstruktorite edutamisel muutub tüüp liigiks, aga mitte-edutatavat tüüpi liigiks muuta ei saa, ei ole see võimalik. Tüübi mitte-edutatavus levib kõigile andmekonstruktoritele mis teda kasutavad.
        \end{itemize}

        Sarnastest piirangutest on lähtutud ka Awfuli loomisel, teatud muudatustega.

        \begin{itemize}
          \item
            Keeles ei ole üldistatud algebralisi andmetüüpe, aga on hargnevad andmetüübid, mida kirjeldame alamjaotises~\ref{hargnevad}. Reegli asemel, et ei edutata üldistatud algebralisi andmetüüpe, on keeles Awful tüübisüsteemis reegel, et ei edutata hargnevaid andmetüüpe.
          \item
            Isegi kui jätta kõrvale asjaolu, et tüübitaseme tehteid ei ole Awfulisse plaanis lisada, siis võimalused andmetüüpide konstrueerimiseks on palju piiravamad kui üldistatud algebralised andmetüübid. Selle tõttu ei näe käesoleva töö autor hetkel Awfulis primitiivide edutamisele mõttekaid rakendusi. Tulevikku vaadates on see siiski teostatud, juhuks kui andmetüüpide konstrueerimise viisid tulevikus võimsamaks muutuvad.
          \item
            Lihtsuse huvides edutab Awful ainult neid andmetüüpe, mille kõik konstruktorid on edutatavad. Andmetüübi edutamist koos ainult osade konstruktorite edutamist ei tehta.
          \item
            Oleks võimalik edutada funktsiooni tüüpi sisaldavaid andmekonstruktoreid, näiteks

            \begin{verbatim}data Fun t u = Fun (t -> u)\end{verbatim}

            Siit oleks võimalik edutamise teel saada kahe argumendiga liigikonstruktor \verb!Fun! ning liigipolümorfne tüübikonstruktor \verb!Fun! liiki \verb!Fun(t -> u) -> Fun t u!, kus sümbol \verb!->! tähistab tüübikonstruktori liiki. Selline edutamine võimaldaks edutada andmekonstruktoreid, mis võtavad argumendiks funktsioone, ja neist tuleks tüübikonstruktorid, mis võtavad argumendiks tüübikonstruktoreid.

            Awfulis, erinevalt Haskellist, sellist tüüpi hetkel ei edutata, sest selleks ei olnud otsest vajadust, aga antud täiendusele ei ole põhimõttelisi takistusi ja ei ole välistatud tulevikus selle võimaluse lisamine.
        \end{itemize}
      \subsubsection{Tüübisüsteemi täiendused edutamise lisamisel}
        Selleks, et saaks toimuda edutamine (alamjaotises~\ref{kitsendused} kirjeldatud kitsendustega), on tarvis tüübisüsteemi täiendada. Selles alamjaotises kirjeldame lühidalt, mis muudatused olid Awfulis edutamise teostamiseks vajalikud.

        \begin{itemize}
          \item
            Kui edutame tüübipolümorfseid andmekonstruktoreid, näiteks listikonstruktorid, muutub tüübipolümorfism liigipolümorfismiks. Seega tekib vajadus liigipolümorfsete tüüpide järele.

            Täpselt nagu tüübipolümorfism ilma kohustusliku tüübirakenduseta toob kaasa vajaduse tüübituletuse järele, toob liigipolümorfism ilma kohustusliku liigirakenduseta kaasa vajaduse liigituletuse järele. Awful nõuab teostuse lihtsuse huvides liigirakendust kõigi liigipolümorfsete tüüpide kasutamisel, et vätida liigituletust. Kuna liigipolümorfsed tüübid ei ole nii laias kasutuses kui tüübipolümorfsed andmekonstruktorid ja funktsioonid, ei muuda liigituletuse puudumine keelt nii kohmakaks kui tüübituletuse puudumine.
          \item
            Liigisüsteem peab olema piisavalt võimas ja paindlik, et võimaldada tüüpidest uusi liike teha. Enne edutamise lisamist oli Awfulis ainult äärmiselt primitiivne liigisüsteem, mis sisaldas liiki \verb!Star! (analoogne Haskelli liigiga \verb!*!) ja liiki \verb!Arrow! (tüübikonstruktorite liik, analoogne Haskelli liigiga \verb!->!). Interpretaatori sees olid liigid esitatud järgneva andmetüübi abil:

            \begin{verbatim}data Kind = Star_kind | Arrow_kind Kind Kind\end{verbatim}

            Selgelt ei ole sellisele fikseeritud liigisüsteemile võimalik edutamist üles ehitada ja on tarvis olulisi muudatusi. Awfuli interpretaator kasutab liigi esitamiseks andmetüüpi

            \begin{verbatim}data Kind = Name_kind | Application_kind Kind Kind\end{verbatim}

            Liike \verb!Star! ja \verb!Arrow! käsitletakse muudatuse järel lihtsalt kui nimede erijuhtumeid.
          \item
            Enne edutamise teostamist ei olnud Awfulis sorte. Sortide järele ei olnud vajadust, sest oli ainult kaks fikseeritud liigikonstruktorit ning programmeerija kirjutatud liigi korrektsust oli võimalik kontrollida otse parseri tasandil.

            Liigisüsteem, mida saab lõpmatult uute liikidega laiendada, nõuab sorte. Liike ei saa üksteisele suvaliselt rakendada. Näiteks \verb!Star Arrow! ei ole korrektne liik ega isegi liigikonstruktor, sest \verb!Star! ei võta argumente ja seega ei tohi teda millelegi rakendada. Õnneks on edutamisele seatud piisavalt ranged piirangud ja sortide süsteem ei ole seega keeruline: liigikonstruktori sordiks on naturaalarv, mis näitab, mitut argumenti on tarvis.

            \begin{verbatim}data Sort = Star_sort | Arrow_sort Sort\end{verbatim}
          \item
            Primitiivide edutamisel on vaja lisada vastavad tüübid.
        \end{itemize}
      \subsubsection{Edutamise kasutusjuhtusid}
        Selles alamjaotises külastame uuesti näiteid, mida tõime alamjaotises~\ref{tyybitasemeandmed} rääkides tüübitaseme andmete rakendustest. Näitame, kuidas edutamine muudab nad tüübiturvaliseks ja aitab vältida korduvat koodi.

        Esiteks ei ole edutamise olemasolu korral enam tarvis käsitsi eksplitsiitselt tüübitaseme andmeid kirjeldada. Kirjutame naturaalarvude andmetüübi

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        ja sellest tuletatakse automaatselt liik \verb!Nat! ning vastava liigi tüübikonstruktorid \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!. Mis kõige tähtsam, tänu sellele, et nüüd on olemas liik \verb!Nat!, on tüübitaseme naturaalarvud teostatud tüübiturvaliselt: tüübikonstruktori \verb!Next! puhul on teada, et tema argumendiks kõlbab ainult naturaalarv ja mitte näiteks täht või list.

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Toome mõned lihtsad näited sellest, milleks saab tüübitaseme andmeid kasutada. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada.

      \begin{verbatim}data Array :: Nat -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua \verb!n! muutuja Boole'i funktsiooni tüüp.

      \begin{verbatim}data Fun :: Nat -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid.

      \begin{verbatim}data Tuple :: [*] -> * where
  Empty_Tuple :: Tuple []
  Construct_Tuple :: t -> Tuple l -> Tuple (t : l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: [Nat] -> * -> * where
  Empty_Array' :: t -> Array' [] t
  Construct_Array' :: Array n (Array' l t) -> Array' (n : l) t\end{verbatim}

      Siinkohal võib tekkida küsimus, kas edutamise praktiline kasutamine on võimalik keeles, kus ei ole üldistatud algebralisi andmetüüpe. Need lihtsad ja kasulikud rakendused, mida oleme selles alamjaotises vaadelnud, ei ole teostatavad ainult algebraliste andmetüüpide abil, kuna andmekonstruktorite resultaattüübid peavad erinema. Näiteks vektorite puhul annab üks andmekonstruktor tulemuseks vektori, mille pikkus on \verb!Zr!, aga teine annab tulemuseks vektori pikkusega \verb!Next n!.

      Hea uudis on see, et paljud edutatud andmetüüpide rakendused on siiski võimalikud ilma keelde üldistatud algebralisi andmetüüpe lisamata. On võimalik kasutada piiravamat ja lihtsamat viisi andmetüüpide konstrueerimiseks. Awful toob sisse \textit{hargnevad andmetüübid}, mida tutvustame alamjaotises~\ref{hargnevad}.
    \subsection{Edutamisega kaasnev nimekonflikt}
      Haskellis on tihti tavaks, et andmetüübi konstruktori nimi ühtib tüübi nimega, näiteks

      \begin{verbatim}data Pair t u = Pair t u\end{verbatim}

      Kuna andmekonstruktor \verb!Pair! esineb ainult avaldiste tasandil ja sama nimega tüübikonstruktor esineb ainult tüüpide tasandil, ei teki vajadust neil kahel vahet teha. Edutamine muudab olukorda.

      Edutades ülalpool mainitud andmetüüpi, saame lisaks tüübikonstruktorile \verb!Pair! liiki \verb!* -> * -> *! samanimelise tüübikonstruktori liiki \verb!t -> u -> Pair t u!, kus t ja u on liigimuutujad ning \verb!Pair! on edutamise teel saadud liigikonstruktor. Seega on kaks erineva liigi ja otstarbega aga samanimelist tüübikonstruktorit. Nendel vahet tegemiseks on mitmeid erinevaid võimalusi.
      \subsubsection{Eksplitsiitne edutamine vajaduse korral}
        Haskellis kasutatakse juhtudel, kus tekib nimede konflikt, edutamise teel saadud tüübikonstruktori ees ülakoma~\cite{Giv}. Antud näite korral tähistab tüübikonstruktor \verb!Pair! tavalist tüübikonstruktorit liiki \verb!* -> * -> *! ning \verb!'Pair! tähistab edutamise teel saadud tüübikonstruktorit liiki \verb!t -> u -> Pair t u!.

        Tasub mainida ka, et juhul kui kasutaja otsustab Haskellis \verb!-Wall! võtit kasutada, antakse hoiatused kõigi edutamise teel saadud tüübikonstruktorite kohta, mille ette ei ole ülakoma pandud -- ka nende kohta, mille puhul ei ole nimekonflikti võimalust~\cite{Gla}.
      \subsubsection{Nimekonflikti vältimine}
        Üks võimalus nimekonflikti lahendada on keelata tüübikonstruktori ja andmekonstruktori nimede ühtimine.

        \begin{verbatim}data Pair t u = MkPair t u\end{verbatim}

        Antud lahendus on lihtne, aga tal on puudusi. Nii on võimalik vältida edutamise eksplitsiitset märkimist, aga samas muutuvad pikemaks tavalised andmekonstruktorid. Programmeerijatele, kes on harjunud tüübikonstruktorit ja andmekonstruktorit sama nimega nimetama, võib olla kergem kohaneda edutamise eksplitsiitse märkimisega kui andmekonstruktorite teisiti nimetamisega.
      \subsubsection{Eksplitsiitne edutamine alati}
        Nimekonflikti saab lahendada ka märkides kõik edutamise teel saadud liigid ja tüübid mõne spetsiaalse sümboliga, näiteks ülalpool mainitud andmetüübi \verb!Pair! deklaratsioon annaks lisaks tavalisele andmekonstruktorile ja tüübikonstruktorile ka 2 argumendi liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"t -> u -> !Pair t u".

        Käesoleva töö autori arvates on tegu hea lahendusega, sest erinevalt eksplitsiitsest edutamisest ainult vajaduse korral näevad edutamise teel saadud tüübikonstruktorid ühtlasemad välja. Lisaks võib edutamise teel saadud liigi- ja tüübikonstruktorite eksplitsiitne eristamine aidata programmeerijat, kes ei ole veel edutamisega harjunud ja ei tunne end kindlalt seda abstraktsiooni kasutades. Täpselt nagu tüüpide juurde märkimine võib vahel koodi isedokumenteeruvusele kaasa aidata, võib seda teha ka edutamise teel saadud tüübikonstruktorite eksplitsiitne märkimine.

        Selle tõttu ongi tegu lahendusega, mis sai valitud käesoleva töö raames loodud programmeerimiskeele jaoks. Awful kasutab edutamise tähistamiseks hüüumärki ning nõuab seda nii edutamise teel saadud liikide kui ka tüüpide ees.
    \subsection{Edutamise võrdlus sõltuvate tüüpidega}\label{soltuvad}
      Paljude keelte tüübisüsteemides, sealhulgas Haskelli omas, kehtib \textit{faasierisus} (ing. k. \textit{phase distinction}). Väärtused võivad sõltuda tüüpidest aga mitte vastupidi. Ka edutamise olemasolul jääb faasierisus tegelikult kehtima. Kuigi näiteks vektorite puhul võib tunduda, et vektori tüüp sõltub naturaalarvulisest väärtusest, aga tegelikult on tüübid ja väärtused siiski rangelt eristatud~\cite{Giv}.

      Mõnedes teistes programmeerimiskeeltes, näiteks Agda~\cite{Agd}, Coq~\cite{The_Coq} ja Idris~\cite{The_Idr}, on olemas sõltuvad tüübid. See tähendab, et tüübid võivad sõltuda väärtustest.

      Sõltuvad tüübid, nagu ka edutamine, võimaldavad luua tüübitaseme naturaalarvusid ja liste ning muid tüübitaseme andmeid. Tegu on aga võimsama tööriistaga kui edutamine. Toome mõned lihtsad funktsioonid, mida saab kirjutada kasutades sõltuvaid tüüpe, aga mis ei ole võimalikud ainult andmetüüpide edutamise abil. Tarvitame näidetes Idrise süntaksit, sest see on väga sarnane Haskelli omaga (siinkohal toodud näidetes on ainus erinevus see, et tüübi märkimiseks kasutatakse ühte ja listi konstrueerimiseks kahte semikoolonit).

      Üks lihtne ja kasulik funktsioon, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada, on kahe vektori konkateneerimine. Kui me konkateneerime vektoreid pikkusega \verb!m! ja \verb!n!, siis tulemuse pikkus on \verb!m + n!. Tegu on tüübitaseme naturaalarvude liitmisega. Kui edutatakse ainult tüüpe ja konstruktoreid, ei ole tüübitaseme andmetele võimalik rakendada funktsioone.

      \begin{verbatim}cat : Array m t -> Array n t -> Array (m + n) t
cat Empty_Array b = b
cat (Construct_Array x a) b = Construct_Array x (cat a b)\end{verbatim}

      Toome siinkohal veel ühe näite sõltuvate tüüpide kasutusest~\cite{The_Idr}, mida ei ole võimalik teostada edutamise abil. Üldistatud algebraline andmetüüp \verb!InElement! võimaldab staatiliselt tõestada, et element esineb listis. \verb!inList! funktsiooni tüüp \verb!InList (5 : Int) [1, 2, 5]! on teoreem, mis ütleb, et \verb!5! esineb listis \verb![1, 2, 5]!. See, et meil õnnestub vastavat tüüpi funktsioon kirjutada, tõestab tüübis toodud väite.

      \begin{verbatim}data InList : t -> List t -> Type where
  Here : InList x (x :: l)
  There : InList x l -> InList x (y :: l)
inList : InList (5 : Integer) [1, 2, 5]
inList = There (There Here)\end{verbatim}

      Haskellis \verb!InList! tüüp küll toimib, sest liste on võimalik tüübi tasemele edutada, aga kuna \verb!Int! ei ole edutatav tüüp, ei ole Haskellis võimalik elemendi leidumise tõestust \verb!Int! tüüpi täisarvude listi jaoks läbi viia. Veel halvem on olukord juhul, kui tahaksime analoogseid tõestusi läbi viia vektorite peal. Sõltuvate tüüpidega on see võimalik, aga tavaline ühekordne edutamine ei võimalda saavutada tüübitaseme vektoreid. Haskellis ei läbiks järgnev andmetüüp tüübikontrolli.

      \begin{verbatim}data InArray : t -> Array n t -> Type where
  Here : InArray x (Construct_Array x a)
  There : InArray x l -> InArray x (Construct_Array y a)\end{verbatim}

      Näeme, et paraku on kasulikke ja üldsegi mitte keerulisi funktsioone, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada. Edutamisel on võrreldes sõltuvate tüüpidega siiski ka eeliseid mitte ainult puudusi~\cite{Giv}:

      \begin{itemize}
        \item
          Programmeerijatel, kes on harjunud faasierisusega, võib olla lihtsam kohaneda edutamisega kui sõltuvate tüüpidega.
        \item
          Sõltuvad tüübid muudavad keerulisemaks tüübikontrolli ja tüübituletuse.
        \item
          Faasierisuse puhul on lihtne tüübikontrolli järel kõik tüübid kustutada (mis aitab kaasa heale jõudlusele) ning edutamine ei muuda seda. Tüüpide kustutamine sõltuvate tüüpidega keeles on oluliselt keerulisem.
      \end{itemize}

      Paljude kasutusjuhtude jaoks on edutamine piisav. Edutamine muudab tüübisüsteemi oluliselt võimsamaks ja väljendusrikkamaks, ohverdamata samas lihtsust ja nõudmata programmeerijalt oluliselt teistmoodi tüübisüsteemiga kohanemist.
\begin{comment}
  \begin{frame}[fragile]{Promotion Without GADT-s?}
    Many GADT-s in the examples have a certain pattern:
    \begin{itemize}
      \item
        The kind of the new type constructor \verb!F! starts with \verb!K L1 ... Ln! where \verb!K! is a kind constructor promoted from an algebraic data type.
      \item
        The first type argument of the resulting \verb!F! is a type constructor applied to some type variables.
      \item
        For every constructor \verb!MakeK! of \verb!K!, we write exactly one data constructor. The first type argument of the resulting \verb!F! is constructed with \verb!MakeK!.
      \item
        For each data constructor that we create, the other type arguments of the resulting \verb!F! are type variables.
      \item
        All type variables used in the resulting \verb!F! are different.
    \end{itemize}
    The two examples shown that do not conform to this rule - \verb!Fin! and \verb!Sum! - can also be done by relaxing only the third rule (allowing zero or more than one data constructor of \verb!F! for each type constructor of \verb!K!).
\end{comment}
  \peatykk{Süntaks}\label{syntaks}
    Selles peatükis kirjeldame Awfuli süntaksit.
    \subsection{Süntaksi formaalne spetsifikatsioon}
    Toome konkreetse süntaksi formaalse spetsifikatsiooni. Lisaks püstkriipsule, mis tähistab valikut kahe variandi vahel, on kasutatud ka sümboleid $A^*=\epsilon\mid AA^*$ ja $A?=\epsilon\mid A$ (kus $\epsilon$ tähistab tühja sõnet).

    Käesolev süntaksi spetsifikatsioon ei tegele leksiliste detailidega, nagu tühikud, reavahetused, kommentaarid ning muutujanimede, tähtede ja täisarvude leksiline struktuur. Neid detaile selgitame peatüki lõpus jaotistes~\ref{kommentaarid}-\ref{primitiivid}.

    Loetavuse huvides on keele elementide tähistused ning süntaksi kirjeldamiseks kasutatav notatsioon tavalises kirjatüübis. Keele võtmesõnad ja sümbolid on helehallis fikseeritud laiusega kirjatüübis.

    \begin{equation*}
      \begin{tabular}{llll}
        Fail & $P$ & $::=$ & $I^*D^*C^*\Delta^*$
      \end{tabular}
    \end{equation*}

    Awfuli fail koosneb imporditavate failide nimekirjast ning andmetüüpide, klasside ja funktsioonide deklaratsioonidest.

    \begin{equation*}
      \begin{tabular}{llll}
        Import & $I$ & $::=$ & {\color{helehall}\verb!Load!} $x${\color{helehall}\verb!.awf!}
      \end{tabular}
    \end{equation*}

    Tähega \verb!x! tähistame süntaksi spetsifikatsioonis ükskõik millist nime: kas siis faili, tüübi, tüübimuutuja, konstruktori, struktuuri välja, definitsiooni või lokaalse muutuja oma. Nimede lekstilist struktuuri kirjeldame jaotises~\ref{muutujanimed}.

    \begin{equation*}
      \begin{tabular}{llll}
        Andmetüüp & $D$ & $::=$ & $S\mid A\mid B$
      \end{tabular}
    \end{equation*}

    Andmetüüp võib olla struktuur, algebraline andmetüüp või hargnev andmetüüp. Hargnevate andmetüüpe sisulist poolt tutvustame alamjaotises~\ref{hargnevad}. Käsolevas peatükis toome ainult süntaksi.

    \begin{equation*}
      \begin{tabular}{llll}
        Struktuur & $S$ & $::=$ & {\color{helehall}\verb!Struct!} $xt\phi$
      \end{tabular}
    \end{equation*}

    Struktuuri deklaratsioon sisaldab nime, tüübimuutujaid ja väljasid.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutujad & $t$ & $::=$ & $(${\color{helehall}\verb![!}$\tau(${\color{helehall}\verb!,!} $\tau)^*${\color{helehall}\verb!]!}$)?$
      \end{tabular}
    \end{equation*}

    Iga tüübimuutuja korral on kohustuslik märkida tema liik. Kui tüübimuutujate nimekiri on tühi, tuleb kandilised sulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutuja koos liigiga & $\tau$ & $::=$ & $x$ {\color{helehall}\verb!:!} $L$
      \end{tabular}
    \end{equation*}

    Nagu ka Idrises märgitakse tüüpe ja liike ühe mitte kahe kooloniga.

    \begin{equation*}
      \begin{tabular}{llll}
        Liik              & $L$   & $::=$ & $L_a\mid L_n$                                                       \\
                          & $L_0$ & $::=$ & {\color{helehall}\verb!(!}$L_a${\color{helehall}\verb!)!}$\mid L_n$ \\
        Liigi rakendamine & $L_a$ & $::=$ & $L_0$ $L_0^*$                                                       \\
        Liigi nimi        & $L_n$ & $::=$ & {\color{helehall}\verb"!"}$?x$
      \end{tabular}
    \end{equation*}

    Liikide süntaks on lihtne, koosnedes ainult nimedest ja rakendamisest. Edutamise teel saadud liikide ette käib hüüumärk.

    \begin{equation*}
      \begin{tabular}{llll}
        Väljad või argumendid & $\phi$ & $::=$ & $(${\color{helehall}\verb!(!}$v(${\color{helehall}\verb!,!} $v)^*${\color{helehall}\verb!)!}$)?$ \\
        Muutuja koos tüübiga  & $v$    & $::=$ & $x$ {\color{helehall}\verb!:!} $T$
      \end{tabular}
    \end{equation*}

    Struktuuri väljade ja funktsiooni argumentide süntaks on identne. Juhul, kui struktuuril ei ole väljasid või funktsioonil ei ole argumente, tuleb ümarsulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüüp                        & $T$   & $::=$ & $T_a\mid T_n\mid T_c\mid T_i$                                                       \\
                                    & $T_0$ & $::=$ & {\color{helehall}\verb!(!}$T_a${\color{helehall}\verb!)!}$\mid T_n\mid T_c\mid T_i$ \\
        Tüübi rakendamine           & $T_a$ & $::=$ & $T_0$ $T_0^*$                                                                       \\
        Tüübi nimi ja liigirakendus & $T_n$ & $::=$ & {\color{helehall}\verb"!"}$?x\gamma$                                                \\
        Tüübitaseme täht            & $T_c$ & $::=$ & {\color{helehall}\verb"!"}$c$                                                       \\
        Tüübitaseme täisarv         & $T_i$ & $::=$ & {\color{helehall}\verb"!"}$i$
      \end{tabular}
    \end{equation*}

    Tüüpide süntaks on sarnane liikide omaga, aga keerulisem selle tõttu, et tüüpide puhul lisandub eksplitsiitne liigirakendamine, mis on liigipolümorfsete tüüpide korral kohustuslik liigituletuse vältimiseks, ning tüübitaseme primitiivid. Tähega $c$ tähistame süntaksi spetsifikatsioonis tähte ja tähega $i$ täisarvu. Primitiivide leksilist struktuuri on kirjeldatud jaotises~\ref{primitiivid}.

    \begin{equation*}
      \begin{tabular}{llll}
        Liigirakendus & $\gamma$ & $::=$ & $(${\color{helehall}\verb"["}$L(${\color{helehall}\verb","}$L)^*${\color{helehall}\verb"]"}$)?$
      \end{tabular}
    \end{equation*}

    Liigirakenduse puhul antakse liigiparameetrite konkreetsed väärtused ette kandilistes sulgudes tüübi nime järel. Juhul, kui tüüp ei ole liigipolümorfne, tuleb kandilised sulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Algebraline andmetüüp              & $A$ & $::=$ & {\color{helehall}\verb!Algebraic!} $xt${\color{helehall}\verb!(!}$a${\color{helehall}\verb!,!} $a(${\color{helehall}\verb!,!} $a)^*${\color{helehall}\verb!)!} \\
        Algebralise andmetüübi konstruktor & $a$ & $::=$ & $x(${\color{helehall}\verb!(!}$T(${\color{helehall}\verb!,!} $T)^*${\color{helehall}\verb!)!}$)?$
      \end{tabular}
    \end{equation*}

    Algebraline andmetüüp, nagu ka struktuur, algab nimest ja tüübimuutujate nimekirjast. Sellele järgneb nimekiri vähemalt kahest konstruktorist. Algebralise andmetüübi konstruktor, erinevalt struktuuri omast, ei anna väljadele nimesid.

    \begin{equation*}
      \begin{tabular}{llll}
        Hargnev andmetüüp               & $B$ & $::=$ & {\color{helehall}\verb!Branching!} $x${\color{helehall}\verb"[!"}$x\gamma${\color{helehall}\verb!]!}$t${\color{helehall}\verb!(!}$b${\color{helehall}\verb!,!} $b(${\color{helehall}\verb!,!} $b)^*${\color{helehall}\verb!)!} \\
        Hargneva andmetüübi konstruktor & $b$ & $::=$ & {\color{helehall}\verb"!"}$x$ $x^*$ {\color{helehall}\verb!->!} $x\phi$
      \end{tabular}
    \end{equation*}

    Hargnev andmetüüp algab nimest. Sellele järgneb kandilistes sulgudes liik, mille järgi hargnetakse. Kuna hargnev andmetüüp võib hargneda ainult üle liigi, millel on lõplik arv tüübikonstruktoreid, peab see tingimata olema edutamise teel saadud liik ning liigi nimele peab eelnema hüüumärk. Liigile, üle mille andmetüüp hargneb, järgneb ülejäänud tüübimuutujate nimekiri ja konstruktorite nimekiri. Konstruktor koosneb edutamise teel saadud tüübi nimest, tüübimuutujate nimekirjast, konstruktori nimest ja väljadest.

    \begin{equation*}
      \begin{tabular}{llll}
        Klass  & $C$ & $::=$ & {\color{helehall}\verb!Class!} $x${\color{helehall}\verb!{!}$\tau${\color{helehall}\verb!}!}$(${\color{helehall}\verb!<!}$x${\color{helehall}\verb!>!}$)?(${\color{helehall}\verb!(!}$M(${\color{helehall}\verb!,!} $M)^*${\color{helehall}\verb!)!}$)?$ \\
        Meetod & $M$ & $::=$ & $xtk$ {\color{helehall}\verb!:!} $T$
      \end{tabular}
    \end{equation*}

    Tüübiklassi deklaratsioon algab nimest ning tüübimuutujast koos liigiga looksulgudes. Päritav klass on võimalik spetsifitseerida nurksulgudes. Seejärel tuleb meetodite nimekiri, mis võib olla ka tühi, mis juhul tuleb ümarsulud ära jätta.

    \begin{equation*}
      \begin{tabular}{llll}
        Kitsendused & $k$      & $::=$ & $(${\color{helehall}\verb!<!}$\kappa(${\color{helehall}\verb!,!} $\kappa)^*${\color{helehall}\verb!>!}$)?$ \\
        Kitsendus   & $\kappa$ & $::=$ & $x$ $x$
      \end{tabular}
    \end{equation*}

    Kitsendused pannakse nurksulgudesse. Juhul kui kitsedusi ei ole, tuleb nurksulud ära jätta. Kitsendus koosneb klassi nimest ja kitsendatava tüübimuutuja nimest.

    \begin{equation*}
      \begin{tabular}{llll}
        Definitsioon / esindaja & $\Delta$ & $::=$ & $F\mid I$
      \end{tabular}
    \end{equation*}

    Faili viimases osas defineeritakse funktsioone ja luuakse klasside esindajaid.

    \begin{equation*}
      \begin{tabular}{llll}
        Definitsioon & $F$ & $::=$ & {\color{helehall}\verb!Def!} $xtk\phi$ {\color{helehall}\verb!:!} T {\color{helehall}\verb!=!} $E$
      \end{tabular}
    \end{equation*}

    Funktsiooni definitsioon sisaldab nime, tüübimuutujaid, kitsendusi, argumentide nimekirja, tüüpi ja avaldist. Argumentide nimekiri on süntaktiline suhkur, mis parandab definitsioonide loetavust.

    \begin{verbatim}Def Id[T : Star](x : T) : T = x
Def Id[T : Star] : Function T T = x -> x\end{verbatim}

    Need kaks definitsiooni on ekvivalentsed ning esimene teisendatakse parsimise järel teiseks.

    \begin{equation*}
      \begin{tabular}{llll}
        Avaldis       & $E$       & $::=$ & $\alpha\mid\lambda\mid\mu\mid x\mid c\mid i$ \\
                      & $E_0$     & $::=$ & {\color{helehall}\verb!(!}$\alpha${\color{helehall}\verb!)!}$\mid${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$\mid${\color{helehall}\verb!(!}$\mu${\color{helehall}\verb!)!}$\mid x\mid c\mid i$ \\
        Rakendamine   & $\alpha$  & $::=$ & $E_0$ $E_0^*$ \\
        Lambda        & $\lambda$ & $::=$ & $x$ {\color{helehall}\verb!->!} $E$ \\
        Mustrisobitus & $\mu$     & $::=$ & {\color{helehall}\verb!Match!} $E$ {\color{helehall}\verb!{!}$(M_a\mid M_c\mid M_i)${\color{helehall}\verb!}!} \\
                      & $M_a$     & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_a)^*\delta?$ \\
                      & $\mu_a$   & $::=$ & $x$ $x^*$ {\color{helehall}\verb!->!} $E$ \\
        Vaikevalik    & $\delta$  & $::=$ & {\color{helehall}\verb!, Default ->!} $E$ \\
                      & $M_c$     & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_c)^*\delta$ \\
                      & $\mu_c$   & $::=$ & c {\color{helehall}\verb!->!} $E$ \\
                      & $M_i$     & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_i)^*\delta$ \\
                      & $\mu_i$   & $::=$ & i {\color{helehall}\verb!->!} $E$
      \end{tabular}
    \end{equation*}

    Avaldis võib olla rakendamine, lambda-avaldis, mustrisobitus-avaldis, muutujanimi, täht või täisarv. Lambda-avaldis koosneb muutujanimest, millele järgneb nool ja avaldis. Mustrisobitus algab võtmesõnaga \verb!Match! ja avaldisega, seejärel on looksulgudes harude nimekiri. Juhul, kui tegu on algebraliste andmetüüpide mustrisobitusega ($M_a$), on vaikevalik (\verb!Default!) mittekohustuslik. Mustrid, mida sobitada, koosnevad konstruktori nimest ja muutujate nimekirjast. Juhul, kui tegu on primitiivide mustrisobitusega ($M_c$ ja $M_i$), on vaikevalik kohustuslik.

    \begin{equation*}
      \begin{tabular}{llll}
        Esindaja        & $I$ & $::=$ & {\color{helehall}\verb!Instance!} $x${\color{helehall}\verb!{!}$T_n x^*${\color{helehall}\verb!}!}$k(${\color{helehall}\verb!(!}$m(${\color{helehall}\verb!,!} $m)^*${\color{helehall}\verb!)!}$)?$ \\
        Meetodi teostus & m   & $::=$ & $x$ $x^*$ {\color{helehall}\verb!=!} $E$
      \end{tabular}
    \end{equation*}

    Esindaja korral tuleb märkida klassi nimi, tüübi nimi koos tüübimuutujatega, kitsenduste nimekiri ja meetodite teostuste nimekiri. Meetodi teostus koosneb meetodi nimest, muutujate nimekirjast ja avaldisest. Võimalus otse meetodi nime järel muutujate nimesid kirjutada, et vähendada lambda-avaldiste arvu, on jällegi süntaktiline suhkur.

    Süntaks ei ole taandetundlik. Põhjuseks oli parseri teostuse lihtsus, aga ka soov anda kasutajale vabadus koodi paigutuses. Lisaks vähendab mitte-taandetundlikkus parsimisvigade ohtu suuremate kooditükkide kopeerimisel ühest kohast teise. Antud otsuse peamiseks puuduseks on liigsed sulud ja eraldajad (näiteks \verb!Match! avaldises), mida taandetundlik süntaks oleks aidanud vältida.
    \subsection{Kommentaarid}\label{kommentaarid}
      Kommentaaride süsteem on sarnane Haskellile ja C keelele, selle vahega, et kasutatakse teistsuguseid sümboleid. Üherealist kommentaari alustatakse graavise sümboliga.

      \begin{verbatim}Def Id[T : Star](x : T) : T = T `Ühikfunktsioon\end{verbatim}

      Mitmerealist kommentaari alustatakse lainelise joone ja kaldkriipsuga, ning lõpetatakse kaldkriipsu ja lainelise joonega. Nagu ka Haskellis võib mitmerealisi kommentaare teineteise sisse paigutada.

      \begin{verbatim}~/ Awful on funktsionaalne keel. /~\end{verbatim}
    \subsection{Muutujanimed}\label{muutujanimed}
      Keel on tõstutundlik. Erinevalt Haskellist ei ole piiratud, mis nimed peavad algama suur- ja millised väiketähega. Failid, tüübid, tüübimuutujad, konstruktorid, struktuuride väljad, definitsioonide nimed ja lokaalsed muutujad võivad kõik alata kas suur- või väiketähega vastavalt kasutaja soovile.

      Nimedes on lubatud ülakoma, numbrid (välja arvatud esimeses positsioonis), ladina tähed ja alakriips. ASCII standardis mitte esinevad sümbolid ei ole nimedes lubatud, küll aga tohib neid kasutada kommentaarides.

      Üksik alakriips tähistab, nagu ka Haskellis, nimetamata muutujat.
    \subsection{Primitiivid}\label{primitiivid}
      Tähtede (\verb!Char!) ümber käivad topeltjutumärgid (näiteks \verb#"!"#). Reavahetuse märk on \verb!"\n"!. Hetkel toetab Awful ainult ASCII standardi tähti.

      Täisarvude süntaks on identne Haskelli omaga.
  \peatykk{Keele kirjeldus ja näited}\label{manual}
    \markus{kusagil kirjeldada sisse ehitatud liike ja tüüpe ja nende otstarvet} Awful on deklaratiivne, puhas, funktsionaalne keel.

    Kuna töö teemaks oli tüübisüsteemi arendamine mitte kompileerimisega seotud problemaatika, sai kirjutatud ainult interpretaator ning kompileerimise võimalust ei ole. Tüübisüsteem on siiski staatiline: koodifaile on võimalik tüübikontrollida ka ilma interpretaatorit käivitamata ning tüükontroll toimub enne interpreteerimist mitte selle käigus.

    Erinevalt Haskellist, mis kasutab laiska väärtustamist, on Awful agara väärtustamisega. Laisa väärtustamise puhul väärtustatakse avaldised alles siis, kui nende tulemusi vaja on, samas kui agar väärtustamine tähendab, et kohe funktsiooni kutsel väärtustatakse kõik argumendid~\cite{Sem}.

    \markus{TODO: 1) rohkem näiteid 2) põhjendada disainivalikuid}
    \subsection{Moodulid ja importimine}
      Kõik Awful koodifailid lõpevad laiendiga \verb!.awf!. Awfulis on olemas lihtne moodulite süsteem. Mooduleid saab importida kasutades võtmesõna \verb!Load!. Impordid peavad olema faili alguses ja nende järjekord ei ole oluline.

      \begin{verbatim}Load Algebra.awf
Load Standard.awf\end{verbatim}

      Nimekonfliktide tuvastamise teostuse lihtsuse huvides ei ole lubatud, et kahes erinevas moodulis oleks mõni ühine muutujanimi, isegi juhul kui tegelikku võimalust nimekonfliktiks ei ole.
    \subsection{Liigid ja andmetüübid}
      Haskellis on kaks viisi uusi andmetüüpe luua: tavalised algebralised andmetüübid ja üldistatud algebralised andmetüübid. Awfuli lähenemine andmetüüpidele on teistsugune. Keel pakub kasutajale kolme erinevat viisi uusi andmetüüpe luua: struktuurid, algebralised andmetüübid ja hargnevad andmetüübid. Ükski neist ei ole teisega asendatav, kõigil on erinev otstarve.

      Awful nõuab, et andmetüübid oleks deklareeritud enne klasse ja definitsioone. Andmetüüpide deklaratsioonide omavaheline järjekord ei ole aga oluline isegi kui nende vahel on sõltuvusi.
      \subsubsection{Liigid}
        \markus{siin mainida uuesti edutamist; mainida mis liigid on keelde sisse ehitatud - Star ja Arrow; viidata osale mis räägib edutamisest}
      \subsubsection{Struktuurid}
        Struktuurid on mõeldud andmetüüpide jaoks, millel on täpselt üks konstruktor. Konstruktori nimi ühtib tüübi nimega automaatselt. Erinevalt Haskellist on kohustuslik kirja panna struktuuri väljade nimed.

        \begin{verbatim}Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Juhul, kui struktuur ei kasuta tüübipolümorfismi, tuleb kandilised sulud lihtsalt ära jätta. Sama kehtib ka struktuuri väljade kohta: juhul kui struktuuril ei ole ühtegi välja, tuleb ära jätta ümarsulud väljade loeteluga.

        \begin{verbatim}Struct Trivial\end{verbatim}

      \subsubsection{Algebralised andmetüübid}
        Algebralised andmetüübid on sarnased Haskelli omadega, selle vahega, et kasutajalt nõutakse vähemalt kahte konstruktorit. Juhul, kui kasutaja tahab kirjutada ühe konstruktoriga andmetüüpi, on selleks struktuurid.

        Kuna algebraliste andmetüüpide puhul on andmetel kaks või enam erinevat kuju, ei ole nende jaoks võimalust spetsifitseerida väljade nimesid. Kui struktuurist saab andmed kätte väljade nimede abil, siis algebraliste andmetüüpide jaoks tuleb kasutada mustrisobituse avaldist, mida on kirjeldatud alamjaotises~\ref{match}.
      \subsubsection{Hargnevad andmetüübid}\label{hargnevad}
        \markus{Kirjutada võrdlus GADT-ga. Mis on eelised ja mis on puudused?}
      \subsubsection{Keelde sisse ehitatud andmetüübid}\label{sisseehitatudalgebralised}
        Lisaks tähtedele (\verb!Char!), funktsioonidele (\verb!Function!) ja piiramata suurusega täisarvudele (\verb!Int!) on Awfulis ka ilma standardteeki importimata saadaval järgmised andmetüübid:

        \begin{verbatim}Algebraic Comparison(LT, EQ, GT)
Algebraic List[T : Star](Empty_List, Construct_List(T, List T))
Algebraic Maybe[T : Star](Nothing, Wrap(T))
Algebraic Nat(Zr, Next(Nat))\end{verbatim}

        Väiksem-võrdne-suurem võrdlustulemuse tüüp \verb!Comparison! on keelde sisse ehitatud, sest keelde on sisse ehitatud ka primitiivide (tähtede ja täisarvude) võrdlus. \verb!List! on keelde sisse ehitatud põhjusel, et keelde on sisse ehitatud täisarvude teisendamine stringideks. \verb!Maybe! on lisatud sisse ehitatud klassi \verb!Field! (korpus) jaoks, sest pöördelemendi tehte tulemus antakse \verb!Maybe! monaadi all, kuna kõik korpused peale triviaalse sisaldavad mittepööratavaid elemente. Naturaalarvude tüüp \verb!Nat! on lisatud, sest tulevikus on kavas lisada keelde kolmandaks primitiiviks jäägiklassikorpused, mis nõuavad tüübitaseme naturaalarvusid.

        Kuna kõik need andmetüübid on edutatavad, kaasneb nendega ka vastavate edutamise teel saadud liikide ja tüüpide kasutamise võimalus.
    \subsection{Tüübiklassid}
      Uue tüübiklassi loomine käib võtmesõnaga \verb!Class!, millele järgneb klassi nimi, tüübimuutuja nimi ja liik, päritav klass (kui seda on), ja nimekiri meetoditest koos tüüpidega.

      \begin{verbatim}Class Functor{F : Arrow Star Star}(
  Fmap[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))\end{verbatim}

      Vahel on kasulikud ka ilma meetoditeta klassid. Sisuliselt on tegu predikaatidega tüüpide peal ja nad on kasulikud kirjeldamaks tüüpide omadusi. Üks lihtne näide on klass \verb!Commutative!, mille esindajat saab kirjutada märkimaks, et tüüp, mis on ring, on lisaks teatud tingimustel kommutatiivne. Kuna antud juhul ei ole tüübimuutuja nimetamine vajalik, lubab Awful selle asemele kirjutada alakriipsu.

      \begin{verbatim}Class Commutative{_ : Star}<Ring>\end{verbatim}

      Siinkohal tasub märkida, et täpselt nagu ka teiste klassidega, ei kontrollita selliste predikaatide puhul kasutaja kirjutatud klassiesindajate vastavust nõutud kitsendustele. Awful ei ole tõestusassistent ega paku võimalusi selliste omaduste tõestamiseks.
      \subsubsection{Pärilus}
        Magistritöö skoobi piiratuse tõttu võimaldab Awful ainult ühest pärilust. Seda, et üks klass pärib teist, märgitakse nurksulgude abil:

        \begin{verbatim}Class Finite{T : Star}<Ord>(All : List T)\end{verbatim}

        Näiteks antud juhul eeldab klass \verb!Finite! (mis lubab \verb!All! meetodi abil saada list lõpliku andmetüübi kõigist võimalikest väärtustest) klassi \verb!Ord!.
      \subsubsection{Kitsendused}
        
      \subsubsection{Klassi meetodite tüübikitsendused}
        Vahel on vaja kirjutada klassi, mille meetodid sisaldavad tüübikitsendusi. Hea näide on klass \verb!Mat!, mis on mõeldud üldistamaks erinevaid ruutmaatrikseid ning sisaldab endas adjunktmaatriksi, karakteristliku polünoomi, determinandi ja vektoriga korrutamise meetodeid. Tema meetodites esinevaid tüübimuutujaid on vaja kitsendada kitsendustega \verb!Ring! ja \verb!Commutative!, sest näiteks maatriksi ja vektori korrutamist ei ole võimalik defineerida, kui allolev struktuur ei ole ring, ja determinant nõuab kommutatiivset ringi.

        \begin{verbatim}Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> :
    Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> :
    Function (Array N T) (Function (F N T) (Array N T)))\end{verbatim}
      \subsubsection{Keelde sisse ehitatud klassid}
        Neli klassi on saadaval ka ilma standardteeki importimata:

        \begin{verbatim}Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Ord{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(
  Brackets : Function T (List Char),
  Write : Function T (List Char))\end{verbatim}

        Klass \verb!Ord! on sarnane Haskelli samanimelise klassiga, selle vahega, et Awfulis ei ole klassi \verb!Eq!. See on keelde sisse ehitatud primitiivide võrdluse jaoks.

        Klass \verb!Writeable! on mõeldud andmestruktuuride stringideks teisendamiseks meetodi \verb!Write! abil; \verb!Brackets! on abimeetod, mis paneb avaldise sulgudesse välja arvatud juhul kui tegu on üksiku konstandiga. Tulevikus on plaanis selle klassi abil teostada interpreteerimise tulemuste kuvamine kasutajasõbralikumal kujul kui praegu.

        Klassid \verb!Ring! ja \verb!Field! on tuttavad algebrast: tegu on lihtsalt (mitte tingimata kommutatiivse) ringi ja korpusega. Klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu ringi elemendiks, on mõeldud defineerimaks nulli (\verb!Convert 0!) ja ühikut (\verb!Convert 1!), aga ka selleks, et oleks mugav suvalises ringis elementi täisarvulise konstandiga korrutada. Klass \verb!Ring! on keelde sisse ehitatud täisarvuliste tehete jaoks. Klass \verb!Field! on lisatud, pidades silmas seda, et tulevikus on plaanis teostada jäägiklassikorpuste primitiiv koos kõigi aritmeetikatehetega, sealhulgas pöördelemendi leidmine.
    \subsection{Keelde sisse ehitatud definitsioonid ja esindajad}
      Lisaks alamjaotises~\ref{sisseehitatudalgebralised} loetletud algebraliste andmetüüpide konstruktoritele, on ilma standardteeki importimata võimalik kasutada järgmisi keelde sisse ehitatud muutujaid ja esindajaid:
      \subsubsection{Ühikfunktsioon}
        Ilma standardteeki importimata on saadaval ühikfunktsioon.

        \begin{verbatim}Def Id[T : Star](x : T) : T = x\end{verbatim}

        Põhjuseks on see, et keelde on sisse ehitatud klassi \verb!Ring! esindaja täisarvude jaoks. Klass \verb!Ring! sisaldab muuhulgas meetodit \verb!Convert!, mis teisendab täisarvu ringi elemendiks. Täisarvude ringi korral on meetod \verb!Convert! ekvivalentne ühikfunktsiooniga, mistõttu ongi ühikfunktsioon keelde sisse ehitatud.
      \subsubsection{Täisarvude võrdlus ja aritmeetika}
        Keelde on sisse ehitatud klasside \verb!Ord! ja \verb!Ring! esindajad täisarvude jaoks. Lisaks on olemas ka funktsioonid \verb!Div! ja \verb!Mod!, mis annavad vastavalt täisarvulise jagamise jagatise ja jäägi. Turvalisuse huvides on mõlema funktsiooni tulemus \verb!Maybe! all juhuks kui jagaja on null.
      \subsubsection{Tähtede võrdlus}
        Keelde on sisse ehitatud klassi \verb!Ord! esindaja tähtede jaoks.
      \subsubsection{Täisarvude stringiks teisendamine}
        Keelde on sisse ehitatud klassi \verb!Writeable! esindaja täisarvude jaoks.
      \subsubsection{Defineerimata käitumine}
        Defineerimata käitumist saab märkida erilise muutuja abil, mille nimi on \verb!Crash!. \verb!Crash! on sarnane Haskelli \verb!undefined! muutujaga selle poolest, et mõlemad on parameetriliselt polümorfsed üle suvalise tüübi liigist \verb!*!, selleks et neid saaks panna suvalisse kohta veel kirjutamata kooditüki asenduseks, või luua funktsioone mille käitumine ongi osade argumendiväärtuste korral defineerimata.

        Käitumine väärtustamisel on aga erinev selle tõttu, et Haskell on laisk ja Awful on agar keel. Näiteks Haskelli avaldis \verb!fst (0, undefined)! annab \verb!0!, aga Awfuli analoogne avaldis \verb!First (Pair 0 Crash)! resulteerub tulemuses \verb!Crash!.
    \subsection{Definitsioonid ja esindajad}
      
      \subsubsection{Definitsioonid}
        
      \subsubsection{Esindajad}
        
    \subsection{Avaldised}
      \markus{TODO}
      \subsubsection{Lambda-avaldised}
        Funktsionaalse programmeerimiskeelena sisaldab Awful loomulikult lambda-avaldisi. Mustrisobituse võimalust funktsiooni argumentides ei ole veel teostatud, aga seda on tulevikus plaanis lisada. Süntaks on sarnane Haskelli omaga, aga ei ole vajalik \verb!\! sümbol enne muutujanime. Toome siinkohal näite lambda-avaldist kasutavast funktsioonist.

        \begin{verbatim}Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T =
  Fmap (z -> Multiply z y) (Inverse x)\end{verbatim}

        Süntaktiline suhkur korraga kahe muutuja andmiseks Awfulis puudub. Kui Haskellis saab kirjutada \verb!\ x y -> x!, siis Awfulis peab kirjutama \verb!x -> y -> x!.
      \subsubsection{Mustrisobitus}\label{match}
        Mustrisobitus töötab tähtede, täisarvude ja algebraliste andmetüüpide peal.

        \begin{verbatim}Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}\end{verbatim}

        Saab kirjutada ka \verb!Default! juhu, mida kasutatakse, kui ükski eelnev variant ei sobinud. See vaikevalik tuleb alati kirjutada mustrisobituse viimaseks juhuks.

        \begin{verbatim}Def Max[T : Star]<Ord T>(x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Turvalisuse tagamiseks kontrollitakse iga \verb!Match! avaldise puhul, kas kõik võimalikud juhud on käsitletud. Kattuvad või puuduvad juhud annavad vea. See tähendab, et \verb!Default! juhtum on kohustuslik tähtede ja täisarvude mustrisobituses, ning ka algebraliste andmetüüpide jaoks juhul kui eelnevalt ei ole kõiki võimalikke juhtusid käsitlenud.

        Erinevalt Haskellist ei luba Awful kirjutada keerulisema struktuuriga mustrisobitust, näiteks sobitada sama \verb!Match! avaldisega tühja, 1-elemendilist ja 2-elemendilist listi. Sellise otsuse põhjuseks oli teostamise lihtsus.

        Samuti ei luba Awful \verb!Match! avaldist üle struktuuri (selle asemel tuleb kasutada väljade nimesid, ja tulevikus on plaanis lisada võimalus teha struktuuride mustrisobitust otse funktsiooni argumendis) ega üle hargneva andmetüübi (selle asemel on võimalik kasutada tüübiklasse viisil, mis on kirjeldatud alamjaotises~\ref{tyybiklassihakk}).
      \subsubsection{Tüübiklasside kasutamine tüübimuutujate mustrisobituseks}\label{tyybiklassihakk}
        
    \subsection{Teegid}
      
      \subsubsection{Standardteek}
        Erinevalt paljudest teistest programmeerimiskeeltest, näiteks Haskell ja Idris, ei toimu standardteegi importimine automaatselt. Standardteek tuleb vajaduse korral importida koos teiste koodifailidega. Standardteegi faili nimi on \verb!Standard.awf!.

        Standardteek sisaldab järgmisi andmetüüpe: \verb!Either! (analoogne Haskelli samanimelise andmetüübiga),  \verb!Logical! (loogikaväärtus \verb!False! või \verb!True!), \verb!Pair! (paar), \verb!Tree! (kahendpuu), \verb!Trivial! (ühiktüüp) ja \verb!Tuple! (üldistatud ennik).
      \subsubsection{Algebrateek}
        
      \subsubsection{Ennikud ja mitmemõõtmelised massiivid}
        
    \subsection{Interpretaatori kompileerimine ja kasutajaliides}
      Interpretaatori kompileerimiseks tuleb kompileerida fail \verb!Awful.hs!.

      \begin{verbatim}ghc Awful.hs\end{verbatim}

      Awful annab kasutajale kaks käsklust mida koodifailidele ja avaldistele rakendada: \verb!check!, mis teostab tüübikontrolli, ning \verb!eval!, mis väärtustab avaldise.

      Käsklus \verb!check! võtab argumendiks failinime ning tüübikontrollib mooduli ja kõik selle impordid.

      \begin{verbatim}./Awful check Standard.awf\end{verbatim}

      Käsklus \verb!eval! võtab argumendiks nimekirja failinimedest ja avaldise ning tüübikontrollib moodulid ja kõik nende impordid. Seejärel väärtustatakse avaldise keskkonnas, kuhu on lisatud kõik moodulitest saadud definitsioonid.

      \begin{verbatim}./Awful eval Standard.awf Algebra.awf "Pair Trivial (Complex 0 0)"\end{verbatim}

      Tulemus väljastatakse otse niiviisi, kuidas avaldised on väärtustajas sisemiselt esitatud. Tulemuste kasutajasõbralikumal kujul väljastamine on plaanis teostada tulevikus.
  \peatykk{Teostuse detailid}
    Awfuli interpretaator on kirjutatud Haskellis. See on võrdlemisi tüüpilise arhitektuuriga, koosnedes lekserist, parserist, nimekontollijast, tüübikontrollijast ja väärtustajast. Lisaks on eraldi moodul, mis vastutab kasutajaliidese ja moodulisüsteemi eest.
    \subsection{Parser}
      Awful kasutab aplikatiivset parsimist. Selles jaotises refereerime lühidalt monaadilist~\cite{Mon} ja aplikatiivset parsimist ning selgitame, kuidas täpselt on Awfuli parser teostatud.\markus{kirjutada Alternative klassi kohta, mida kasutan parsimiseks}
      \subsubsection{Parserite andmetüüp}\label{parserityyp}
        Selleks, et saaks kasutada aplikatiivset või monaadilist parsimist, tuleb kirjutada parserite andmetüüp. Toome siinkohal parserite andmetüübi, mis lisaks erinevatele võimalikele väljundtüüpidele ei piira ka sisendi tüüpi ega veateadete andmise viisi.

        \begin{verbatim}newtype Parser s m t = Parser {parser :: s -> m (t, s)}\end{verbatim}

        Selline parser võtab sisendteksti tüüpi \verb!s! ning annab tulemuseks väljundi tüüpi \verb!t! ja parsimata jäänud osa sisendekstist, kusjuures väljund antakse monaadi \verb!m! all.

        Sisend \verb!s! võib olla tähtede nimekiri, aga võib olla ka mõni keerulisem struktuur. Praktikas on oluliselt lihtsam parsida teksti, mille peal on eelnevalt tehtud leksiline analüüs, et parser ei peaks tegelema selliste detailidega nagu nimede ja arvude tähthaaval kokku korjamine või kommentaarid. Lisaks parsitavale tekstile võib olla kasulik kaasas kanda ka lisainfot, näiteks teavet selle kohta, kui kaugele ette on teksti ebaõnnestunud parsimiskatsete käigus vaadatud.

        Monaad \verb!m! on vajalik selle tõttu, et parsimine võib ka ebaõnnestuda või rohkem kui ühe tulemuse anda. See monaad võib olla näiteks \verb!Maybe! (juhul kui meid ei huvita, miks täpselt parsimine ebaõnnestus) või \verb!Either e! (juhul kui vajame veateateid tüüpi \verb!e!). Aga monaad \verb!m! võib olla ka näiteks list, juhul kui on tarvis mitmest parsimist.
      \subsubsection{Monaadiline parsimine}
        Parsereid saab vaadelda monaadidena~\cite{Mon}.

        Juhul kui \verb!m! on funktor, on tüüp \verb!Parser s m! samuti funktor. Intuitiivselt tähendab see, et tüüpi \verb!t! väljundiga parseri puhul saame väljundile eduka parsimise korral rakendada funktsiooni tüüpi \verb!t -> u! ja saame niiviisi parseri väljundtüübiga \verb!u!.

        \begin{verbatim}instance Functor m => Functor Parser s m where
  fmap f (Parser p) = Parser (\x -> fmap (first f) (p x))\end{verbatim}

        Funktsioon \verb!first! moodulist \verb!Data.Bifunctor! rakendab funktsiooni paari (või mõne muu bifunktori) esimesele elemendile.

        Juhul kui \verb!m! on monaad, on tüüp \verb!Parser s m! samuti monaad. Operaator \verb!>>=!, mis võtab argumendiks parseri \verb!p! ja funktsiooni \verb!f!, rakendab sisendtekstile parserit \verb!p! ning, saades tulemuseks väärtuse \verb!r! ja teksti \verb!x!, parsib teksti \verb!x! parseriga \verb!f r!. Meetod \verb!return! teeb väärtusest \verb!r! parseri, mis ei muuda sisendteksti ja annab parsimise tulemuseks sellesama väärtuse \verb!r!.

        \begin{verbatim}instance Monad m => Monad Parser s m where
  Parser p >>= f = Parser (p >=> \(r, x) -> parser (f r) x)
  return r = Parser (\x -> return (r, x))\end{verbatim}

        Operaator \verb!>=>!, mis on defineeritud teegis \verb!Control.Monad!, käitub järgmiselt:

        \begin{verbatim}p >=> f = \x -> p x >>= f\end{verbatim}

        \begin{verbatim}instance MonadPlus m => MonadPlus Parser s m where
  mplus (Parser p) (Parser q) = Parser (\x -> mplus (p x) (q x))
  mzero = Parser (\_ -> mzero)\end{verbatim}
      \subsubsection{Aplikatiivne parsimine}\label{appars}
        Iga tüübikonstruktor, mis on monaad, on ka aplikatiivne funktor. Ka parserid on aplikatiivsed funktorid.

        \begin{verbatim}instance Monad m => Applicative Parser s m where
  Parser p <*> q = Parser (p >=> \(f, x) -> first f <$> q x)
  pure r = Parser (\x -> pure (r, x))\end{verbatim}

        Klassi \verb!MonadPlus! asemel võib erinevate alternatiivide vahel valimiseks kasutada ka klassi \verb!Alternative!, mis eeldab klassi \verb!Applicative!. Klass \verb!Applicative! on peaaegu identne klassiga \verb!MonadPlus!. Ainsaks sisuliseks vaheks on see, et kui \verb!MonadPlus! eelduseks on \verb!Monad!, siis \verb!Alternative! eelduseks on \verb!Applicative!, mis on vähem piirav eeldus.

        Klassis \verb!Alternative! on funktsiooni \verb!mplus! ja konstandi \verb!mzero! asemel samade tüüpidega operaator \verb!<|>! ja konstant \verb!empty!.

        \begin{verbatim}instance Alternative m => Alternative Parser s m where
  Parser p <|> Parser q = Parser (\x -> p x <|> q x)
  empty = Parser (\_ -> empty)\end{verbatim}
      \subsubsection{Awfuli parseri teostus}
        Awfuli parser järgib alamjaotises~\ref{parserityyp} kirjeldatud mustrit, et parser on funktsioon, mis tagastab monaadi all paari parsimistulemisest ning järelejäänud sisendist.

        \begin{verbatim}newtype Parser t = Parser {parser :: State -> Either Location (t, State)}\end{verbatim}

        Sisendiks on tüüp nimega \verb!State!, mis koosneb lekseri väljastatud \markus{kuidas eesti keeles nimetada tokeneid?} nimekirjast ja lisaks asukohast, mis ütleb, kui kaugele on teksti ette vaadatud. See teave on vajalik andmaks võimalikult täpse asukohaga veateateid.

        \begin{verbatim}data State = State Tokens Location\end{verbatim}

        Tulemus antakse \verb!Either Location! monaadi all. Veateate tüübiks on seega \verb!Location!, mis ütleb, kust alates ei õnnestunud teksti enam edasi parsida.

        Parserite järjest komponeerimine (ning seega ka klassi \verb!Applicative! teostus) on täpselt sama mis jaotises~\ref{appars}. Küll aga muudavad veateated keerulisemaks valiku alternatiivide vahel. Erinevalt \verb!Maybe! monaadist või listidest, mille korral veateade puudub, tahaksime anda parsimisvea täpset asukohta.

        \begin{verbatim}instance Alternative Parser where
  Parser p <|> Parser q =
    Parser
      (\x ->
        case p x of
          Left l -> q (update_location x l)
          Right r -> Right r)
  empty = Parser (\(State _ l) -> Left l)\end{verbatim}

      Kui toimub valik kahe alternatiivi vahel, proovime enne esimest parserit. Juhul, kui see õnnestub, tagastamegi vastava tulemuse. Juhul, kui esimene parser ebaõnnestub, tunduks loomulik lihtsalt samale sisendile teist parserit rakendada. Siis aga tekib probleem veateadete asukohtadega. Juhul, kui esimene parser jõuab kaugemale kui teine, aga mõlemad ebaõnnestuvad, ütleks selline süsteem, et viga juhtus varem kui tegelikult. Näiteks kui grammatika lubab sõnet \verb!"Catamorphism"! või \verb!"Category"!, aga parser saab sõne \verb!"Catastrophe"!, tahaksime kasutajale öelda, et viga juhtus tähemärgil \verb!5!, kus ebaõnnestus sõne \verb!"Catamorphism"! parsimine, mitte tähemärgil \verb!4!, kus ebaõnnestus sõne \verb!"Category"! parsimine.

      Ka kahest vea-asukohast suurima leidmine ei aita. Kui tahame parsida kogu teksti reegliga \verb!many p <*> many q!, kus \verb!p! parsib sõnet \verb!"aa"! ja \verb!p! parsib sõnet \verb!"ba"!, siis teksti \verb!"ab"! korral antaks vea asukohaks \verb!1! mitte \verb!2!. Parser \verb!many p! õnnestub ja jätab jäägiks kogu teksti \verb!"ab"!. Rakendades sellele parserit \verb!many q!, mis ei mäleta, kui kaugele parser \verb!p! jõudis, tulebki välja, nagu oleks viga kohe stringi alguses, kuigi tegelikult jõudis esimene parser kaugemale.

      Selleks jätabki Awfuli parser alati meelde kõige suurema asukoha, kuhu mõnel katsel edukalt jõuti, ning see asukoht väljastataksegi programmeerijale veateates. Uue kõige kaugema vea-asukoha arvutamist teostab funktsioon \verb!update_location!.

        \begin{verbatim}update_location :: State -> Location_0 -> State
update_location (State a b) c = State a (max b c)\end{verbatim}
    \subsection{Tüübikontroll}
      Awful võimaldab andmetüüpe, klasse ning definitsioone ja esindajaid kirjutada ükskõik millises järjekorras, olenemata nende omavahelistest sõltuvustest. Selle tõttu läbib tüübikontrollija nii andmetüübid, klassid kui ka definitsioonid ja esindajad kaks korda.
      \subsubsection{Andmetüübid}
        
      \subsubsection{Klassid}
        
      \subsubsection{Definitsioonid ja esindajad}
        
    \subsection{Väärtustamine}
      Väärtustaja kasutab avaldisi, mille küljes ei ole tüübiinfot.
\begin{comment}
    Add_Int_expression_2 |
    Add_Int'_expression_2 Integer |
    Algebraic_expression_2 String [Expression_2] |
    Application_expression_2 Expression_2 Expression_2 |
    Field_expression_2 String |
    Function_expression_2 Pattern_0 Expression_2 |
    Match_expression_2 Expression_2 Matches_2 |
    Struct_expression_2 (Map' Expression_2) |
\end{comment}
      \subsubsection{Struktuurid}
        
      \subsubsection{Algebralised andmetüübid}
        Algebralise andmetüübi esitus väärtustajas on list väljade sisust, millele on lisatud konstruktori nimi. Konstruktori nimi on algebraliste andmetüüpide puhul erinevalt struktuurist vajalik, sest seda kasutatakse mustrisobitusel õige haru leidmiseks.
      \subsubsection{Defineerimata käitumine}
        Muutuja \verb!Crash! on keelde sisse ehitatud muutuja, mis esineb tüüpimiskeskkonnas, aga seda ei ole lisatud väärtustamiskeskkonda. Väärtustaja annab tulemuse \verb!Maybe! monaadi all, ning kui muutuja väärtustamiskeskkonnast leidmine ebaõnnestub (mis võib juhtuda ainult muutuja \verb!Crash! korral), antakse tulemuseks \verb!Nothing! ja kasutajale kuvatakse, et väärtustamise lõpptulemuseks oli \verb!Crash!.
      \subsubsection{Struktuuri väljade leidmine}
        
      \subsubsection{Mustrisobitus}
        
      \subsubsection{Lambda-avaldised}
        
      \subsubsection{Klasside meetodid}
        
    \subsection{Moodulisüsteem}
      
  \peatykk{Edasine töö}
    \subsection{Liik kui kategooria}
      ~\cite{Cat}.
    \subsection{Klass kui alamliik}
      
    \subsection{Mitmene pärilus}
      
    \subsection{Kasutusmugavus}
      \markus{let-avaldis} Magistritöö mahu tõttu keskendus töö tüübiklasside ja edutamise arendamisele ning töö skoobist jäid välja mõned väikesed, keele võimalusi otseselt mitte laiendavad, aga kasutusmugavuse seisukohast olulised aspektid. Need on plaanis tulevikus teostada, et muuta keeles kirjutatud kood loetavamaks ja kasutajasõbralikumaks.
      \begin{itemize}
        \item
          Võimaldada eksplitsiitset tüübirakendamist, et säästa kasutajale liigsete abi-definitsioonide tegemise vaeva
      \end{itemize}
      \subsubsection{Operaatorid}
        
      \subsubsection{Mustrisobitus funktsioonide argumentides}
        
      \subsubsection{Väärtustamise tulemuste trükkimine}
        Anda interpreteerimise tulemused prettyprinditud kujul (\verb!Writeable! klassi abil)
      \subsubsection{Tüübisünonüümid}
        
      \subsubsection{Tüübirakendamine}
        
      \subsubsection{Detailsemad veateated}
        Hetkel antakse tüübivigade puhul ainult funktsioon, kus viga tekib. Ei öelda täpsemat põhjust. Tulevikus on plaanis veateatele lisada teave selle kohta, millise kahe tüübi unifitseerimine ebaõnnestus.

        Teine veateadete liik, mida saab oluliselt informatiivsemaks muuta, on veateated, mis tulenevad sellest, et kitsendatud meetodit üritatakse kutsuda väärtuse peal, mille jaoks need klassikitsendused ei kehti.

        \begin{verbatim}Def Max[T : Star](x : T, y : T) : T = Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Antud näites on kasutaja unustanud kirjutada tüübikitsenduse, mistõttu funktsioon ei tüüpu. Hetkel öeldakse veateates, et vea põhjustas klass \verb!Ord!, aga kasutajale ei öelda, et vea põhjustas meetod \verb!Compare! ja et tüüp, mille jaoks klassikitsendus täitmata on, on \verb!T!. Kasutaja peab ise välja mõtlema, kas viga tuleb puuduvast tüübimuutuja kitsendusest või hoopis mõnest konkreetse tüübi jaoks kirjutamata jäänud esindajast. Veateade, mis ütleks, mis tüübi jaoks on kitsendus rahuldamata, aitaks seda laadi vigu kiiremini parandada.
    \subsection{???}
      \markus{Tüübiklassihäki eemaldamine}
    \subsection{Süntaksi kasutajapoolsete täienduste võimalus}
      
    \subsection{Jäägiklassikorpuste primitiiv}
      
  \peatykk{Kokkuvõte}
    \markus{what did you do?}

    \markus{What are the results?}

    \markus{future work?}
  \newpage
  \addcontentsline{toc}{section}{\refname}
  \bibliography{bachelor-thesis}
  \peatykktarn{Litsents}
    \subsection*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele kättesaadavaks tegemiseks}
      Mina, \textbf{Liisi Kerik},

      \begin{enumerate}
        \item
          annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose

          \textbf{\pealkiri}

          mille juhendaja on Härmel Nestra

          \begin{enumerate}
            \item[1.1]
              reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni;
            \item[1.2]
              üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace´i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
          \end{enumerate}
        \item
          olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
        \item
          kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi. 
      \end{enumerate}

      \noindent
      Tartus, 21.05.2018
\end{document}