% Institute of Computer Science thesis template
% authors: Sven Laur, Liina Kamm
% last change Tõnu Tamme 09.05.2017
\documentclass[12pt]{article}
\usepackage{CormorantGaramond}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english, estonian]{babel}
\usepackage[labelsep = period]{caption}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{inconsolata}
\usepackage[utf8x]{inputenc}
\usepackage[final, kerning = true, spacing = true]{microtype}
\usepackage{pifont}
\usepackage{verbatim}
\addto\captionsestonian{
  \renewcommand\refname{Viidatud kirjandus}}
\bibliographystyle{plain}
\def\linnuke{\ding{51}}
\def\pealkiri{Funktsionaalse programmeerimiskeele liigisüsteem}
\definecolor{ereroheline}{RGB}{0,255,0}
\definecolor{hall}{RGB}{128,128,128}
\definecolor{helehall}{RGB}{192,192,192}
\definecolor{must}{RGB}{0,0,0}
\definecolor{roheline}{RGB}{0,128,0}
\newcommand\peatykk[1]{
  \clearpage
  \section{#1}}
\newcommand\peatykktarn[1]{
  \clearpage
  \section*{#1}
  \addcontentsline{toc}{section}{#1}}
\newcommand\markus[1]{\textcolor{roheline}{\textbf{#1}}}
\begin{document}
  \thispagestyle{empty}
  \begin{center}
    \large
      TARTU ÜLIKOOL\\
      Arvutiteaduse instituut\\
      Informaatika õppekava

    \vspace{25mm}

    \Large
      Liisi Kerik

    \vspace{4mm}

    \huge
      \pealkiri

    \vspace{20mm}

    \Large
      Magistritöö (30 EAP)
  \end{center}

  \vspace{2mm}

  \begin{flushright}
    \begin{tabular}{rl} 
      Juhendaja: & Härmel Nestra, PhD
    \end{tabular}
  \end{flushright}
  \vfill
  \centerline{Tartu 2018}
  \newpage
  \noindent
  \textbf{\large\pealkiri}

  \vspace*{1ex}

  \noindent
  \textbf{Lühikokkuvõte:}

  \noindent
  Staatilised tüübisüsteemid võimaldavad leida programmidest teatud vigu juba enne koodi käivitamist ja aitavad seega kaasa töökindlama koodi kirjutamisele. Paljud funktsionaalsed keeled, näiteks Haskell ja Idris, on staatiliselt tüübitud.

  Mida väljendusrikkam on keele tüübisüsteem, seda rohkem vigu on võimalik juba tüübikontrolli ajal leida. Osad keeled, näiteks Idris, kasutavad sõltuvaid tüüpe, mis muudavad tüübisüsteemi võimsaks aga ka keeruliseks. Hiljuti Haskellis sisse toodud edutamine tõstab tüübisüsteemi väljendusrikkust ilma sõltuvate tüüpideta, võimaldades tüübitaseme andmeid, näiteks tüübitaseme naturaalarvusid ja liste. Koos üldistatud algebraliste andmetüüpidega laseb edutamine programeerijal konstrueerida kasulikke andmestruktuure, näiteks staatilise pikkusega vektoreid ning üldistatud ennikuid.

  Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud funktsionaalne programmeerimiskeel, mille tüübisüsteemi on rikastatud edutamise abil. Tulemuseks olev keel Awful näitab, et edutamise teel saadud liikide ja tüüpidele on palju kasulikke rakendusi ka keeles, milles puuduvad üldistatud algebralised andmetüübid.

  Awful kasutab üldistatud algebraliste andmetüüpide abil piiravamat aga oluliselt lihtsamat uut andmetüüpide konstrueerimise viisi. \textit{Hargnevad andmetüübid} võimaldavad konstrueerida paljusid kasulikke struktuure, näiteks staatilise pikkusega vektoreid, mille jaoks Haskellis või Idrises kasutataks üldistatud algebralisi andmetüüpe.

  \vspace*{1ex}

  \noindent
  \textbf{Võtmesõnad:} andmetüübid ja struktuurid, deklaratiivne programmeerimine, funktsionaalprogrammeerimine, liigid, polümorfism, edutamine, tüübisüsteemid

  \vspace*{1ex}

  \noindent
  \textbf{CERCS:} P175 Informaatika, süsteemiteooria

  \vspace*{3ex}

  {
    \selectlanguage{english}
    \noindent
    \textbf{\large A Kind System for a Functional Programming Language}

    \vspace*{1ex}

    \noindent
    \textbf{Abstract:}

    \noindent
    Static type systems find some classes of bugs before the program is run, thereby assisting in writing safer code. Many functional languages, for example, Haskell and Idris, are statically typed.

    The more expressive a language's type system is, the more bugs can be found during type checking. Some languages, for example, Idris, use dependent types, which result in an expressive albeit complex type system. Promotion, which has been recently introduced in Haskell, improves the expressiveness of the type system without resorting to dependent types by endowing the language with type level data, like type level natural numbers and lists. Together with generalised algebraic data types it allows the programmer to construct, for example, statically sized vectors and tuples of arbitrary length.

    The aim of this work was to develop a statically typed functional language with a type system that has been enriched via promotion. The language which is the result of this work, Awful, shows that promoted kinds and types have many useful applications even in a language that does not have generalised algebraic data types.

    Instead of generalised algebraic data types Awful employs a more restrictive but also considerably simpler new way of constructing new data types. \textit{Branching data types} enable construction of many useful data structures, like statically sized vectors, for which we would use generalised algebraic data types in Haskell or Idris.

    \vspace*{1ex}

    \noindent
    \textbf{Keywords:} data types and structures, declarative programming, functional programming, kinds, polymorphism, promotion, type systems

    \vspace*{1ex}

    \noindent
    \textbf{CERCS:} P175 Informatics, systems theory

    \vspace*{1ex}}
  \newpage
  \tableofcontents
  \peatykktarn{Tänusõnad}
    Autor soovib tänada käesoleva töö valmimisele kaasa aidanud inimesi.

    Minu juhendaja Härmel Nestra on juhendamisprotsessi käigus ilmutanud otsatut kannatlikkust, ka siis kui asjad ei ole läinud plaanipäraselt. Tänan teda huvitavate ideede ja nõuannete ning põhjaliku tagasiside eest, ja selle eest, et mul on magistritöö vallas olnud palju loomevabadust ning huvitav ja inspireeriv teema.

    Jaak Randmets on see, tänu kellele mul tekkis huvi programmeerimiskeelte vastu ja idee üritada programmeerimiskeelt luua. Ilma temata ei oleks ma enda jaoks seda huvitavat valdkonda avastanud. Tema jagatud teadmised ning nõuanded keele disaini ja teostuse vallas, aga eelkõige nakkav entusiasm programmeerimiskeelte teemal ja toetav suhtumine, on interpretaatori kirjutamisel olnud hindamatuks abiks.
  \peatykk{Sissejuhatus}
    Käesoleva töö eesmärgiks oli arendada staatiliselt tüübitud puhas funktsionaalne programmeerimiskeel. Dünaamiliselt tüübitud keeltes, nagu näiteks Python~\cite{Pyt} ja Wolfram Language~\cite{Wol}, selguvad kõik vead programmi töö käigus. Klassikalisteks näideteks vigadest, mis võivad programmi töö käigus juhtuda, on funktsiooni kutsumine vale tüüpi argumendi peal, massiivi indekseerimine liiga suure arvuga, katse liita arvu ja sõnet, või nulliga jagamine. Staatiliselt tüübitud keeltes, nagu Haskell~\cite{Has} ja Idris~\cite{The_Idr}, aitab tüübikontroll ennetada osasid programmi jooksutamise käigus tekkivaid vigu ja soovimatut käitumist. Staatiline tüübikontroll muudab koodi tüübiturvalisemaks.

    Turingi-täieliku keele puhul ei saa tüübikontroll, mille termineerumine on alati tagatud, ennetada kõiki vigu, ilma samas osasid korrektseid programme kõrvale heitmata. See tähendab, et iga tüübikontrolli-algoritm, mis alati termineerub ja on täielik (kiidab heaks kõik korrektsed programmid), peab lubama osasid ebakorrektseid programme~\cite{Typ}. Mida väljendusrikkam on tüübisüsteem, seda rohkem vigu on võimalik ennetada. Näiteks on osades programmeerimiskeeltes kõik massiivide pikkuse ja indekseerimisega seotud vead dünaamilised, aga osades keeltes on olemas staatilise pikkusega vektorid, mille puhul vektori pikkus on tema tüübi osa ja seega näiteks programm, kus üritatakse leida skalaarkorrutist kahest erineva pikkusega vektorist, tunnistatakse ebakorrektseks juba enne käivitamist.

    Kuna staatiline tüübikontroll ennetab osasid programmi töö käigus tekkivaid vigu, vähendab see soovimatu käitumise, programmi kokku jooksmise ja turvaaukude ohtu. Seega on tüübisüsteemid suure praktilise tähtsusega.

    Käesoleva töö tulemuseks on staatiliselt tüübitud puhas funktsionaalne programmeerimiskeel nimega Awful. Awfuli tüübisüsteem sisaldab parameetrilist polümorfismi~\cite{Fun} ja ühe muutuja tüübiklasse~\cite{How} ning tüübisüsteemi on rikastatud edutamise abil, võttes eeskuju Haskellist~\cite{Giv}. Üks oluline erinevus teistest keeltest on andmetüübid. Haskellis on lisaks tavalistele algebralistele andmetüüpidele olemas üldistatud algebralised andmetüübid. Awfulis puuduvad üldistatud algebralised andmetüübid ja nende asemel tuuakse sisse \textit{hargnevad andmetüübid}, mis on piiravamad, aga samas ka oluliselt lihtsamad.

    Käesolevas töös alustame sellest, et kirjutame tüübiklassidest ning võrdleme, millised omadused on Haskelli ja Awfuli tüübiklassidel. Meenutame lühidalt üldistatud algebralisi andmetüüpe, tutvustame tüübitaseme andmeid ja edutamist ning toome näiteid sellest, kuidas edutamine muudab tüübisüsteemi väljendusrikkamaks. Meenutame lühidalt ka sõltuvaid tüüpe ja vaatleme, kuidas need võrdlevad edutamisega.

    Töö teises pooles tutvustame käesoleva töö teemaks olevat keelt Awfulit. Spetsifitseerime keele süntaksi. Kirjeldame keelt, põhjendame disainivalikuid ja toome koodinäiteid. Viimases peatükis räägime täiendustest ja parandustest, mida on tulevikus kavas teostada. Peamised plaanitavad muudatused on liikide käsitlemine kategooriatena ning klasside käsitlemine alamliikidena, aga lisaks on kavas ka väiksemad keele kasutajasõbralikkuse ja väljendusrikkuse seisukohast olulised täiendused.
  \peatykk{\textit{Ad hoc} polümorfism ja tüübiklassid}
    Parameetriline polümorfism võimaldab käsitleda koos andmeid, millel on sama struktuur aga erinevat tüüpi sisu. Näiteks ei ole parameetrilise polümorfismiga keeles tarvis luua kahte erinevat andmetüüpi tähtede listide ja täisarvude listide jaoks. Selle asemel võib luua parametriseeritud andmetüübi, mille abil saab konstrueerida ükskõik millise sisuga liste. Sellise andmetüübi jaoks saab kirjutada ka parameetriliselt polümorfseid funktsioone. Näiteks käitub listide konkateneerimine samamoodi olenemata sellest, kas konkateneerime tähtede või täisarvude liste.

    Parameetriline polümorfism ei ole ainus polümorfismi liik, mida programmeerimiskeeled kasutavad. Teine oluline abstraktsioon on \textit{ad hoc} polümorfism~\cite{Fun}.
    \subsection{\textit{Ad hoc} polümorfism}\label{peidetudargumendid}
      Kui parameetrilise polümorfismi korral tegeleme andmete ja funktsioonidega, millel on samasugune struktuur ja käitumine olenemata parameetrite väärtusest, siis \textit{ad hoc} polümorfism võimaldab kokku võtta funktsioone, millel on sarnane otstarve, aga erinev käitumine, mis oleneb andmete tüübist.

      Üks lihtne näide on aritmeetikatehted. Aritmeetikatehteid on tarvis paljude erinevate struktuuride jaoks. Me tahame liita ja korrutada täisarvusid, jäägiklassiringide elemente, loogikaväärtusi, vektoreid, kompleksarvusid, maatrikseid, harilikke murdusid, polünoome, kvaternione ja pajusid muid tüüpe. Kõigi puhul on liitmise ja korrutamise teostused erinevad, aga on ka olulisi ühiseid jooni (näiteks see, et liitmise ja korrutamise vahel kehtib distributiivsus).

      On mugav, kui erinevate tüüpide peal töötavate aritmeetikatehete jaoks on võimalik kasutada samu funktsiooninimesid ja operaatoreid. Kontekstist on enamasti selge, mida liidetakse või korrutatakse, ning seega arvukalt erinevaid funktsiooninimesid või operaatoreid ainult muudab koodi pikemaks ja vähem loetavaks.

      Eriti kasulik on \textit{ad hoc} polümorfism siis, kui on tarvis parameetriliselt polümorfse funktsiooni sees erineva teostusega aga sarnase otstarbega funktsioone kasutada. Toome näiteks vektorite liitmise. Olgu meil staatilise pikkusega vektorite tüüp \verb!Array!, mille esimene argument näitab suurust ja teine elementide tüüpi. Olgu tühja vektori konstruktor \verb!Empty_Array! ja mittetühja vektori konstruktor \verb!Construct_Array!. Juhul, kui Haskellis ei oleks \textit{ad hoc} polümorfismi, peaks vektorite liitmise funktsioon, mis töötab erineva sisuga vektorite peal, võtma lisaargumendiks ka vastava tüübi elementide liitmise.

      \begin{verbatim}add_array :: (t -> t -> t) -> Array n t -> Array n t -> Array n t
add_array _ Empty_Array Empty_Array = Empty_Array
add_array add_t (Construct_Array x a) (Construct_Array y b) =
  Construct_Array (add_t x y) (add_array add_t a b)\end{verbatim}

    Lisaargument \verb!add_t!, mis ütleb, kuidas täpselt vektorite elemente liita, tuleks anda igal \verb!add_array! kutsel. Selline lähenemine resulteerub pikas ja halvastiloetavas koodis.

    Õnneks on Haskellis ja ka paljudes teistes keeltes olemas \textit{ad hoc} polümorfism, mis võimaldab sellised lisaargumendid likvideerida -- erinevaid tüüpe saab liita sama funktsiooninime või operaatoriga ja keel suudab ise tuvastada, millist liitmist rakendada. Haskelli \textit{ad hoc} polümorfism on teostatud tüübiklasside kaudu~\cite{How}.
    \subsection{Tüübiklassid Haskellis}\label{haskklass}
      Toome alustuseks lihtsa näite tüübiklassist, selgitades, kuidas eelmise jaotise näide vektorite liitmisest tüübiklasside olemasolul muutub. Seejärel loetleme, millised piirangud ja nõuded on seatud Haskelli tüübiklassidele.

      Kui tahame luua funktsiooni \verb!add!, mis töötaks erinevate andmetüüpide peal erinevalt, peab ta olema tüübiklassi meetod. Loomegi selle jaoks lihtsa ühe meetodiga tüübiklassi \verb!Additive!. Tüübiklassid võivad sisaldada ka mitut meetodit, aga selles näites piirdume lühiduse huvides ainult ühega.

      \begin{verbatim}class Additive t where
  add :: t -> t -> t\end{verbatim}

      See klassideklaratsioon ütleb, et kui tüüp \verb!t! kuulub klassi \verb!Additive!, on tema jaoks defineeritud meetod \verb!add! tüüpi \verb!t -> t -> t!. Nüüd ütleme, et vektor on selle klassi \textit{esindaja} (ing. k. \textit{instance}).

      \begin{verbatim}instance Additive t => Additive (Array n t) where
  add Empty_Array Empty_Array = Empty_Array
  add (Construct_Array x a) (Construct_Array y b) =
    Construct_Array (add x y) (add a b)\end{verbatim}

      Esimene rida ütleb, et vektor üle tüübi \verb!t! on liidetav parajasti siis, kui tüüp \verb!t! on liidetav. Järgmised kolm rida defineerivad meetodi \verb!add! teostuse vektorite jaoks. Erinevus võrreldes eelmise versiooniga on see, et nüüd ei ole enam vaja pikka tüübispetsiifilist funktsiooninime \verb!add_array! ega lisaargumenti \verb!add_t!. Kui varem oleksime pidanud täisarvuliste vektorite liitmiseks kutsuma funktsiooni \verb!add_array (+)!, siis nüüd piisab sellest, et kutsume lihtsalt funktsiooni \verb!add! ja Haskelli kompilaator tuletab ise lähtuvalt kontekstist, millist \verb!add! meetodi teostust on mõeldud ja milliseid lisaargumente ta vajab.

      Tasub tähele panna, et mittetühjade vektorite liitmise avaldises kasutatud meetodi \verb!add! kutsed tähistavad tegelikult kahte erinevat väärtust: esimene tähistab vektori elementide liitmist (näite eelmises versioonis argument \verb!add_t!), teine tähistab vektorite liitmist (näite eelmises versioonis \verb!add_array add_t!).
      \subsubsection{Pärilus}
        Tüübiklassid, nagu ka klassid objektorienteeritud keeltes, võivad üksteist pärida. Toome näiteks Haskelli klassi \verb!Applicative!, mille esindajad peavad alati kuuluma ka klassi \verb!Functor!.

        \begin{verbatim}class Functor f where
  fmap :: (t -> u) -> f t -> f u
class Functor f => Applicative f where
  (<*>) :: f (t -> u) -> f t -> f u
  pure  :: t -> f t\end{verbatim}

        Pärilus ei tähenda, et klassi \verb!Applicative! esindajad defineeritakse kompilaatori poolt automaatselt ka klassi \verb!Functor! esindajateks. See tähendab, et kui tüüp defineeritakse klassi \verb!Applicative! esindajaks, peab ta olema defineeritud ka klassi \verb!Functor! esindajaks -- programmeerija peab seda ise tegema (või kasutama võtmesõna \verb!deriving! vastava esinaja tuletamiseks).

        \begin{verbatim}instance Functor [] where
  fmap f x =
    case x of
      [] -> []
      y : z -> f y : fmap f z
instance Applicative [] where
  x <*> y =
    case x of
      [] -> []
      f : z -> fmap f y ++ z <*> y
  pure x = [x]\end{verbatim}

        Rohkem näiteid tüübiklassidest, kasutades juba Awfuli süntaksit, on peatükis~\ref{manual}. Järgnevates alamjaotistes kirjeldame detailsemalt, milliseid võimalusi Haskelli tüübiklassid pakuvad ja millised piirangud on neile seatud.
      \subsubsection{Tüübiklassid Haskell 2010 standardis}\label{haskstd}
        Haskell 2010 standard spetsifitseerib tüübiklassid järgnevalt~\cite{Has}.
        \begin{itemize}
          \item
            Klassi deklaratsioon on kujul \verb!class! $cx$ \verb!=>! $C$ $u$ \verb!where! $cdecls$, kus $C$ on uue klassi nimi, $u$ on tüübimuutuja, $cx$ spetsifitseerib, mis klassid klass $C$ pärib (teisisõnu spetsifitseerib $C$ ülemklassid) ja $cdecls$ sisaldab klassi meetodeid. Iga meetodi deklaratsioon on kujul $v_i$ \verb!::! $cx_i$ \verb!=>! $t_i$, kus $v_i$ on meetodi nimi, $t_i$ on meetodi tüüp ja $cx_i$ on tüübimuutujatele seatavate kitsenduste nimekiri.
          \item
            Ülemklasse spetsifitseerides tohib kasutada ainult tüübimuutujat $u$, mis on klassi deklareerides sisse toodud, ja mitte ühtegi teist tüüpi ega ka mitte mõnda uut tüübimuutujat. Toome kaks näidet klassidest, mis ei vasta antud nõudele ja on seega ebakorrektsed.

            \begin{verbatim}class Bug Int => Bug' t
class Bug u => Bug' t\end{verbatim}
          \item
            Pärilussuhetes ei tohi tekkida tsüklit. Klasside pärilussuhted moodustavad suunatud atsüklilise graafi.
          \item
            Haskell võimaldab mitmest pärilust.

            \begin{verbatim}class (A t, B t) => C t\end{verbatim}
          \item
            Tüüp $t_i$ peab sisaldama klassi päises sisse toodud tüübimuutujat $u$. Põhjuseks on see, et vastasel juhul ei ole võimalik klassi meetodi kutsel tuletada, millise tüübi jaoks mõeldud teostust kasutada. Toome näite, mis juhtuks, kui lubada meetodite tüüpe, mis ei vasta sellele kitsendusele.

            \begin{verbatim}class Bug t where
  bug :: Int
instance Bug Char where
  bug = 0
instance Bug Int where
  bug = 1\end{verbatim}

            Kui kasutatakse meetodit \verb!bug!, ei ole tüüpimisalgoritmil võimalik teada, kas tegu on meetodi \verb!bug! teostusega \verb!Char!, \verb!Int! või mõne muu tüübi jaoks. Ka eksplitsiitne tüübiannotatsioon ei aita, sest meetodi tüüp on sama kõigi teostuste korral. Seetõttu ei oleks sellist avaldist standartses Haskellis võimalik väärtustada.
          \item
            Kitsenduste nimekiri $cx_i$ tohib kitsendada ainult tüübimuutujaid, mis on sisse toodud tüübis $t_i$. Ei tohi kitsendada tüüpe, mis ei ole tüübimuutujad.

            \begin{verbatim}class Bug t where
  bug :: Bug' Int => t\end{verbatim}

            Ei tohi tuua kitsendustes sisse tüübimuutujaid, mida tüübis $t$ ei esine.

            \begin{verbatim}class Bug t where
  bug :: Bug' u => t\end{verbatim}

            Ei tohi kitsendada ka klassi päises deklareeritud tüübimuutujat.

            \begin{verbatim}class Bug t where
  bug :: Bug' t => t\end{verbatim}
          \item
            $cdecls$ võib sisaldada ka operaatorite assotsieerumissuuna ja prioriteedi deklaratsioone (ing. k. \textit{fixity declaration}) ning vaikedefinitsioone klassi meetodite jaoks.
        \end{itemize}

        Klasside esindajad on spetsifitseeritud järgnevalt~\cite{Has}.

        \begin{itemize}
          \item
            Kui meil on klass nimega $C$, siis tema esindaja on kujul \verb!instance! $cx'$ \verb!=>! $C$ $(T$ $u_1$ \ldots $u_k)$ \verb!where! \verb!{!$d$\verb!}!, kus $k\in\mathbb{N}_0$. Kitsenduste nimekiri $cx'$ võimaldab kitsendada tüübikonstruktorile $T$ argumentiks antud tüübimuutujaid $u_1$ \ldots $u_k$. Plokk $d$ sisaldab klassi meetodite definitsioone tüübi $T$ jaoks.
          \item
            Programmis ei tohi olla kahte esindajat, kus on sama klass $C$ ja tüüp $T$.
          \item
            Tüübikonstruktori $T$ argumendid $u_1$ \ldots $u_k$ peavad olema tüübimuutujad. Argumendiks ei tohi olla midagi muud, näiteks on keelatud selline esindaja:

            \begin{verbatim}instance Bug [Char]\end{verbatim}

            Nimetatud kitsendusega on seotud ka reegel, et klassi esindajaks ei tohi defineerida tüübisünonüümi. $T$ peab olema tüübikonstruktor. Näiteks ei tohi klassi esindaja olla \verb!String!, sest \verb!String! on sünonüüm tüübile \verb![Char]! ning programmis võib olla ka klassi esindaja tüübi \verb![t]! jaoks, mis juhul tekiks kahe esindaja vahel kattuvus.
          \item
            Tüübimuutujad $u_1$ \ldots $u_k$ peavad olema erinevad. Näiteks on keelatud selline esindaja:

            \begin{verbatim}instance Bug (t, t)\end{verbatim}
          \item
            Tüübi $T$ $u_1$ \ldots $u_k$ liik peab olema sama, mis klassi $C$ tüübimuutuja $u$ liik. Liikidest räägime täpsemalt jaotises~\ref{liiksort}. Seni aga toome ühe lihtsa näite liikide sobimatusest. Klass \verb!Functor! on mõeldud ühe argumendiga tüübikonstruktorite jaoks.

            \begin{verbatim}class Functor f where
  fmap :: (t -> u) -> f t -> f u\end{verbatim}

            Seda on näha meetodi \verb!fmap! signatuurist, kus tüübimuutuja \verb!f! võtab ühe argumendi. Seega peavad klassi \verb!Functor! esindajad olema tüübikonstruktorid, mis võtavad täpselt ühe argumendi (näiteks \verb!Maybe!, listi tüübikonstruktor, aga ka tüübikonstruktor \verb!Either t!). Järgmised kaks esindajat on keelatud, sest tüübid \verb!Int! ja \verb![t]! ei võta piisavalt argumente:

            \begin{verbatim}instance Functor Int
instance Functor [t]\end{verbatim}

            Järgmine esindaja on aga keelatud, sest \verb!Either!, millele ei ole argumendiks antud ühtegi tüübimuutujat, võtab mitte üks vaid kaks argumenti, seega liiga palju.

            \begin{verbatim}instance Functor Either\end{verbatim}

            Jaotises~\ref{liiksort} selgitame, kuidas liik võib olla ka palju keerulisem kui tüübikonstruktori argumentide arv, aga praeguseks piirdume ülalpool toodud lihtsate näitega.
          \item
            Tüüp $T$ $u_1$ \ldots $u_k$ kitsendustega $cx'$ peab olema ka kõigi $C$ ülemklasside esindaja. Näiteks kuna klass \verb!Functor! on klassi \verb!Applicative! ülemklass, ei tohi kirjutada klassi \verb!Applicative! esindajat ilma vastava \verb!Functor! esindajata. Lisaks tähendab see reegel, et ülemklassi esindajale ei tohi seada rangemaid kitsendusi kui alamklassi (päriva klassi) esindajale. Näiteks on keelatud järgmine kood:

            \begin{verbatim}class Bug t => Bug' t
instance Ord t => Bug [t]
instance Bug' [t]\end{verbatim}

            Selline kood ei ole lubatud, sest klass \verb!Bug! on klassi \verb!Bug'! ülemklass ning alati, kui tüübi peal kehtib kitsendus \verb!Bug'!, peaks järelikult kehtima ka \verb!Bug!.
          \item
            Kitsenduste nimekiri $cx'$ tohib kitsendada ainult tüübimuutujaid $u_1$ \ldots $u_k$. Keelatud on kitsendada tüüpe, mis ei ole tüübimuutujad.

            \begin{verbatim}instance Bug Int => Bug' [t]\end{verbatim}

            Samuti on keelatud kitsendustes uusi tüübimuutujaid sisse tuua.

            \begin{verbatim}instance Bug u => Bug' [t]\end{verbatim}
          \item
            Plokk $d$ tohib sisaldada ainult klassi $C$ meetodite definitsioone ning muud definitsioonid on keelatud. Haskell lubab osade meetodite definitsioonid kirjutamata jätta. Juhul, kui defineerimata meetodi jaoks on olemas vaiketeostus, kasutatakse seda. Kui ei ole, on meetodi väärtus antud tüübi jaoks \verb!undefined!. 
          \item
            Ploki $d$ definitsioonid peavad vastama klassi deklaratsioonis toodud tüübisignatuuridele. Sealhulgas tähendab see, et meetodi $v_i$ definitsioon tüübi $T$ $u_1$ \ldots $u_k$ jaoks ei tohi nõuda rangemaid kitsendusi $t_i$ kui on määratud klassi deklaratsioonis tüübisignatuuris, kitsenduste nimekirjas $cx_i$. Samuti ei tohi definitsioon nõuda rangemaid kitsendusi tüübimuutujatele $u_1$ \ldots $u_k$ kui on sisse toodud kitsenduste nimekirjas $cx'$ esindaja deklaratsiooni päises. Toome kaks näidet esindajatest, mis ei läbi tüübikontrolli, kuna definitsiooni sisust järelduksid liiga ranged kitsendused.

            \begin{verbatim}class Bug t where
  bug :: t -> f t
instance Bug [t] where
  bug = pure\end{verbatim}

            Loome klassi \verb!Bug!, millel on meetod \verb!bug!. Meetodil \verb!bug! on kitsendamata tüübimuutuja \verb!f!. Esindaja \verb!Bug [t]! ei läbi tüübikontrolli, sest funktsioon \verb!pure! eeldab klassi \verb!Applicative!, aga klassi deklaratsioonis ei ole tüübimuutuja \verb!f! kitsendamist ette nähtud.

            \begin{verbatim}class Bug t where
  bug :: t -> t
instance Bug [t] where
  bug = sort\end{verbatim}

            Ka see näide ei läbi tüübikontrolli, sest meetodi teostus eeldab mitte-ettenähtud kitsendusi esindaja deklaratsiooni päises sisse toodud tüübimuutujale. Funktsioon \verb!sort! eeldab, et listi elemendid on võrreldavad, aga samas ei ole seda eeldust sisse toodud. Viga saab parandada, muutes eksplitsiitseks eelduse, et tüübimuutuja \verb!t! kuulub klassi \verb!Ord!.

            \begin{verbatim}instance Ord t => Bug [t] where
  bug = sort\end{verbatim}
          \item
            Ploki $d$ definitsioonidele on keelatud kirjutada tüübisignatuure, sel lihtsal põhjusel, et klassi meetodite tüübisignatuurid on toodud juba klassi deklaratsioonis ning esindajat defineerides ei ole need seega vajalikud.
        \end{itemize}
      \subsubsection{Tüübiklassidega seotud laiendused}
        Haskellil on ka palju laiendusi, mis võimaldavad tüübiklasside vallas paindlikkust lisada. Loetleme siinkohal mõned tüübiklassidega seotud laiendused~\cite{Gla}. Me ei hakka detailselt käsitlema nimetatud laienduste kasutusvõimalusi, vaid lihtsalt mainime lühidalt, milliseid piiranguid need eemaldavad.

        \begin{itemize}
          \item
            \verb!ConstrainedClassMethods! võimaldab klassi meetodite tüübisignatuurides kitsendada ka klassi päises sisse toodud tüübimuutujat.

            \begin{verbatim}class C t where
  f :: Ord t => t -> t -> t\end{verbatim}
          \item
            \verb!DefaultSignatures! võimaldab kirjutada erineva signatuuri klassi meetodile ja vaiketeostusele. See on kasulik näiteks juhuks, kui tahta kirjutada vaiketeostus, mis töötab ainult teatud kitsendatud juhtudel.
          \item
            \verb!FlexibleContexts! võtab ära piirangu, et klassi kontekst $cx$ on lihtsalt ülemklasside nimekiri. See võimaldab kitsenduste nimekirjas kasutada ka keerulisemaid avaldisi, mis ei pea koosnema tingimata ainult tüübimuutujatest vaid võivad sisaldada ka muid tüüpe.
          \item
            \verb!FlexibleInstances! võimaldab luua esindajaid, kus tüüp ei koosne ainult konstruktorist ja tüübimuutujatest. Näiteks saab sellisel juhul klassi esindajaks defineerida tüübi \verb![Char]!.

            \begin{verbatim}instance C [Char]\end{verbatim}
          \item
            \verb!IncoherentInstances! ja \verb!OverlappingInstances! on kaks aegunud laiendust, mis lubavad kattuvaid esindajaid.
          \item
            Standartses Haskellis on tüübiklassid üheparameetrilised. \verb!MultiParamTypeClasses! lubab suvalise arvu parameetritega -- sealhulgas ka ilma parameetrita -- tüübiklasse.

            \begin{verbatim}
class C
class B t u\end{verbatim}
          \item
            Laiendus \verb!FunctionalDependencies! on mõeldud loomaks mitmeparameetrilisi tüübiklasse, kus osade tüübiparameetrite väärtused on üheselt määratud teiste tüübiparameetrite poolt. Näiteks oletame, et kirjutame algebrateeki ja soovime defineerida üldistatud korrutamisfunktsiooni, mis võib korrutada erinevat tüüpi argumente, kusjuures tulemuse tüüp ei pea tingimata kummagi argumendi omaga ühtima. Antud näites on korrutise tulemuse tüüp \verb!v! üheselt määratud argumentide tüüpide \verb!t! ja \verb!u! poolt.

            \begin{verbatim}class Mult t u v | t u -> v where
  mult :: t -> u -> v
instance Num t => Mult (Array m t) (Array n t) (Matrix m n t)
instance Num t => Mult (Array n t) (Matrix n m t) (Array m t)
instance Num t => Mult (Matrix m n t) (Array n t) (Array m t)
instance Num t => Mult (Matrix l m t) (Matrix m n t) (Matrix l n t)\end{verbatim}

            Kuna laiendus \verb!FunctionalDependencies! eeldab mitmeparameetrilisi tüübiklasse, võetakse sellega koos automaatselt kasutusse ka \verb!MultiParamTypeClasses!.
          \item
            \verb!InstanceSigs! võimaldab tüübisignatuure esindaja sees meetodite teostuste juures. Üks võimalik kasutus on näiteks täiendav dokumentatsioon esindajate sees.
          \item
            \verb!NullaryTypeClasses! on aegunud laiendus, mis võimaldab parameetriteta tüübiklasse. Selle asemel saab kasutada üldisemat laiendust \verb!MultiParamTypeClasses!.
          \item
            \verb!TypeSynonymInstances! võimaldab tüübisünonüüme, näiteks \verb!String!, klasside esindajateks defineerida.
          \item
            \verb!UndecidableInstances! ja \verb!UndecidableSuperClasses! lubavad vastavalt esindajaid ja klasse, mille olemasolu võib resulteeruda mittetermineeruvas tüübikontrollis.
        \end{itemize}
    \subsection{Tüübiklassid Awfulis}\label{tyybiklassidawfulis}
      Ka käesoleva töö teemaks olev keel Awful võimaldab \textit{ad hoc} polümorfismi tüübiklasside kaudu. Awful on tüübiklasside ja esindajate osas erinev Haskell 2010 standardist järgmistes aspektides:

      \begin{itemize}
        \item
          Lubatud on ainult ühene pärilus. Mitmene pärilus on plaanis lisada edasise töö käigus.
        \item
          Klassi meetodid ei pea sisaldama klassi päises sisse toodud tüübimuutujat. Toome näite olukorrast, kus selline meetod on praktikas kasulik: täisarvuline jagamine, mille puhul on garanteeritud, et jagaja ei ole null, sest jagaja on tüübitaseme naturaalarv. (Tüübitaseme naturaalarvudest räägime peatükis~\ref{edutamine}.) Haskellis on selline meetod keelatud.

          \begin{verbatim}class Nonzero (n :: Nat) where
  div' :: Integer -> Integer\end{verbatim}

          Awfulis on analoogne meetod lubatud.

          \begin{verbatim}Class Nonzero{N : !Nat}(Div' : Int -> Int)\end{verbatim}

          Erinevalt Haskellist, kus tüübiargumentide eksplitsiitne edastamine ei ole standardi osa ja vajab keelelaiendust, on Awfuli puhul algusest peale arvestatud tüübiargumentide eksplitsiitse edastamise vajadusega. Seega ei ole Awfulis piirangut, et meetodi teostust peaks saama tema tüübist tuletada. Tüübiargumentide eksplitsiitsest edastamisest räägime täpsemalt alamjaotises~\ref{typeargs}.
        \item
          Haskell võimaldab osade tüübiklasside esindajaid (näiteks \verb!Eq!, \verb!Ord! ja \verb!Show!) automaatselt tuletada. Awfulis selline võimalus puudub.
        \item
          Ei ole võimalust lisada vaikedefinitsioone klassi meetodite jaoks. Kuna tegu on keele väljendusrikkuse seisukohast mittekriitilise võimalusega, ei ole seda hetkel kavas. Awfulis sisaldab klass ainult neid meetodeid, mis on minimaalselt vajalikud, ning kõik ülejäänud funktsioonid, mis saab nende kaudu defineerida, tuleb kirjutada väljaspool klassi. Selle tõttu ei luba Awful, erinevalt Haskellist, esindaja defineerimisel ühtegi meetodit kirjutamata jätta. Kuna puuduvad vaikedefinitsioonid, on defineerimata meetod alati viga.
        \item
          Awful nõuab, et esindajat teostades oleks meetodid samas järjekorras, mis klassi deklaratsiooni sees. Tegu oli teostuse lihtsusest lähtuva otsusega.
      \end{itemize}
  \peatykk{Tüübitaseme andmed ja edutamine}\label{edutamine}
    Selles peatükis refereerime, mis on edutamine ning kuidas see muudab tüübisüsteemi väljendusrikkamaks ja aitab kirjutada tüübiturvalisemat koodi. Kuna käesoleva töö autori loodud keelt tutvustatakse alles peatükkides~\ref{syntaks} ja~\ref{manual}, ning kuna Haskell on esimene keel, mis võimaldab edutamist~\cite{Giv}, on antud peatükis edutamise põhimõtete selgitamiseks kasutatud Haskelli süntaksit.

    Sageli on tüübiturvalisema koodi kirjutamiseks kasulik, kui saab tüüpide tasemel väärtusi kasutada. Näiteks võimaldavad tüübitaseme naturaalarvud luua vektoreid, mille pikkus, erinevalt listide omast, on juba tüübikontrolli ajal teada. Vektorite pikkusega seotud vead tulevad sellisel juhul ilmsiks juba tüübikontrolli käigus, enne väärtustamist või kompileerimist.

    See võimaldab kirjutada näiteks vektorite liitmise või vektori viimase elemendi leidmise funktsioone tüübiturvaliselt. Juhul, kui kirjutada neid funktsioone listide abil, ei ole kuidagi tagatud, et programmeerija ei kutsu vektorite liitmise funktsiooni välja kahe erineva pikkusega listi peal või ei kutsu viimase elemendi leidmise funktsiooni tühja listi peal. Staatilise pikkusega vektorite puhul on sellised vead tänu tüübisüsteemile välistatud.

    Lisaks kannavad tüübid kasulikku teavet funktsioonide sisendite ja väljundite kohta, ning mida väljendusrikkam tüübisüsteem on seda detailsemalt saavad funktsioonide tüübid funktsioonide sisu kirjeldada. Näiteks juhul kui keeles on võimalik kasutada tüübitaseme naturaalarve, saab vektorite liitmise funktsiooni tüüpi vaadates kohe teada, et kaks vektorit peavad olema sama pikad. Vaadates vektori viimase elemendi leidmise funktsiooni tüüpi, on kohe aru saada, et vektor ei tohi olla pikkusega null, kuna esimene tüübiargument on \verb!Next n!.

    \begin{verbatim}add_array :: Num t => Array n t -> Array n t -> Array n t
last_elem :: Array (Next n) t => t\end{verbatim}

    Tüübitaseme andmed parandavad tüübiturvalisust, vähendavad korduva koodi hulka ning lisaks aitavad kaasa sellele, et tüübisüsteem oleks väljendusrikkam ja tüübid dokumenteeriks paremini funktsioonide sisu.
    \subsection{Üldistatud algebralised andmetüübid}
      Käesoleva peatüki näidetes kasutame üldistatud algebralisi andmetüüpe. Seega enne tüübitaseme andmete juurde liikumist selgitame lühidalt üldistatud algebralisi andmetüüpe ja toome mõned näited.

      Tavalise algebralise andmetüübi puhul järgneb tüübi nimele tüübimuutujate loetelu ja seejärel konstruktorid.

      \begin{verbatim}data Maybe t = Nothing | Just t\end{verbatim}

      Konstruktorid ei võimalda resulteeruvat tüüpi kuidagi kitsendada. Kui tüübil $D$, millel on $n$ tüübiargumenti, on konstruktor $C$ argumentidega tüüpi $T_1$ \ldots $T_m$, siis $C$ tüüp on $T_1$ \verb!->! \ldots \verb!->! $T_m$ \verb!->! $D$ $t_1$ \ldots $t_n$. Tüübid $T_1$ \ldots $T_m$ võivad sisaldada ainult tüübimuutujaid $t_1$ \ldots $t_n$ ning tüübimuutujad $t_1$ \ldots $t_n$ peavad kõik olema erinevad. Näiteks \verb!Maybe! puhul on andmekonstruktori \verb!Nothing! tüüp \verb!Maybe t! ja andmekonstruktori \verb!Just! tüüp \verb!t -> Maybe t!. Kummagi andmekonstruktori tulemuse tüüp on \verb!Maybe t!, mitte näiteks \verb!Maybe Int! või \verb!Maybe [t]!.

      Üldistatud algebralise andmetüüpide puhul~\cite{Fir} see kitsendus enam ei kehti. Näitame alustuseks, kuidas tüüpi \verb!Maybe! üldistatud algebraliste andmetüüpide süntaksiga kirja panna:

      \begin{verbatim}data Maybe :: * -> * where
  Nothing :: Maybe t
  Just :: t -> Maybe t\end{verbatim}

      Esimene rida näitab, et \verb!Maybe! on tüübikonstruktor, mis võtab ühe argumendi. Seejärel kirjutame andmekonstruktorid. Erinevalt tavalisest algebralisest andmetüübist on üldistatud algebralise andmetüübi puhul vajalik märkida ka tulemuse tüüp, antud juhul \verb!Maybe t!. Andmekonstruktori tulemuse tüübis ei pea aga tüübikonstruktor olema rakendatud ainult hulgale erinevatele tüübimuutujatele -- ta võib olla rakendatud ka teistele tüüpidele, näiteks \verb!Int! või \verb![t]!, ning antud tüüpides esinevad tüübimuutujad ei pea omavahel erinema.

      \begin{verbatim}data Example :: * -> * -> * where
  Constr_0 :: Example Int [t]
  Constr_1 :: Example t t\end{verbatim}

      Üldistatud algebraliste andmetüüpide ja nende rakenduste põhjalik käsitlus jääb väljapoole antud töö skoopi. Seetõttu piirdume siinkohal ainult selle lühikese selgitusega ning jätkame tüübitaseme andmete ja nende võimalike kasutusjuhtude tutvustamisega.
    \subsection{Tüübitaseme andmed}\label{tyybitasemeandmed}
      Mõnedes keeltes, näiteks Idris~\cite{The_Idr}, saab tüübitaseme andmete saavutamiseks kasutada sõltuvaid tüüpe. Sõltuvatest tüüpidest anname lühikese ülevaate jaotises~\ref{soltuvad}. Keeles, kus sõltuvaid tüüpe ei ole, on tüübitaseme andmeid võimalik kirjutada algebraliste andmetüüpide abil~\cite{Giv}. Tüübitaseme naturaalarvud näeksid Haskelli algebralisi andmetüüpe kasutades välja sellised:

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Sarnasel viisil saab teostada ka näiteks tüübitaseme liste:

      \begin{verbatim}data Empty_List
data Construct_List t l\end{verbatim}

      Tegu on tühjade tüüpidega, millel puuduvad andmekonstruktorid ja mis on mõeldud spetsiaalselt tüübitaseme andmete rolli täitmiseks.

      Toome mõned lihtsad näited andmetüüpidest, mille konstrueerimiseks on vaja tüübitaseme andmeid. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada. Kirjutame kaks konstruktorit: üks tühja vektori jaoks, ja teine vektori jaoks pikkusega \verb!n + 1!, mis võtab argumendiks pea ja \verb!n!-elemendilise saba.

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua suvalise arvu muutujatega Boole'i funktsiooni tüüp. Null muutuja Boole'i funktsioon on üks konstant. \verb!n + 1! muutuja Boole'i funktsiooni saab esitada kahe \verb!n! muutuja Boole'i funktsiooni abil (jääkfunktsioonid, mille saame, asendades esimese muutuja vastavalt konstandiga \verb!False! või \verb!True!).

      \begin{verbatim}data Fun :: * -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid, mis sarnanevad struktuuri poolest üleeelmises näites toodud vektoritele, selle vahega, et nad võivad sisaldada erinevat tüüpi andmeid.

      \begin{verbatim}data Tuple :: * -> * where
  Empty_Tuple :: Tuple Empty_List
  Construct_Tuple :: t -> Tuple l -> Tuple (Construct_List t l)\end{verbatim}

      Kui saame luua tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: * -> * -> * where
  Empty_Array' :: t -> Array' Empty_List t
  Construct_Array' ::
    Array n (Array' l t) -> Array' (Construct_List n l) t\end{verbatim}

      Tüübitaseme andmed on kasulikud selleks, et saaks kirjutada tüübiturvalisemaid funktsioone. Näiteks tahame kirjutada vektorite liitmise funktsiooni. Kui kasutada vektorite esitamiseks liste, siis on tarvis arvestada ohuga, et programmeerija annab funktsiooni sisendiks erineva pikkusega listid. Erineva pikkusega listid resulteeruvad defineerimata käitumises või erindis programmi töö käigus ning tüüpimise ajal ei ole seda võimalik ennetavalt tuvastada.

      Tüübitaseme andmete olemasolul saab vektorite liitmise funktsiooni kirjutada eelpool näiteks toodud \verb!Array! tüübi peal. See tagab, et iga vektorite liitmise funktsiooni kutse puhul kontrollitakse juba tüüpimise ajal, et mõlemad argumendid oleks sama pikad.
    \subsection{Tüübid, liigid ja sordid}\label{liiksort}
      Eelmises jaotises kirjeldatud viisil teostatud tüübitaseme andmetel on oluline puudus. Tüübisüsteem ei ole piisavalt väljendusrikas kirjeldamaks programmeerija tegelikke kavatsusi. Ei ole võimalust seada piirangut, et kohas kus võib esineda näiteks tüüp \verb!Char! või \verb!Int!, ei tohi esineda naturaalarvuline tüüp, ja vastupidi -- ehk tüübid ei ole piisavalt tugevalt tüübitud~\cite{Giv}. Tüübikontrollist lähevad läbi koodinäited, mis ei ole programmeerija tegelike kavatsustega kooskõlas, näiteks:

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next t) n\end{verbatim}

      Siin on konstruktori \verb!Construct_Array! tulemuse tüübis vahetusse läinud tüübimuutujad \verb!n! ja \verb!t!. Antud koodinäide ei tohiks tegelikult tüübikontrolli läbida, sest need tüübimuutujad on täiesti erineva otstarbega: \verb!n! kirjeldab vektori pikkust ja \verb!t! vektori elementide sisu. Vältimaks sedalaadi vigu, oleks vaja tüübisüsteemi, mis on piisavalt võimas kirjeldamaks, et tüübikonstruktori \verb!Array! esimene argument peab olema naturaalarv ja teine tavaline tüüp, ja et tüübikonstruktorit \verb!Next! saab rakendada ainult naturaalarvule.

      Selleks, et tüübitaseme naturaalarvusid, tüübitaseme liste ja teisi tüübitaseme andmeid saaks kasutada turvalisemalt, on vaja võimsamat liigisüsteemi. Liigid on tüüpide jaoks sama, mis tüübid väärtuste jaoks -- tegu on tüüpide tüüpidega. Ka liikidel võivad omakorda olla tüübid ja neid nimetatakse sortideks~\cite{Typ}.

      Tuntud liigikonstruktorid Haskellis on näiteks liik \verb!*! ja liigikonstruktor \verb!->!, mille kaudu konstrueeritakse tüübikonstruktorite liike. Need tagavad, et tüübikonstruktoreid rakendataks õigele arvule õigetele argumentidele, näiteks et programmeerija ei üritaks kirjutada tüüpi \verb!Int List!.

      Võimsam liigisüsteem, mis sisaldaks lisaks eelmainitud liikidele ka kõigi tüübitaseme andmete liike (näiteks naturaalarvude liiki ja listide liiki), aitaks vältida tüüpide ja tüübimuutujate ebasobivat kasutust, mida nägime ülalpool toodud näites.

      See, et jaotises~\ref{tyybitasemeandmed} kirjeldatud viis tüübitaseme andmeid luua ei ole piisavalt tüübiturvaline, ei ole selle ainus nõrk külg. Lisaks eelmainitud peamisele puudusele on oluline miinus ka see, et programmeerija peab tüüpide tasemel duplitseerima andmeid, mis on väärtuste tasemel tegelikult juba olemas. Näiteks on tüübitaseme naturaalarvud samasuguse struktuuriga mis väärtuste taseme naturaalarvud ja tüübitaseme naturaalarvude eraldi kirjutamine on korduv kood.

      Edutamine lahendab mõlemad probleemid, muutes tüübi- ja liigisüsteemi võimsamaks ning tagades, et programmeerija ei peaks ise käsitsi tüübitaseme andmeid kirjutama. Järgmistes jaotistes räägimegi sellest, kuidas edutamine töötab, kuidas see muudab tüübisüsteemi ja millised andmetüübid on edutatavad.
    \subsection{Edutamine}
      Edutamine tõstab sobivad andmetüübid automaatselt "`üks tase ülespoole"'. Andmetüübi edutamisel tehakse tüübikonstruktorist liigikonstruktor, kusjuures tüübiparameetritest saavad liigiparameetrid. Andmekonstruktoritest saavad vastava liigi tüübikonstruktorid, kusjuures argumentide tüüpidest saavad tüübikonstruktorite argumentide liigid~\cite{Giv}.
      \subsubsection{Edutamise näiteid}
        Võtame esimeseks näiteks lihtsa andmetüübi, kus puudub polümorfism: naturaalarvud.

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        Ilma edutamiseta saab siit tüübi \verb!Nat :: *! ning kaks andmekonstruktorit: \verb!Zr! tüüpi \verb!Nat! ja \verb!Next! tüüpi \verb!Nat -> Nat!. Edutamise olemasolul saab lisaks ka liigi \verb!Nat! ning kaks tüübikonstruktorit: \verb!Zr! liiki \verb!Nat! ja \verb!Next! liiki \verb!Nat -> Nat!.

        Vaatleme keerulisemat näidet: liste.

        \begin{verbatim}data List (t :: *) = Empty_List | Construct_List t (List t)\end{verbatim}

        Ilma edutamiseta saab sellest andmetüübist tüübikonstruktori \verb!List :: * -> *! ning kaks andmekonstruktorit: \verb!Empty_List! tüüpi \verb!List (t :: *)! ja \verb!Construct_List! tüüpi \verb!(t :: *) -> List t -> List t!. Edutamise olemasolul saab sellest andmetüübist lisaks ka ühe argumendiga liigikonstruktori \verb!List! ning kaks tüübikonstruktorit: \verb!Empty_List! liiki \verb!List k! ja \verb!Construct_List! liiki \verb!k -> List k -> List k!.

        Listide puhul tuleb mängu polümorfism. Parametriseeritud tüüp muutub parametriseeritud liigiks. Tüübipolümorfsetest andmekonstruktoritest saavad liigipolümorfsed tüübikonstruktorid.

        Standartne Haskell edutamist ei sisalda ning edutamise jaoks on vaja kasutada keele laiendusi. Vajalikud laiendused on \verb!DataKinds! (edutamine) ja \verb!KindSignatures! (liigisignatuurid) ning, kuna paljud edutamise rakendused nõuavad üldistatud algebralisi andmetüüpe, ka \verb!GADTs!. Liigipolümorfismi jaoks on lisaks vajalik laiendus \verb!PolyKinds!.
      \subsubsection{Andmetüübid, mida saab edutada}\label{kitsendused}
        Edutamisele on mõistlik seada teatud piirangud ning edutada ainult osasid andmetüüpe, mitte kõiki. Piirangud on seotud sooviga kasutada edutamise võimalusi (näiteks tüübitaseme naturaalarvusid ja liste) ilma muutmata tüübisüsteemi keerulisemaks kui hädapärast vajalik. Loetleme siinkohal piirangud, mida on kasutatud Haskellis~\cite{Giv}.

        \begin{itemize}
          \item
            Ei edutata üldistatud algebraliseid andmetüüpe, kuna see muudaks liigisüsteemi keerulisemaks tuues sisse liikide võrdsuskitsendused (ing. k. \textit{equality constraints}).
          \item
            Ei edutata primitiive, näiteks tähti ja täisarvusid. Primitiivide edutamisega ei kaasne tegelikult põhimõttelisi raskusi, küll aga võib neile praktiliste rakenduste leidmine nõuda teisi keele täiendusi, mis ei ole sama lihtsad. Haskellis on primitiivide edutamata jätmise põhjuseks see, et keele laienduse autorite arvates ei ole primitiivide edutamine kasulik, kuni ei ole võimalik edutada tüüpie tasemele ka tehteid primitiividega.
          \item
            Ei edutata andmetüüpe, millel on tüübiparameetreid muud liiki kui liik \verb!*!. Juhul kui edutada ainult sellele kitsendusele vastavaid andmetüüpe, on sortide süsteem äärmiselt lihtne. Kõik liigimuutujad on ühte sorti. See tähendab, et liigipolümorfismi korral ei pea liigimuutujate sorte märkima. Liigikonstruktori sort on lihtsalt naturaalarv, mis näitab, mitut argumenti liigikonstruktor vajab.

            Juhul, kui soovida edutada andmetüüpe, mis sisaldaks tüübiparameetrites mitte ainult liiki \verb!*! vaid ka liigikonstruktorit \verb!->!, ei ole sellele põhimõttelisi takistusi, aga selline täiendus nõuaks keerulisemat sortide süsteemi. Liigimuutujad võiksid sellisel juhul olla erinevat sorti. Seega oleks vaja liigipolümorfismi korral liigimuutujate sorte märkida. Edutamise teostamine muutuks keerulisemaks, samas kui vajadus sellise võimsusega liigisüsteemi järele on küsitav.

            Kui tahta minna veel kaugemale ja edutada andmetüüpe, mis on parametriseeritud üle omakorda edutamise teel saadud liikide, oleks see veel keerulisem. Sellisel juhul oleks vaja \textit{topeltedutamist} -- tüübid, mis ei ole parametriseeritud üle edutamise teel saadud liikide, tuleks edutada kaks taset ülespoole -- või peaks tüübid ja liigid sõltuvad olema.
          \item
            Ei edutata liigipolümorfseid tüüpe, kuna sellisel juhul oleks vajalik sordipolümorfism.
          \item
            Loomulikult ei tohi edutada andmekonstruktoreid, mis võtavad mitte-edutatavat tüüpi argumente. Andmekonstruktorite edutamisel muutub tüüp liigiks, aga kuna mitte-edutatavat tüüpi liigiks muuta ei saa, ei ole see võimalik. Tüübi mitte-edutatavus levib kõigile andmekonstruktoritele, mis teda kasutavad.
        \end{itemize}

        Sarnastest piirangutest on lähtutud ka Awfuli loomisel, teatud muudatustega.

        \begin{itemize}
          \item
            Keeles ei ole üldistatud algebralisi andmetüüpe, aga on hargnevad andmetüübid, mida kirjeldame alamjaotises~\ref{hargnevad}. Reegli asemel, et ei edutata üldistatud algebralisi andmetüüpe, kehtib Awfuli tüübisüsteemis reegel, et ei edutata hargnevaid andmetüüpe.
          \item
            Isegi kui jätta kõrvale asjaolu, et tüübitaseme tehteid ei ole Awfulisse plaanis lisada, siis võimalused andmetüüpide konstrueerimiseks on palju piiravamad kui üldistatud algebralised andmetüübid. Selle tõttu ei näe käesoleva töö autor hetkel Awfulis primitiivide edutamisele mõttekaid rakendusi. Tähtede (\verb!Char!) ja täisarvude (\verb!Int!) edutamine on siiski teostatud, juhuks kui andmetüüpide konstrueerimise viisid tulevikus võimsamaks muutuvad.

            Jäägiklassiringide primitiivi (\verb!Modular!) ei edutata, sest tegu on tüübiga, mis on parametriseeritud üle naturaalarvude ja seega ei vasta kitsendusele, et kõik tüübiargumendid peavad olema liiki \verb!Star! (Haskelli \verb!*!).
          \item
            Lihtsuse huvides edutab Awful ainult neid andmetüüpe, mille kõik konstruktorid on edutatavad. Andmetüübi edutamist koos ainult osade konstruktorite edutamisega ei tehta.
          \item
            Oleks võimalik edutada funktsiooni tüüpi sisaldavaid andmekonstruktoreid, näiteks

            \begin{verbatim}data Fun t u = Fun (t -> u)\end{verbatim}

            Siit oleks võimalik edutamise teel saada kahe argumendiga liigikonstruktor \verb!Fun! ning liigipolümorfne tüübikonstruktor \verb!Fun! liiki \verb!Fun(t -> u) -> Fun t u!, kus sümbol \verb!->! tähistab tüübikonstruktori liiki. Selline edutamine võimaldaks edutada andmekonstruktoreid, mis võtavad argumendiks funktsioone, ja neist tuleks tüübikonstruktorid, mis võtavad argumendiks tüübikonstruktoreid.

            Awfulis, erinevalt Haskellist, sellist tüüpi hetkel ei edutata, sest selleks ei olnud otsest vajadust, aga antud täiendusele ei ole põhimõttelisi takistusi ja ei ole välistatud tulevikus selle võimaluse lisamine.
        \end{itemize}
      \subsubsection{Tüübisüsteemi täiendused edutamise lisamisel}
        Selleks, et saaks toimuda edutamine (alamjaotises~\ref{kitsendused} kirjeldatud kitsendustega), on tarvis tüübisüsteemi täiendada. Selles alamjaotises kirjeldame lühidalt, mis muudatused olid Awfulis edutamise teostamiseks vajalikud.

        \begin{itemize}
          \item
            Kui edutame tüübipolümorfseid andmekonstruktoreid, näiteks listide konstruktorid, muutub tüübipolümorfism liigipolümorfismiks. Seega tekib vajadus liigipolümorfsete tüüpide järele.

            Täpselt nagu tüübipolümorfism ilma kohustusliku tüübiargumentide märkimiseta toob kaasa vajaduse tüübituletuse järele, toob liigipolümorfism ilma kohustusliku liigiargumentide märkimiseta kaasa vajaduse liigituletuse järele. Awful nõuab teostuse lihtsuse huvides liigiargumentide märkimist kõigi liigipolümorfsete tüüpide kasutamisel, et vätida liigituletust. Kuna liigipolümorfsed tüübid ei ole nii laias kasutuses kui tüübipolümorfsed andmekonstruktorid ja funktsioonid, ei muuda liigituletuse puudumine keelt nii kohmakaks kui tüübituletuse puudumine.
          \item
            Liigisüsteem peab olema piisavalt võimas ja paindlik, et võimaldada tüüpidest uusi liike teha. Enne edutamise lisamist oli Awfulis ainult äärmiselt primitiivne liigisüsteem, mis sisaldas liiki \verb!Star! (analoogne Haskelli liigiga \verb!*!) ja liiki \verb!Arrow! (tüübikonstruktorite liik, analoogne Haskelli liigiga \verb!->!). Interpretaatori sees olid liigid esitatud järgneva andmetüübi abil:

            \begin{verbatim}data Kind = Star_kind | Arrow_kind Kind Kind\end{verbatim}

            Selgelt ei ole sellisele fikseeritud liigisüsteemile võimalik edutamist üles ehitada ja on tarvis olulisi muudatusi. Awfuli interpretaator kasutab liigi esitamiseks andmetüüpi

            \begin{verbatim}data Kind = Name_kind Name | Application_kind Kind Kind\end{verbatim}

            Liike \verb!Star! ja \verb!Arrow! käsitletakse muudatuse järel lihtsalt kui nimede erijuhtumeid.
          \item
            Enne edutamise teostamist ei olnud Awfulis sorte. Sortide järele ei olnud vajadust, sest oli ainult kaks fikseeritud liigikonstruktorit ning programmeerija kirjutatud liigi korrektsust oli võimalik kontrollida otse parseri tasandil.

            Liigisüsteem, mida saab lõpmatult uute liikidega laiendada, nõuab sorte. Liike ei saa üksteisele suvaliselt rakendada. Näiteks \verb!Star Arrow! ei ole korrektne liik ega isegi liigikonstruktor, sest \verb!Star! ei võta argumente ja seega ei tohi teda millelegi rakendada. Õnneks on edutamisele seatud piisavalt ranged piirangud ja sortide süsteem ei ole seega keeruline: liigikonstruktori sordiks on naturaalarv, mis näitab, mitut argumenti antud liigikonstruktor nõuab.

            \begin{verbatim}data Sort = Star_sort | Arrow_sort Sort\end{verbatim}
          \item
            Primitiivide edutamisel on vaja keelde sisse ehitada vastavad liigid ja tüübid. Tegu on võrdlemisi triviaalse täiendusega.
        \end{itemize}
      \subsubsection{Edutamise kasutusjuhtusid}
        Selles alamjaotises külastame uuesti näiteid, mida tõime alamjaotises~\ref{tyybitasemeandmed} rääkides tüübitaseme andmete rakendustest. Selgitame, kuidas edutamine muudab need näited kasutajasõbralikumaks ja tüübiturvalisemaks.

        Esiteks ei ole edutamise olemasolu korral enam tarvis käsitsi eksplitsiitselt tüübitaseme andmeid kirjeldada. Näiteks kirjutame naturaalarvude andmetüübi

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        ja sellest tuletatakse automaatselt liik \verb!Nat! ning vastava liigi tüübikonstruktorid \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!. Mis kõige tähtsam, tänu sellele, et nüüd on olemas liik \verb!Nat!, on tüübitaseme naturaalarvud teostatud tüübiturvaliselt: tüübikonstruktori \verb!Next! puhul on teada, et tema argumendiks kõlbab ainult naturaalarv ja mitte näiteks täht või list. Viga, mille tõime näiteks jaotises~\ref{liiksort}, ja ka teised analoogsed vead, saavad tüübikontrollija poolt tuvastatud.

        Kirjutame uuesti alamjaotises~\ref{tyybitasemeandmed} toodud andmetüübid, kasutades nüüd mitte algebraliste andmetüüpide kaudu käsitsi kirjutatud tüübitaseme andmeid, vaid edutamise teel saadud liike ja tüüpe.

        Vektorite ja Boole'i funktsioonide puhul on esimese tüübiargumendi liik \verb!Nat!. Seda on nüüd näha ka tüübikonstruktorite liigisignatuuridest.

        \begin{verbatim}data Array :: Nat -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t
data Fun :: Nat -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

        Üldistatud ennikute tüübikonstruktori liigisignatuur kajastab nüüd seda, et esimene tüübiargument on tüüpide list.

        \begin{verbatim}data Tuple :: [*] -> * where
  Empty_Tuple :: Tuple []
  Construct_Tuple :: t -> Tuple l -> Tuple (t : l)\end{verbatim}

        Mitmemõõtmeliste massiivide korral on tüübikonstruktori esimene argument tüübitaseme naturaalarvude list.

        \begin{verbatim}data Array' :: [Nat] -> * -> * where
  Empty_Array' :: t -> Array' [] t
  Construct_Array' :: Array n (Array' l t) -> Array' (n : l) t\end{verbatim}

        Siinkohal võib tekkida küsimus, kas edutamisest on praktilist kasu keeles, kus ei ole üldistatud algebralisi andmetüüpe. Need lihtsad ja kasulikud rakendused, mida oleme selles alamjaotises vaadelnud, ei ole teostatavad ainult algebraliste andmetüüpide abil, kuna andmekonstruktorite resultaattüübid peavad erinema. Näiteks vektorite puhul annab üks andmekonstruktor tulemuseks vektori, mille pikkus on \verb!Zr!, aga teine annab tulemuseks vektori pikkusega \verb!Next n!.

        Õnneks on paljud edutatud andmetüüpide rakendused siiski võimalikud ilma keelde üldistatud algebralisi andmetüüpe lisamata. On võimalik kasutada piiravamat ja lihtsamat viisi andmetüüpide konstrueerimiseks. Awful toob sisse \textit{hargnevad andmetüübid}, mida tutvustame alamjaotises~\ref{hargnevad}.
    \subsection{Edutamisega kaasnev nimekonflikt}
      Haskellis on sageli tavaks, et andmekonstruktori nimi ühtib tüübi nimega.

      \begin{verbatim}data Pair t u = Pair t u\end{verbatim}

      Awful lausa nõuab ühe andmekonstruktoriga tüüpide (struktuuride) korral, et andmekonstruktori nimi ühtiks tüübi nimega. Ilma edutamiseta ei põhjusta selline kattuvus nimekonflikti. Kuna andmekonstruktor esineb ainult avaldiste tasandil ja sama nimega tüübikonstruktor esineb ainult tüüpide tasandil, ei teki vajadust neil kahel vahet teha. Edutamine muudab olukorda.

      Edutades ülalpool mainitud andmetüüpi, saame lisaks tüübikonstruktorile \verb!Pair! liiki \verb!* -> * -> *! samanimelise tüübikonstruktori liiki \verb!t -> u -> Pair t u!, kus \verb!t! ja \verb!u! on liigimuutujad ning \verb!Pair! on edutamise teel saadud liigikonstruktor. Seega on meil nüüd kaks erineva liigi ja otstarbega, aga samanimelist tüübikonstruktorit. Nendel vahet tegemiseks on mitmeid erinevaid võimalusi.
      \subsubsection{Eksplitsiitne edutamine vajaduse korral}
        Haskellis kasutatakse juhtudel, kus tekib nimede konflikt, edutamise teel saadud tüübikonstruktori ees ülakoma~\cite{Giv}. Antud näite korral tähistab tüübikonstruktor \verb!Pair! tavalist tüübikonstruktorit liiki \verb!* -> * -> *! ning \verb!'Pair! tähistab edutamise teel saadud tüübikonstruktorit liiki \verb!t -> u -> Pair t u!.

        Tasub mainida ka, et juhul kui kasutaja otsustab Haskellis kompileerimisel \verb!-Wall! võtit kasutada, antakse hoiatused kõigi edutamise teel saadud tüübikonstruktorite kohta, mille ette ei ole ülakoma pandud -- ka nende kohta, mille puhul ei ole nimekonflikti võimalust~\cite{Gla}.
      \subsubsection{Nimekonflikti vältimine}
        Üks võimalus nimekonflikti lahendada on keelata tüübikonstruktori ja andmekonstruktori nimede ühtimine.

        \begin{verbatim}data Pair t u = MkPair t u\end{verbatim}

        Antud lahendus on lihtne, aga tal on puudusi. Nii on võimalik vältida edutamise eksplitsiitset märkimist, aga samas muutuvad pikemaks tavalised andmekonstruktorid. Programmeerijatele, kes on harjunud tüübikonstruktorit ja andmekonstruktorit sama nimega nimetama, võib olla kergem kohaneda edutamise eksplitsiitse märkimisega kui andmekonstruktorite teisiti nimetamisega.
      \subsubsection{Eksplitsiitne edutamine alati}
        Nimekonflikti saab lahendada ka märkides kõik edutamise teel saadud liigid ja tüübid mõne spetsiaalse sümboliga, näiteks ülalpool mainitud andmetüübi \verb!Pair! deklaratsioon annaks lisaks tavalisele andmekonstruktorile ja tüübikonstruktorile ka 2 argumendi liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"t -> u -> !Pair t u".

        Käesoleva töö autori arvates on tegu hea lahendusega, sest erinevalt eksplitsiitsest edutamisest ainult vajaduse korral näevad edutamise teel saadud tüübikonstruktorid ühtlasemad välja. Lisaks võib edutamise teel saadud tüübikonstruktorite eksplitsiitne eristamine tavalistest tüüpidest aidata programmeerijat, kes ei ole veel edutamisega harjunud ja ei tunne end kindlalt seda abstraktsiooni kasutades.

        Selle tõttu ongi tegu lahendusega, mis sai valitud käesoleva töö raames loodud programmeerimiskeele jaoks. Awful kasutab edutamise tähistamiseks hüüumärki ning nõuab seda nii edutamise teel saadud liikide kui ka tüüpide ees.
    \subsection{Edutamise võrdlus sõltuvate tüüpidega}\label{soltuvad}
      Paljude keelte tüübisüsteemides, sealhulgas Haskelli omas, kehtib \textit{faasierisus} (ing. k. \textit{phase distinction}). Väärtused võivad sõltuda tüüpidest aga mitte vastupidi. Ka edutamise olemasolul jääb faasierisus tegelikult kehtima. Kuigi näiteks vektorite puhul võib tunduda, et vektori tüüp sõltub naturaalarvulisest väärtusest, aga tegelikult on tüübid ja väärtused siiski rangelt eristatud~\cite{Giv}.

      Mõnedes teistes programmeerimiskeeltes, näiteks Agda~\cite{Agd}, Coq~\cite{The_Coq} ja Idris~\cite{The_Idr}, on olemas sõltuvad tüübid. See tähendab, et tüübid võivad sõltuda väärtustest. Sõltuvate tüüpidega keeltes puudub faasierisus.

      Sõltuvad tüübid, nagu ka edutamine, võimaldavad luua tüübitaseme naturaalarvusid ja liste ning muid tüübitaseme andmeid. Tegu on aga võimsama tööriistaga kui edutamine. Toome näiteks mõned lihtsad funktsioonid, mida saab kirjutada sõltuvate tüüpidega keeles, aga mis ei ole võimalikud ainult andmetüüpide edutamise abil. Tarvitame näidetes Idrise süntaksit, sest see on väga sarnane Haskelli omaga. Siinkohal toodud näidetes on ainsateks erinevusteks see, et tüübi märkimiseks kasutatakse ühte ja listi konstrueerimiseks kahte semikoolonit ning liigi \verb!*! asemel kasutatakse nime \verb!Type!.

      Üks lihtne ja kasulik funktsioon, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada, on kahe staatilise vektori konkateneerimine. Kui me konkateneerime vektoreid pikkusega \verb!m! ja \verb!n!, siis tulemuse pikkus on \verb!m + n!. Tegu on tüübitaseme naturaalarvude liitmisega. Kui edutatakse ainult tüüpe ja andmekonstruktoreid, ei ole tüübitaseme andmetele võimalik rakendada funktsioone.

      \begin{verbatim}cat : Array m t -> Array n t -> Array (m + n) t
cat Empty_Array b = b
cat (Construct_Array x a) b = Construct_Array x (cat a b)\end{verbatim}

      Toome siinkohal veel ühe näite sõltuvate tüüpide kasutusest~\cite{The_Idr}, mida ei ole võimalik teostada edutamise abil. Üldistatud algebraline andmetüüp \verb!InElement! võimaldab staatiliselt tõestada, et element esineb listis. Funktsiooni \verb!inList! tüüp \verb!InList (5 : Int) [1, 2, 5]! on teoreem, mis ütleb, et \verb!5! esineb listis \verb![1, 2, 5]!. See, et meil õnnestub vastavat tüüpi funktsioon kirjutada, tõestab tüübis toodud väite.

      \begin{verbatim}data InList : t -> List t -> Type where
  Here : InList x (x :: l)
  There : InList x l -> InList x (y :: l)
inList : InList (5 : Integer) [1, 2, 5]
inList = There (There Here)\end{verbatim}

      Haskellis \verb!InList! tüüp küll toimib, sest liste on võimalik tüübi tasemele edutada, aga kuna \verb!Int! ei ole edutatav tüüp, ei ole Haskellis võimalik elemendi leidumise tõestust \verb!Int! tüüpi täisarvude listi jaoks läbi viia. Veel halvem on olukord juhul, kui tahaksime analoogseid tõestusi läbi viia vektorite peal. Sõltuvate tüüpidega on see võimalik, aga tavaline ühekordne edutamine ei võimalda saavutada tüübitaseme vektoreid. Haskellis ei läbiks järgnev andmetüüp tüübikontrolli.

      \begin{verbatim}data InArray : t -> Array n t -> Type where
  Here : InArray x (Construct_Array x a)
  There : InArray x l -> InArray x (Construct_Array y a)\end{verbatim}

      Näeme, et paraku on kasulikke ning üldsegi mitte keerulisi andmetüüpe ja funktsioone, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada. Edutamisel on võrreldes sõltuvate tüüpidega siiski ka eeliseid mitte ainult puudusi~\cite{Giv}:

      \begin{itemize}
        \item
          Programmeerijatel, kes on harjunud faasierisusega, võib olla lihtsam mõista edutamist kui sõltuvaid tüüpe.
        \item
          Sõltuvad tüübid muudavad keerulisemaks tüübikontrolli ja tüübituletuse.
        \item
          Sellistes keeltes nagu Haskell on võimalik tüübikontrolli järel kõik tüübid kustutada (ing. k. \textit{type erasure}). See, et programmi töö käigus ei ole enam tüüpe tarvis, aitab kaasa jõudlusele. Sõltuvate tüüpide korral on tüüpide kustutamine oluliselt keerulisem ülesanne.
      \end{itemize}

      Paljude kasutusjuhtude jaoks on edutamine piisav. Edutamine muudab tüübisüsteemi oluliselt võimsamaks ja väljendusrikkamaks, ohverdamata samas lihtsust ja nõudmata programmeerijalt oluliselt teistmoodi tüübisüsteemiga kohanemist.
  \peatykk{Süntaks}\label{syntaks}
    Selles peatükis kirjeldame Awfuli süntaksit.
    \subsection{Süntaksi formaalne spetsifikatsioon}
      Toome konkreetse süntaksi formaalse spetsifikatsiooni. Lisaks püstkriipsule, mis tähistab valikut kahe variandi vahel, ja tähele $\epsilon$, mis tähistab tühja sõnet, kasutame järgimisi sümboleid:

      \begin{equation*}
        \begin{tabular}{lll}
          $A^*$ & $=$ & $AA^*\mid\epsilon$ \\
          $A?$  & $=$ & $A\mid\epsilon$
        \end{tabular}
      \end{equation*}

      Käesolev süntaksi spetsifikatsioon ei tegele leksiliste detailidega, nagu tühikud, reavahetused, kommentaarid ning muutujanimede, tähtede ja täisarvude leksiline struktuur. Neid detaile selgitame peatüki lõpus jaotistes~\ref{kommentaarid} ja~\ref{muutujanimed}.

      Loetavuse huvides on keele elementide tähistused ning süntaksi kirjeldamiseks kasutatav notatsioon tavalises kirjatüübis. Tavalised ümarsulud on kasutusel grammatiliste konstruktsioonide grupeerimiseks. Keele võtmesõnad ja sümbolid on helehallis fikseeritud laiusega kirjatüübis. Halli värvi ümar-, kant-, look- ja nurksulud on keele süntaksi osa.

      \begin{equation*}
        \begin{tabular}{llll}
          Fail & $P$ & $::=$ & $I^*D^*C^*(F\mid I)^*$
        \end{tabular}
      \end{equation*}

      Awfuli fail koosneb imporditavate failide nimekirjast ning andmetüüpidest, klassidest, definitsioonidest ja esindajatest.

      \begin{equation*}
        \begin{tabular}{llll}
          Import & $I$ & $::=$ & {\color{helehall}\verb!Load!} $x${\color{helehall}\verb!.awf!}
        \end{tabular}
      \end{equation*}

      Tähega $x$ tähistame süntaksi spetsifikatsioonis ükskõik millist nime: kas siis faili, tüübi, tüübimuutuja, konstruktori, struktuuri välja, definitsiooni või lokaalse muutuja oma. Nimede lekstilist struktuuri kirjeldame jaotises~\ref{muutujanimed}.

      \begin{equation*}
        \begin{tabular}{llll}
          Andmetüüp & $D$ & $::=$ & $S\mid A\mid B$
        \end{tabular}
      \end{equation*}

      Andmetüüp võib olla struktuur, algebraline andmetüüp või hargnev andmetüüp. Hargnevate andmetüüpe sisulist poolt tutvustame alamjaotises~\ref{hargnevad}. Käsolevas peatükis toome ainult süntaksi.

      \begin{equation*}
        \begin{tabular}{llll}
          Struktuur & $S$ & $::=$ & {\color{helehall}\verb!Struct!} $x$ $t$ $\phi$
        \end{tabular}
      \end{equation*}

      Struktuuri deklaratsioon sisaldab nime, tüübimuutujaid ja väljasid.

      \begin{equation*}
        \begin{tabular}{llll}
          Tüübimuutujad & $t$ & $::=$ & $(${\color{helehall}\verb![!}$\tau(${\color{helehall}\verb!,!} $\tau)^*${\color{helehall}\verb!]!}$)?$
        \end{tabular}
      \end{equation*}

      Iga tüübimuutuja korral on kohustuslik märkida tema liik. Kui tüübimuutujate nimekiri on tühi, tuleb kandilised sulud ära jätta.

      \begin{equation*}
        \begin{tabular}{llll}
          Tüübimuutuja koos liigiga & $\tau$ & $::=$ & $x$ {\color{helehall}\verb!:!} $L$
        \end{tabular}
      \end{equation*}

      Nagu ka Idrises märgitakse tüüpe ja liike ühe mitte kahe kooloniga.

      \begin{equation*}
        \begin{tabular}{llll}
          Liik                     & $L$   & $::=$ & $L_f\mid L_a\mid L_n$                                                          \\
          Tüübikonstruktorite liik & $L_f$ & $::=$ & $L_1$ {\color{helehall}\verb!->!} $L$                                          \\
          Liigi rakendamine        & $L_a$ & $::=$ & $L_0$ $L_0$ $L_0^*$                                                            \\
          Liigi nimi               & $L_n$ & $::=$ & {\color{helehall}\verb"!"}$?x$                                                 \\
          Sulgudes liik            & $L_0$ & $::=$ & {\color{helehall}\verb!(!}$(L_f\mid L_a)${\color{helehall}\verb!)!} $\mid L_n$ \\
                                   & $L_1$ & $::=$ & {\color{helehall}\verb!(!}$L_f${\color{helehall}\verb!)!} $\mid L_a\mid L_n$
        \end{tabular}
      \end{equation*}

      Liikide süntaks on lihtne, koosnedes ainult nimedest ja rakendamisest ning binaarsest operaatorist \verb!->!, millega saab asendada tüübikonstruktori liigi \verb!Arrow! nime. Edutamise teel saadud liikide ette käib hüüumärk.

      \begin{equation*}
        \begin{tabular}{llll}
          Väljad või argumendid & $\phi$ & $::=$ & $(${\color{helehall}\verb!(!}$v(${\color{helehall}\verb!,!} $v)^*${\color{helehall}\verb!)!}$)?$ \\
          Muutuja koos tüübiga  & $v$    & $::=$ & $x$ {\color{helehall}\verb!:!} $T$
        \end{tabular}
      \end{equation*}

      Struktuuri väljade ja funktsiooni argumentide süntaks on identne. Juhul, kui struktuuril ei ole väljasid või funktsioonil ei ole argumente, tuleb ümarsulud ära jätta.

      \begin{equation*}
        \begin{tabular}{llll}
          Tüüp                          & $T$   & $::=$ & $T_f\mid T_t\mid T_a\mid T_0$                                                          \\
          Funktsiooni tüüp              & $T_f$ & $::=$ & $T_2$ {\color{helehall}\verb!->!} $T$                                                  \\
          Paari tüüp                    & $T_t$ & $::=$ & $T_1$ {\color{helehall}\verb!*!} $T_2$                                                 \\
          Tüübi rakendamine             & $T_a$ & $::=$ & $T_p$ $T_p$ $T_p^*$                                                                    \\
          Atomaarne tüüp                & $T_0$ & $::=$ & $T_n\mid T_c\mid T_i\mid n$                                                            \\
                                        & $T_2$ & $::=$ & {\color{helehall}\verb!(!}$T_f${\color{helehall}\verb!)!} $\mid T_t\mid T_a\mid T_0$   \\
                                        & $T_1$ & $::=$ & {\color{helehall}\verb!(!}$(T_f\mid T_t)${\color{helehall}\verb!)!} $\mid T_a\mid T_0$ \\
          Sulgudes tüüp                 & $T_p$ & $::=$ & {\color{helehall}\verb!(!}$(T_f\mid T_t\mid T_a)${\color{helehall}\verb!)!} $\mid T_0$ \\
          Tüübi nimi ja liigiargumendid & $T_n$ & $::=$ & {\color{helehall}\verb"!"}$?x$ $\gamma$                                                \\
          Tüübitaseme täht              & $T_c$ & $::=$ & {\color{helehall}\verb"!"}$c$                                                          \\
          Tüübitaseme täisarv           & $T_i$ & $::=$ & {\color{helehall}\verb"!"}$i$
        \end{tabular}
      \end{equation*}

      Tüüpide süntaks on sarnane liikide omaga, aga keerulisem selle tõttu, et tüüpide puhul lisanduvad eksplitsiitsed liigiargumendid, mis on liigipolümorfsete tüüpide korral kohustuslikud liigituletuse vältimiseks, ning tüübitaseme primitiivid. Lisaks on olemas süntaktiline suhkur tüübitaseme naturaalarvude jaoks (näiteks teisendatakse \verb!1! tüübiks \verb"!Next !Zr").

      Binaarsete tüübikonstruktorite \verb!Function! ja \verb!Pair! jaoks on defineeritud operaatorid. Mõlemad assotsieeruvad paremale ning paari tüübi operaator \verb!*! on kõrgema prioriteediga kui funktsiooni tüübi operaator \verb!->!.

      Tähega $n$ tähistame süntaksi spetsifikatsioonis naturaalarvu (kaasa arvatud null), tähega $c$ tähemärki ja tähega $i$ täisarvu. Tähtede ümber käivad topeltjutumärgid (näiteks \verb#"!"#). Reavahetuse märk on \verb!"\n"!. Hetkel toetab Awful ainult ASCII standardi tähti.

      \begin{equation*}
        \begin{tabular}{llll}
          Liigiargumendid & $\gamma$ & $::=$ & $(${\color{helehall}\verb"["}$L(${\color{helehall}\verb","}$L)^*${\color{helehall}\verb"]"}$)?$
        \end{tabular}
      \end{equation*}

      Liigiargumentide puhul antakse liigiparameetrite konkreetsed väärtused ette kandilistes sulgudes liigi või tüübi nime järel. Juhul, kui liik või tüüp ei ole liigipolümorfne -- ehk ei võta ühtegi liigiargumenti -- tuleb kandilised sulud ära jätta.

      \begin{equation*}
        \begin{tabular}{llll}
          Algebraline andmetüüp              & $A$ & $::=$ & {\color{helehall}\verb!Algebraic!} $x$ $t${\color{helehall}\verb!(!}$a${\color{helehall}\verb!,!} $a(${\color{helehall}\verb!,!} $a)^*${\color{helehall}\verb!)!} \\
          Algebralise andmetüübi konstruktor & $a$ & $::=$ & $x$ $T_p^*$
        \end{tabular}
      \end{equation*}

      Algebraline andmetüüp, nagu ka struktuur, algab nimest ja tüübimuutujate nimekirjast. Sellele järgneb nimekiri vähemalt kahest konstruktorist. Algebralise andmetüübi konstruktor, erinevalt struktuuri omast, ei anna väljadele nimesid.

      \begin{equation*}
        \begin{tabular}{llll}
          Hargnev andmetüüp               & $B$ & $::=$ & {\color{helehall}\verb!Branching!} $x${\color{helehall}\verb"[!"}$x$ $\gamma${\color{helehall}\verb!]!}$t${\color{helehall}\verb!(!}$b${\color{helehall}\verb!,!} $b(${\color{helehall}\verb!,!} $b)^*${\color{helehall}\verb!)!} \\
          Hargneva andmetüübi konstruktor & $b$ & $::=$ & {\color{helehall}\verb"!"}$x$ $x^*$ {\color{helehall}\verb!->!} $x$ $\phi$
        \end{tabular}
      \end{equation*}

      Hargnev andmetüüp algab nimest. Sellele järgneb kandilistes sulgudes liik, mille järgi hargnetakse. Kuna hargnev andmetüüp võib hargneda ainult üle liigi, millel on lõplik arv tüübikonstruktoreid, peab see tingimata olema edutamise teel saadud liik ning liigi nimele peab eelnema hüüumärk. Järgneb ülejäänud tüübimuutujate nimekiri ja konstruktorite nimekiri. Konstruktor koosneb edutamise teel saadud tüübi nimest, tüübimuutujate nimekirjast, konstruktori nimest ja väljadest.

      \begin{equation*}
        \begin{tabular}{llll}
          Klass  & $C$ & $::=$ & {\color{helehall}\verb!Class!} $x${\color{helehall}\verb!{!}$\tau${\color{helehall}\verb!}!}$(${\color{helehall}\verb!<!}$x${\color{helehall}\verb!>!}$)?(${\color{helehall}\verb!(!}$M(${\color{helehall}\verb!,!} $M)^*${\color{helehall}\verb!)!}$)?$ \\
          Meetod & $M$ & $::=$ & $x$ $t$ $k$ {\color{helehall}\verb!:!} $T$
        \end{tabular}
      \end{equation*}

      Tüübiklassi deklaratsioon algab nimest ning tüübimuutujast koos liigiga looksulgudes. Päritav klass on võimalik spetsifitseerida nurksulgudes. Seejärel tuleb meetodite nimekiri, mis võib olla ka tühi, mis juhul tuleb ümarsulud ära jätta.

      \begin{equation*}
        \begin{tabular}{llll}
          Kitsendused & $k$      & $::=$ & $(${\color{helehall}\verb!<!}$\kappa(${\color{helehall}\verb!,!} $\kappa)^*${\color{helehall}\verb!>!}$)?$ \\
          Kitsendus   & $\kappa$ & $::=$ & $x$ $x$
        \end{tabular}
      \end{equation*}

      Kitsendused pannakse nurksulgudesse. Juhul kui kitsedusi ei ole, tuleb nurksulud ära jätta. Kitsendus koosneb klassi nimest ja kitsendatava tüübimuutuja nimest.

      \begin{equation*}
        \begin{tabular}{llll}
          Definitsioon & $F$ & $::=$ & {\color{helehall}\verb!Def!} $x$ $t$ $k$ $\phi$ {\color{helehall}\verb!:!} $T$ {\color{helehall}\verb!=!} $E$
        \end{tabular}
      \end{equation*}

      Definitsioon sisaldab nime, tüübimuutujaid, kitsendusi, argumentide nimekirja, tüüpi ja avaldist. Argumentide nimekiri on süntaktiline suhkur, mis parandab definitsioonide loetavust.

      \begin{verbatim}Def Id[T : Star](x : T) : T = x
Def Id[T : Star] : T -> T = x -> x\end{verbatim}

      Need kaks definitsiooni on ekvivalentsed ning esimene teisendatakse parsimise järel teiseks.

      \begin{equation*}
        \begin{tabular}{llll}
          Avaldis                & $E$   & $::=$ & $E_1\mid E_0$                                                           \\
          Mitteatomaarne avaldis & $E_1$ & $::=$ & $\Lambda_1\mid\alpha\mid\lambda\mid\mu\mid\Psi\mid m$                   \\
          Atomaarne avaldis      & $E_0$ & $::=$ & $\Lambda_0\mid\nu\mid c\mid i$                                         \\
          Sulgudes avaldis       & $E_p$ & $::=$ & {\color{helehall}\verb!(!}$E_1${\color{helehall}\verb!)!} $\mid E_0$
        \end{tabular}
      \end{equation*}

      Avaldis võib olla funktsiooni rakendamine, lambda-avaldis, mustrisobitusavaldis, let-avaldis, jäägiklassiringi element, muutujanimi, täht või täisarv. Lisaks on keelde sisse ehitatud süntaktiline suhkur listide jaoks.

      \begin{equation*}
        \begin{tabular}{llll}
          Jäägiklassiringi element & $m$ & $::=$ & $n$ {\color{helehall}\verb!#!} $n$
        \end{tabular}
      \end{equation*}

      Jäägiklassiringi elemendi (\verb!Modular!) puhul kirjutatakse ringi moodul numbri järele, eraldatuna \verb!#! sümboliga.

      \begin{equation*}
        \begin{tabular}{llll}
          Muutujanimi & $\nu$ & $::=$ & $x(${\color{helehall}\verb!{!}$T${\color{helehall}\verb!}!}$)?(${\color{helehall}\verb![!}$T(${\color{helehall}\verb!,!}$T)^*${\color{helehall}\verb!]!}$)?$
        \end{tabular}
      \end{equation*}

      Muutujanimele saab anda eksplitsiitseid tüübiargumente.

      \begin{equation*}
        \begin{tabular}{llll}
          Funktsiooni rakendamine & $\alpha$ & $::=$ & $E_p$ $E_p$ $E_p^*$
        \end{tabular}
      \end{equation*}

      Funktsiooni rakendamine assotsieerub vasakult paremale ning järjekorda saab muuta ümarsulgudega täpselt nagu Haskellis. Erinevalt Haskellist ei luba Awful ebavajalikke sulgusid, mille ära jätmine ei põhjusta muudatusi avaldise tähenduses, näiteks \verb!(0)!. Ainsaks erandiks on sulud jäägiklassiringi elementide ja mittetühjade listide süntaktilise suhkru ümber, kus sulud küll ei osale tehete jäjekorra määramisel, aga see-eest aitavad programmeerijat koodi lugemisel. Näiteks on avaldis \verb!f (0 # 1)! oluliselt paremini loetav kui \verb!f 0 # 1!.

      \begin{equation*}
        \begin{tabular}{llll}
          Lambda & $\lambda$ & $::=$ & $x$ {\color{helehall}\verb!->!} $E$
        \end{tabular}
      \end{equation*}

      Lambda-avaldis koosneb muutujanimest, millele järgneb nool ja avaldis.

      \begin{equation*}
        \begin{tabular}{llll}
          Mustrisobitus & $\mu$    & $::=$ & {\color{helehall}\verb!Match!} $E$ {\color{helehall}\verb!{!}$(M_a\mid M_c\mid M_i\mid M_m)${\color{helehall}\verb!}!} \\
                        & $M_a$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_a)^*\delta?$ \\
                        & $\mu_a$  & $::=$ & $x$ $x^*$ {\color{helehall}\verb!->!} $E$ \\
          Vaikevalik    & $\delta$ & $::=$ & {\color{helehall}\verb!,!} {\color{helehall}\verb!Default ->!} $E$ \\
                        & $M_c$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_c)^*\delta$ \\
                        & $\mu_c$  & $::=$ & $c$ {\color{helehall}\verb!->!} $E$ \\
                        & $M_i$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_i)^*\delta$ \\
                        & $\mu_i$  & $::=$ & $i$ {\color{helehall}\verb!->!} $E$ \\
                        & $M_m$    & $::=$ & $\mu_a(${\color{helehall}\verb!,!} $\mu_i)^*\delta?$ \\
                        & $\mu_m$  & $::=$ & $m$ {\color{helehall}\verb!->!} $E$
        \end{tabular}
      \end{equation*}

      Mustrisobitus algab võtmesõnaga \verb!Match! ja avaldisega, seejärel on looksulgudes harude nimekiri. Juhul, kui tegu on algebraliste andmetüüpide või jäägiklassiringi elementide mustrisobitusega ($M_a$ ja $M_m$), on vaikevalik (\verb!Default!) mittekohustuslik. Juhul, kui tegu on primitiivide mustrisobitusega ($M_c$ ja $M_i$), on vaikevalik kohustuslik.

      \begin{equation*}
        \begin{tabular}{llll}
          Let-avaldis           & $\Psi$ & $::=$ & {\color{helehall}\verb!Let!} $\psi(${\color{helehall}\verb!,!}$\psi)^*$ {\color{helehall}\verb!In!} $E$ \\
          Lokaalne definitsioon & $\psi$ & $::=$ & $x$ $x^*$ {\color{helehall}\verb!=!} $E$
        \end{tabular}
      \end{equation*}

      Let-avaldis algab võtmesõnaga \verb!Let!, millele järgneb mittetühi lokaalsete definitsioonide nimekiri, võtmesõna \verb!In! ja tulemuseks olev avaldis. Tegu on järjestikuse let-avaldisega, mis ei võimalda rekursiivseid definitsioone. Parsimise järel teisendatakse let-avaldis lambda-avaldiste rakendamise jadaks. Awfuli let-avaldisest räägime ka alamjaotises~\ref{letavaldis}.

      \begin{equation*}
        \begin{tabular}{llll}
          Tühi list      & $\Lambda_0$ & $::=$ & {\color{helehall}\verb!List!}                                                                                          \\
          Mittetühi list & $\Lambda_1$ & $::=$ & {\color{helehall}\verb!List!} {\color{helehall}\verb!(!}$E(${\color{helehall}\verb!,!}$E)^*${\color{helehall}\verb!)!}
        \end{tabular}
      \end{equation*}

      Listide süntaktiline suhkur algab sõnaga \verb!List! ning järgneb ümarsulgudes komadega eraldatud elementide loetelu. Juhul, kui list on tühi, on kohustuslik ümarsulud ära jätta.

      \begin{equation*}
        \begin{tabular}{llll}
          Esindaja        & $I$ & $::=$ & {\color{helehall}\verb!Instance!} $x${\color{helehall}\verb!{!}$T_n$ $x^*${\color{helehall}\verb!}!}$k(${\color{helehall}\verb!(!}$m(${\color{helehall}\verb!,!} $m)^*${\color{helehall}\verb!)!}$)?$ \\
          Meetodi teostus & $m$ & $::=$ & $x$ $x^*$ {\color{helehall}\verb!=!} $E$
        \end{tabular}
      \end{equation*}

      Esindaja korral tuleb märkida klassi nimi, tüübi nimi koos tüübimuutujatega, kitsenduste nimekiri ja meetodite teostuste nimekiri. Meetodi teostus koosneb meetodi nimest, muutujate nimekirjast ja avaldisest. Võimalus otse meetodi nime järel muutujate nimesid kirjutada, et vähendada lambda-avaldiste arvu, on jällegi süntaktiline suhkur. See teisendatakse enne nime- ja tüübikontrolli lambda-avaldisteks.

      Süntaks ei ole taandetundlik. Põhjuseks oli parseri teostuse lihtsus, aga ka soov anda kasutajale vabadus koodi paigutuses. Lisaks vähendab mitte-taandetundlikkus parsimisvigade ohtu suuremate kooditükkide kopeerimisel ühest kohast teise, mis on mugav näiteks koodi refaktoreerides. Peamiseks puuduseks on liigsed sulud ja eraldajad (näiteks \verb!Match! avaldises), mida taandetundlik süntaks oleks aidanud vältida.
    \subsection{Kommentaarid}\label{kommentaarid}
      Kommentaaride süsteem on sarnane Haskellile ja C keelele, selle vahega, et kasutatakse teistsuguseid sümboleid. Üherealist kommentaari alustatakse graavise sümboliga.

      \begin{verbatim}Def Id[T : Star](x : T) : T = T `Ühikfunktsioon\end{verbatim}

      Mitmerealist kommentaari alustatakse lainelise joone ja kaldkriipsuga, ning lõpetatakse kaldkriipsu ja lainelise joonega. Nagu ka Haskellis võib mitmerealisi kommentaare teineteise sisse paigutada.

      \begin{verbatim}~/ Awful on funktsionaalne keel. /~\end{verbatim}
    \subsection{Muutujanimede leksiline struktuur}\label{muutujanimed}
      Keel on tõstutundlik. Erinevalt Haskellist ei ole piiratud, mis nimed peavad algama suur- ja millised väiketähega. Failid, liigid, tüübid, tüübimuutujad, konstruktorid, struktuuride väljad, klassid, definitsioonide nimed ja lokaalsed muutujad võivad kõik alata kas suur- või väiketähega vastavalt kasutaja soovile.

      Nimedes on lubatud ülakoma, numbrid (välja arvatud esimeses positsioonis), ladina tähed ja alakriips. ASCII standardis mitte-esinevad sümbolid ei ole nimedes lubatud, küll aga tohib neid kasutada kommentaarides.

      Üksik alakriips tähistab, nagu ka Haskellis, nimetamata muutujat.
  \peatykk{Keele kirjeldus ja koodinäited}\label{manual}
    Awful on deklaratiivne, puhas, funktsionaalne keel.

    Kuna töö teemaks oli tüübisüsteemi arendamine mitte kompileerimisega seotud problemaatika, sai kirjutatud ainult interpretaator ning kompileerimise võimalust ei ole. Tüübisüsteem on siiski staatiline: koodifaile on võimalik tüübikontrollida ka ilma väärtustajat käivitamata ning tüükontroll toimub enne väärtustamist mitte selle käigus.

    Erinevalt Haskellist, mis kasutab laiska väärtustamist, on Awful agara väärtustamisega. Laisa väärtustamise puhul väärtustatakse avaldised alles siis, kui nende tulemusi vaja on, samas kui agar väärtustamine tähendab, et kohe funktsiooni kutsel väärtustatakse kõik argumendid~\cite{Sem}. Agara väärtustamise valiku põhjuseks, nagu ka selle põhjuseks, et keel on interpreteeritud mitte kompileeritud, oli see, et töö fookuses oli tüübisüsteem ning väärtustamise viis on selle seisukohast ebatähtis. Seega sai valik langetatud lihtsama variandi kasuks.
    \subsection{Awfuli interpretaatori kasutajaliides}
      Interpretaatori lähtekood, mis on kirjutatud Haskellis, ja ka keelega kaasas käivad teegid, asuvad aadressil

      \begin{verbatim}github.com/LiisiKerik/Awful\end{verbatim}

      Interpretaatori kompileerimiseks tuleb kompileerida fail \verb!Awful.hs!.

      \begin{verbatim}ghc Awful.hs\end{verbatim}

      Awful annab kasutajale kaks käsklust, mida koodifailidele ja avaldistele rakendada: \verb!check!, mis teostab tüübikontrolli, ning \verb!eval!, mis väärtustab avaldise. Käsklus \verb!check! võtab argumendiks failinime ning tüübikontrollib faili sisu ja kõik selle impordid.

      \begin{verbatim}./Awful check Standard.awf\end{verbatim}

      Käsklus \verb!eval! võtab argumendiks nimekirja failinimedest ja avaldise ning tüübikontrollib failid ja kõik nende impordid. Seejärel väärtustatakse avaldis keskkonnas, kus on saadaval kasutaja antud failide nimekirjast leitud definitsioonid.

      \begin{verbatim}./Awful eval Standard.awf Algebra.awf "Fmap (Add 1) (Complex 2 5)"\end{verbatim}

      Interpreteeritav avaldis peab olema tüübist, mis on \verb!Writeable! klassi esindaja, ning tulemus kuvatatakse \verb!Write_Brackets! meetodi abil.
    \subsection{Koodifailid ja importimine}
      Kõik Awfuli koodifailid lõpevad laiendiga \verb!.awf!. Faile saab importida kasutades võtmesõna \verb!Load!. Impordid peavad olema faili alguses ja nende omavaheline järjekord ei ole oluline.

      \begin{verbatim}Load Algebra.awf
Load Standard.awf\end{verbatim}

      Ringsõltuvused failide vahel on keelatud. Nende olemasolul antakse kasutajale veateade, kus kuvatakse nimekiri tsüklit moodustavatest failidest.
    \subsection{Nimekonfliktid}
      Awfuli nimekontrolli olulisemad aspektid on järgmised:

      \begin{itemize}
        \item
          Programmis esinevaid nimesid -- liikide, tüüpide, konstruktorite, struktuuri väljade, klasside, definitsioonide, tüübimuutujate ja lokaalsete muutujate nimesid -- kogutakse ühte nimekontrolli-keskkonda. See tähedab, et sama nime ei tohi jagada ka täiesti erineva otstarbega konstruktsioonid, näiteks tüüp ja definitsioon, kuigi sellele ei oleks põhimõttelisi takistusi.
        \item
          Ainsaks erandiks reeglist, et globaalsed nimed ei tohi olenemata otstarbest omavahel ühtida, on struktuuri tüübikonstruktori ja andmekonstruktori nimi. Struktuuri deklareerimisel antakse automaatselt sama nimi nii tüübikonstruktorile kui ka andmekonstruktorile.
        \item
          Sama programmi kahes erinevas moodulis ei tohi esineda ühesugust globaalset nime, isegi juhul kui impordisuhted failide vahel on sellised, et tegelikult nimekonflikti ei teki. Tegu oli teostuse lihtsusest lähtuva otsusega.
        \item
          Kui moodul \verb!B! impordib (otse või kaudselt) mooduli \verb!A!, tehakse nimekontroll enne mooduli \verb!A! peal. See tähendab, et mõni lokaalne nimi moodulis \verb!A! võib ühtida mõne globaalse nimega moodulis \verb!B!, aga mitte vastupidi.
        \item
          Erinevalt Haskellist ei luba Awful muutujate varjutamist (ing. k. \textit{shadowing}). Näiteks lambda-avaldis \verb!f = \x -> \x -> x! on Haskellis lubatud (olenevalt kompilaatori seadistustest võib see resulteeruda hoiatuses). Sisemine \verb!x! varjutab välimise ning avaldise \verb!f 0 1! väärtustamise tulemuseks on \verb!1!. Samas Awfulis on analoogne avaldis \verb!x -> x -> x! keelatud.
      \end{itemize}
    \subsection{Liigid ja andmetüübid}
      Haskellis on olemas tavalised algebralised andmetüübid ja üldistatud algebralised andmetüübid. Awfuli lähenemine andmetüüpidele on teistsugune. Keel pakub kasutajale kolme erinevat viisi uute andmetüüpide loomiseks: struktuurid, algebralised andmetüübid (mis mõnevõrra erinevad Haskelli omadest) ja hargnevad andmetüübid. Kõigil on erinev otstarve.

      Awful nõuab, et andmetüübid oleks deklareeritud enne klasse ja definitsioone. Andmetüüpide deklaratsioonide omavaheline järjekord ei ole aga oluline isegi kui nende vahel on sõltuvusi.
      \subsubsection{Liigid ja edutamine}
        Keelde on sisse ehitatud liigid \verb!Star! ja \verb!Arrow!, mis on analoogsed vastavalt Haskelli liikidega \verb!*! ja \verb!->!. Liigi \verb!Arrow! jaoks on sisse ehitatud binaarne operaator \verb!->!. Lisaks on Awfuli liigi- ja tüübisüsteemi täiendatud edutamise abil. Edutamisest on antud põhjalik ülevaade peatükis~\ref{edutamine} ning Haskelli ja Awfuli edutamise erinevusi käsitleb alamjaotis~\ref{kitsendused}.
      \subsubsection{Struktuurid}
        Struktuurid on mõeldud andmetüüpide jaoks, millel on täpselt üks konstruktor. Andmekonstruktori nimi ühtib automaatselt tüübi nimega. Struktuuri väljadele on kohustuslik nimed anda.

        \begin{verbatim}Struct Complex[T : Star](Real : T, Imaginary : T)\end{verbatim}

        Juhul, kui struktuur ei kasuta tüübipolümorfismi, tuleb kandilised sulud lihtsalt ära jätta. Sama kehtib ka struktuuri väljade kohta: juhul kui struktuuril ei ole ühtegi välja, tuleb ära jätta ümarsulud väljade loeteluga.

        \begin{verbatim}Struct Trivial\end{verbatim}

      \subsubsection{Algebralised andmetüübid}
        Algebralised andmetüübid sarnanevad Haskelli omadele, selle vahega, et kasutajalt nõutakse vähemalt kahte konstruktorit ja ühegi andmekonstruktori nimi ei tohi tüübi nimega ühtida. Juhul, kui kasutaja tahab kirjutada ühe andmekonstruktoriga andmetüüpi, on selleks struktuurid.

        Konstruktorite loetelu käib tüübimuutujate nimekirja järel ümarsulgudes.

        \begin{verbatim}Algebraic Either[T : Star, U : Star](Left T, Right U)\end{verbatim}

        Kuna algebraliste andmetüüpide puhul on andmetel kaks või enam erinevat võimalikku kuju, ei ole nende jaoks antud võimalust spetsifitseerida väljade nimesid -- need funktsioonid ei oleks tüübiturvalise. Kui struktuurist saab andmed kätte väljade nimede abil, siis algebraliste andmetüüpide jaoks tuleb kasutada mustrisobitusavaldist, mida on kirjeldatud alamjaotises~\ref{match}.
      \subsubsection{Keelde sisse ehitatud andmetüübid}
        Lisaks tähtedele (\verb!Char!), funktsioonidele (\verb!Function!), piiramata suurusega täisarvudele (\verb!Int!) ja jäägiklassiringidele (\verb!Modular!) on Awfulis ka ilma standardteeki importimata saadaval järgmised andmetüübid:

        \begin{verbatim}Algebraic Comparison(LT, EQ, GT)
Algebraic List[T : Star](Empty_List, Construct_List T (List T))
Algebraic Logical(False, True)
Algebraic Maybe[T : Star](Nothing, Wrap T)
Algebraic Nat(Zr, Next Nat)
Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Väiksem-võrdne-suurem võrdlustulemuse tüüp \verb!Comparison! on keelde sisse ehitatud, sest keelde on sisse ehitatud ka primitiivide (tähtede ja täisarvude) võrdlus. Listid, loogikaväärtused ja paarid on keelde sisse ehitatud põhjusel, et neid on vaja \verb!Writeable! klassi jaoks, mille kaudu on teostatud avaldise väärtustamise tulemuste kasutajasõbralik esitamine. \verb!Maybe! on lisatud sisse ehitatud klassi \verb!Field! (korpus) jaoks, sest pöördelemendi tehte tulemus antakse \verb!Maybe! monaadi all, kuna kõik korpused peale triviaalse sisaldavad mittepööratavaid elemente. Naturaalarvude tüüp \verb!Nat! on lisatud, sest jäägiklassiringid nõuavad tüübitaseme naturaalarvusid.

        Kuna kõik nimetatud struktuurid ja algebralised andmetüübid on edutatavad, kaasneb nendega ka vastavate edutamise teel saadud liikide ja tüüpide kasutamise võimalus.
      \subsubsection{Hargnevad andmetüübid}\label{hargnevad}
        Kui Awfuli struktuurid ja algebralised andmetüübid on võrdlemisi sarnased Haskelli algebralistele andmetüüpidele mõningate väikeste erinevuste ja piirangutega, siis hargnevad andmetüübid on oluliselt teistsugused. Seega selgitame neid põhjalikumalt.

        Hargnevad andmetüübid on mõeldud asendama osasid üldistatud algebraliste andmetüüpide pakutavaid võimalusi, ilma samas tüübisüsteemile oluliselt keerukust lisamata. Meenutame peatükis~\ref{edutamine} toodud näiteid üldistatud algebraliste andmetüüpide rakendustest: nende abil saab konstrueerida näiteks staatilise pikkusega vektoreid, üldistatud ennikuid ja mitmemõõtmelisi staatilise suurusega tabeleid. Loetletud struktuurid ei vaja tegelikult üldistatud algebraliste andmetüüpide suurt paindlikkust, vaid järgivad väga kitsast spetsiifilist mustrit.

        Olgu meil edutatav andmetüüp nimega $D$, millel on $l$ tüübimuutujat ja $m$ andmekonstruktorit.

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!data!} $D$ $t_1$ \ldots $t_l$ {\color{helehall}\verb!=!} $C_1$ $T_{11}$ \ldots $T_{1n_1}$ {\color{helehall}\verb!|!} \ldots {\color{helehall}\verb!|!} $C_m$ $T_{m1}$ \ldots $T_{mn_m}$
          \end{tabular}
        \end{equation*}

        Selle abil konstrueeritud üldistatud algebraline andmetüüp on tihti järgmisel kujul:

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!data!} $G$ {\color{helehall}\verb!::!} $D$ $K_1$ \ldots $K_l$ {\color{helehall}\verb!->!} $L_1$ {\color{helehall}\verb!->!} \ldots {\color{helehall}\verb!->!} $L_a$ {\color{helehall}\verb!where!} \\
            \verb!  !$E_1$ {\color{helehall}\verb!::!} $U_{11}$ {\color{helehall}\verb!->!}\ldots {\color{helehall}\verb!->!} $U_{1b_1}$ {\color{helehall}\verb!->!} $G$ {\color{helehall}\verb!(!}$C_1$ $v_{11}$ \ldots $v_{1n_1}${\color{helehall}\verb!)!} $u_1$ \ldots $u_a$ \\
            \verb!  !\ldots \\
            \verb!  !$E_m$ {\color{helehall}\verb!::!} $U_{m1}$ {\color{helehall}\verb!->!}\ldots {\color{helehall}\verb!->!} $U_{mb_m}$ {\color{helehall}\verb!->!} $G$ {\color{helehall}\verb!(!}$C_1$ $v_{m1}$ \ldots $v_{mn_m}${\color{helehall}\verb!)!} $u_1$ \ldots $u_a$
          \end{tabular}
        \end{equation*}

        Tüübikonstruktori $G$ esimene argument on liigist $D$ (rakendatuna mingitele teistele liikidele juhul kui $D$ võtab argumente). Iga $D$ andmekonstruktori $C_i$ kohta luuakse üks $G$ andmekonstruktor $E_i$. Tüübimuutujad $\{u_1,\ldots,u_a,v_{i1},\ldots v_{in_i}\}$ on kõik erinevad ning argumentide tüübid $(U_{i1},\ldots,U_{ib_i})$ ei sisalda ühtegi tüübimuutujat peale nende, mida resultaattüübis mainitakse. Andmekonstruktori $E_i$ resultaattüübi esimene argument on $D$ vastav konstruktor $C_i$ rakendatuna sobivale arvule tüübimuutujatele ning ülejäänud argumendid on lihtsalt tüübimuutujad. Kõik $G$ andmekonstruktorite resultaatttüübid näevad välja identsed kui välja arvata esimene argument.

        Awful võimaldab hargnevate andmetüüpide abil asendada selliseid üldistatud algebralisi andmetüüpe, mis vastavad kõigile ülalpool loetletud kitsendustele. Ütleme, et andmetüüp $G$ \textit{hargneb} tüübi $D$ järgi. Tüüpi $G$ saab Awfulis kirja panna järgnevalt:

        \begin{equation*}
          \begin{tabular}{l}
            {\color{helehall}\verb!Branching!} $G${\color{helehall}\verb![!}$D$ $K_1$ \ldots $K_l${\color{helehall}\verb!][!}$u_1$ {\color{helehall}\verb!:!} $L_1${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $u_a$ {\color{helehall}\verb!:!} $L_a${\color{helehall}\verb!](!} \\
            \verb!  !$C_1$ $v_{11}$ \ldots $v_{1n_1}$ {\color{helehall}\verb!->!} $E_1${\color{helehall}\verb!(!}$F_{11}$ {\color{helehall}\verb!:!} $U_{11}${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $F_{1b_1}$ {\color{helehall}\verb!:!} $U_{1b_1}${\color{helehall}\verb!),!}\\
            \verb!  !\ldots{\color{helehall}\verb!,!}\\
            \verb!  !$C_m$ $v_{m1}$ \ldots $v_{mn_m}$ {\color{helehall}\verb!->!} $E_m${\color{helehall}\verb!(!}$F_{m1}$ {\color{helehall}\verb!:!} $U_{m1}${\color{helehall}\verb!,!} \ldots{\color{helehall}\verb!,!} $F_{mb_m}$ {\color{helehall}\verb!:!} $U_{mb_m}${\color{helehall}\verb!))!}
          \end{tabular}
        \end{equation*}

        Toome esimeseks hargnevate andmetüüpide näiteks staatilise pikkusega vektorid.

        \begin{verbatim}Branching Array[!Nat][T : Star](
  !Zr -> Empty_Array,
  !Next N -> Construct_Array(Head : T, Tail : Array N T))\end{verbatim}

        Esimesed kandilised sulud näitavad, millise liigi järgi hargnemine toimub. Antud juhul toimub hargnemine naturaalarvude järgi. Seejärel loetleme teised vajalikud tüübimuutujad koos liikidega: antud juhul on meil üks tüübimuutuja \verb!T!, mis tähistab vektori elementide tüüpi. Seejärel loome naturaalarvu-liigi kummagi tüübikonstruktori jaoks ühe andmekonstruktori. Nullile vastab tühi vektor; mittenullile vastab vektor, mis koosneb peast ja ühe võrra lühemast sabast.

        Nagu ka struktuuride korral on kohustuslik ette anda väljade nimed. Hargneva andmetüübi esimese tüübiargumendi fikseerimisel saame ühe kindla struktuuri ning seega on väljade küsimine alati tüübiturvaline.

        Toome teiseks näiteks üldistatud ennikud.

        \begin{verbatim}Branching Tuple[!List Star](
  !Empty_List -> Empty_Tuple,
  !Construct_List T L ->
    Construct_Tuple(Head_Tuple : T, Tail_Tuple : Tuple L))\end{verbatim}

        Hargneme üle listide. Kuna Awfulis puudub liigituletus, on tarvis märkida, et hargneme üle listide, mille elemendid on tüübid liigist \verb!Star!. Listidel on kaks konstruktorit ja ka üldistatud ennikul on kaks konstruktorit. Tühjale tüüpide listile vastab tühi ennik. Tüüpide listile, mis koosneb tüübist \verb!T! ja sabast \verb!L!, vastab ennik, mille pea on tüüpi \verb!L! ja saba on ühe võrra lühem ennik, mis koosneb tüüpidest \verb!L!.

        Hargnevate andmetüüpide peamine eelis on see, et teades esimest tüübiargumenti, näiteks teades, kas vektor on pikkusega \verb"!Zr" või \verb"!Next N", teame kohe, millise konstruktori abil on andmed konstrueeritud ja milliseid väljasid on sealt võimalik kätte saada.

        Hargnevate andmetüüpide seatavatel rangetel piirangutel on ka olulisi puudusi. Üheks lihtsaks näiteks on üldistatud \verb!Either!. Kui meil on võimalus kirjutada suvalise arvu tüüpide konjunktsiooni, tekib küsimus, kas saaksime kirjutada ka suvalise arvu tüüpide disjunktsiooni. Haskellis on see võimalik.

        \begin{verbatim}data Either' :: [*] -> * where
  Left' :: t -> Either' (t : l)
  Right' :: Either' l -> Either' (t : l)\end{verbatim}

        Paneme tähele, et see üldistatud algebraline andmetüüp ei vasta hargnevatele andmetüüpidele seatud kitsendustele. Mõlema konstruktori resultaattüübis on esimene argument mittetühi list ja väärtust tüüpi \verb!Either' []! ei ole üleüldse võimalik konstrueerida. Tegu on kasuliku andmestruktuuriga, mida Awfuli hargnevad andmetüübid ei võimalda.
    \subsection{Tüübiklassid}
      Uue tüübiklassi loomine käib võtmesõnaga \verb!Class!, millele järgneb klassi nimi, tüübimuutuja nimi ja liik, päritav klass (kui seda on), ja nimekiri meetoditest koos tüüpidega.

      \begin{verbatim}Class Functor{F : Star -> Star}(
  Fmap[T : Star, U : Star] : (T -> U) -> F T -> F U)\end{verbatim}

      Vahel on kasulikud ka ilma meetoditeta klassid. Sisuliselt on tegu predikaatidega tüüpide peal ja nad on kasulikud kirjeldamaks tüüpide omadusi. Üks lihtne näide on klass \verb!Commutative!, mille esindajat saab kirjutada märkimaks, et tüüp, mis on ring, on lisaks teatud tingimustel kommutatiivne. Kuna antud juhul ei ole tüübimuutuja nimetamine vajalik, lubab Awful selle asemele kirjutada alakriipsu.

      \begin{verbatim}Class Commutative{_ : Star}<Ring>\end{verbatim}

      Siinkohal tasub märkida, et täpselt nagu ka teiste klassidega, ei kontrollita selliste predikaatide puhul kasutaja kirjutatud klassiesindajate vastavust nõutud kitsendustele. Awful ei ole tõestusassistent ega paku võimalusi selliste omaduste tõestamiseks. See, et tüüp kuulub klassi \verb!Commutative!, ei ole garantii, et tegu on tõepoolest kommutatiivse ringiga, juhul kui programmeerija on esindajaid defineerides vea teinud.
      \subsubsection{Pärilus}
        Awful võimaldab ainult ühest pärilust. Mitmene pärilus on plaanis teostada edasise töö käigus.

        Seda, et üks klass pärib teist, märgitakse nurksulgude abil:

        \begin{verbatim}Class Finite{T : Star}<Ord>(All : List T)\end{verbatim}

        Näiteks antud juhul eeldab klass \verb!Finite! (mis lubab \verb!All! meetodi abil saada list lõpliku andmetüübi kõigist võimalikest väärtustest) klassi \verb!Ord!.
      \subsubsection{Klassi meetodite tüübikitsendused}
        Vahel on vaja kirjutada klassi, mille meetodid sisaldavad tüübikitsendusi. Hea näide on klass \verb!Mat!, mis on mõeldud üldistamaks erinevaid ruutmaatrikseid ning sisaldab endas adjunktmaatriksi, karakteristliku polünoomi, determinandi ja vektoriga korrutamise meetodeid. Tema meetodites esinevaid tüübimuutujaid on vaja kitsendada kitsendustega \verb!Ring! ja \verb!Commutative!, sest näiteks maatriksi ja vektori korrutamist ei ole võimalik defineerida, kui allolev struktuur ei ole ring, ja determinant nõuab kommutatiivset ringi.

        \begin{verbatim}Class Mat{F : !Nat -> Star -> Star}(
  Adj[N : !Nat, T : Star]<Commutative T> : F N T -> F N T,
  Adj_Det[N : !Nat, T : Star]<Commutative T> : F N T -> F N T * T,
  Characteristic[N : !Nat, T : Star]<Commutative T> :
    F N T -> Array (!Next N) T,
  Det[N : !Nat, T : Star]<Commutative T> : F N T -> T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> :
    F N T -> Array N T -> Array N T,
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> :
    Array N T -> F N T -> Array N T)\end{verbatim}
      \subsubsection{Keelde sisse ehitatud klassid}
        Viis klassi on saadaval ka ilma standardteeki importimata:

        \begin{verbatim}Class Field{T : Star}<Ring>(Inverse : T -> Maybe T)
Class Nonzero{N : !Nat}(Div' : Int -> Int)
Class Ord{T : Star}(Compare : T -> T -> Comparison)
Class Ring{T : Star}(
  Add : T -> T -> T,
  Convert : Int -> T,
  Multiply : T -> T -> T,
  Negate : T -> T)
Class Writeable{T : Star}(Write_Brackets : T -> List Char * Logical)\end{verbatim}

        Klass \verb!Ord! on sarnane Haskelli samanimelise klassiga, selle vahega, et Awfulis ei ole klassi \verb!Eq!.

        Klass \verb!Nonzero! puhul on esindaja defineeritud suvalise positiivse tüübitaseme naturaalarvu \verb"!Next N" jaoks, aga mitte nulli jaoks. Lisaks sisaldab see klass meetodit täisarvuliseks jagamiseks tüübitaseme naturaalarvuga. Selle meetodi kasutusest toome näite alamjaotises~\ref{tehtedprim}.

        Klass \verb!Writeable!, sarnaselt Haskelli klassiga \verb!Show!, on mõeldud teisendamaks andmestruktuure sõnedeks. Meetod \verb!Write_Brackets! tagastab paari sõnest ja loogikaväärtusest. Loogikaväärtus näitab, kas avaldisele on sulgusid ümber vaja või mitte sellisel juhul, kui ta on mõne teise avaldise komponent. Meetodi \verb!Write_Brackets! kaudu on teostatud avaldiste väärtustamise tulemuste kuvamine. Seetõttu peab kasutaja \verb!eval! käsklust tarvitades hoolitsema selle eest, et väärtustatava avaldise tüüp oleks klassi \verb!Writeable! esindaja.

        Klassid \verb!Ring! ja \verb!Field! on tuttavad algebrast: tegu on (mitte tingimata kommutatiivse) ringi ja korpusega. Klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu ringi elemendiks, on mõeldud defineerimaks nulli (\verb!Convert 0!) ja ühikut (\verb!Convert 1!), aga ka selleks, et oleks mugav suvalises ringis elementi täisarvulise konstandiga korrutada.
    \subsection{Definitsioonid ja esindajad}
      Nagu ka andmetüüpide ja klasside korral, ei ole definitsioonide ja esindajate omavaheline järjekord oluline.
      \subsubsection{Definitsioonid}
        Definitsioon algab võtmesõnaga \verb!Def!, millele järgneb funktsiooni nimi, tüübimuutujate nimekiri, kitsenduste nimekiri, argumentide nimekiri, tulemuse tüüp ja avaldis. Ühikfunktsiooni definitsioon näeb välja selline:

        \begin{verbatim}Def Id[T : Star](x : T) : T = x\end{verbatim}

        Toome ka ühe näite definitsioonist, kus esineb kitsendusi. Juhul, kui \verb!T! on ring, saame tüübi \verb!T! jaoks \verb!Convert! meetodiga defineerida nulli.

        \begin{verbatim}Def Zero[T : Star]<Ring T> : T = Convert 0\end{verbatim}
      \subsubsection{Tehted primitiividega}\label{tehtedprim}
        Keelde on sisse ehitatud järgmised klasside \verb!Ord!, \verb!Ring! ja \verb!Writeable! esindajad:

        \begin{equation*}
          \begin{tabular}{l|cccc}
                           & \verb!Field! & \verb!Ord! & \verb!Ring! & \verb!Writeable! \\\hline
            \verb!Char!    &              & \linnuke   &             &                  \\
            \verb!Int!     &              & \linnuke   & \linnuke    & \linnuke         \\
            \verb!Modular! & \linnuke     & \linnuke   & \linnuke    & \linnuke
          \end{tabular}
        \end{equation*}

        Tüüp \verb!Modular N! on defineeritud klasside \verb!Field! ja \verb!Ring! esindajaks ainult sellisel juhul, kui \verb!N! ei ole null ehk kuulub klassi \verb!Nonzero!. Selle põhjuseks on klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu vastava ringi elemendiks. Tüübi \verb!Modular 0! ehk tühja ringi jaoks seda meetodit defineerida ei saa.

        Lisaks on keelde sisse ehitatud kolm funktsiooni täisarvulise jagatise ja jäägi leidmiseks.

        \begin{verbatim}Div : Int -> Int -> Maybe Int
Mod : Int -> Int -> Maybe Int
Div'[N : !Nat]<Nonzero N> : Int -> Int\end{verbatim}

        Funktsioonid \verb!Div! ja \verb!Mod! annavad vastavalt täisarvulise jagamise tulemuse ja jäägi. Tulemus on tüübiturvalisuse huvides \verb!Maybe! monaadi all juhuks kui jagaja on null. Meetod \verb!Div'! puhul on jagatav tavaline täisarv, aga jagaja on positiivne tüübitaseme naturaalarv, mistõttu on garanteeritud, et nulliga jagamist ei toimu. Seda meetodit saab programmeerija kasutada juhtudel, kus ta tahab täisarvu konstandiga jagada.

        Võib tekkida küsimus, miks ei ole klassis \verb!Nonzero! analoogset meetodit \verb!Mod'!, mis leiaks täisarvulise jagamise jäägi juhul, kui jagaja on positiivne tüübitaseme naturaalarv \verb!N!. Sellise meetodi eeliseks oleks võimalus anda tulemuseks mitte \verb!Int!, vaid \verb!Modular N!. Põhjuseks, miks sellist meetodit ei ole, on see, et klassis \verb!Ring! leiduv meetod \verb!Convert!, mille abil saab täisarvu jäägiklassiringi elemendiks teisendada, täidab täpselt sama otstarvet.

        Toome siinkohal näite meetodite \verb!Div'! ja \verb!Convert! kasutusest. Algebrateegis \verb!Algebra.awf! defineeritud funktsioon \verb!Pow'! võtab argumendiks suvalise ringi elemendi \verb!x! ja mittenegatiivse täisarvu \verb!i! ning arvutab \verb!x! astmes \verb!i!. Selleks, et funktsiooni keerukus oleks lineaarse asemel logaritmiline, kasutame astme täisarvulist jagamist kahega.

        \begin{verbatim}Def Pow'[T : Star]<Ring T>(x : T, i : Int) : T =
  Match i {
    0 -> Identity,
    Default ->
      Let
        y = Pow' x (Div'{2} i),
        z = Multiply y y
      In
        Match Convert i {0 # 2 -> z, 1 # 2 -> Multiply x z}}\end{verbatim}

        Funktsiooni kutse \verb!Div'{2}! sisaldab tüübiargumendi -- antud juhul tüübitaseme naturaalarvu -- eksplitsiitset täpsustamist. Sellest räägime täpsemalt alamjaotises~\ref{typeargs}.
      \subsubsection{Esindajad}
        Esindajat deklareeritakse, sarnaselt Haskellile, sõnaga \verb!Instance!.

        \begin{verbatim}Instance Ord{Trivial}(Compare _ _ = EQ)\end{verbatim}

        Tüübi nimi, mille jaoks esindajad defineeritakse, ning vajaduse korral ka tüübimuutujad, käivad looksulgudesse. Nurksulgudes saab anda tüübimuutujate kitsendusi.

        \begin{verbatim}Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)\end{verbatim}

        Juhul, kui mõnele tüübimuutujale ei ole tarvis kitsendusi anda, saab selle asemele kirjutada alakriipsu.

        \begin{verbatim}Instance Functor{Function _}(Fmap f g x = f (g x))\end{verbatim}

        Juhul, kui tegu on ilma meetoditeta klassiga, jäetakse ära ümarsulud meetodite nimekirjaga.

        \begin{verbatim}Instance Commutative{Int}\end{verbatim}

        Awfulis on klassi esindajate üks eripära see, et meetodid tuleb kirja panna täpselt sellises järjekorras nagu nad on klassideklaratsioonis. Tegu oli otsusega, mis lähtus kontrolli teostuse lihtsusest.
    \subsection{Avaldised}
      Awfuli avaldis võib olla muutujanimi, primitiiv, funktsiooni rakendamine, lambda-avaldis, mustrisobitusavaldis või let-avaldis.

      Lisaks on keelde sisse ehitatud süntaktiline suhkur listide jaoks, mis algab märksõnaga \verb!List!. Tühja listi puhul piisabki ainult sellest märksõnast. Mittetühja listi puhul käib elementide nimekiri ümarsulgudesse ning elemendid eraldatakse komadega, näiteks \verb!List (x)! ja \verb!List (x, y)!.

        Käesolevas jaotises räägime põhjalikumalt defineerimata käitumisest, lambda-avaldistest, mustrisobitusest ja let-avaldisest.
      \subsubsection{Defineerimata käitumine}
        Defineerimata käitumist saab märkida erilise muutuja abil, mille nimi on \verb!Crash!. Sarnaselt Haskelli muutujaga \verb!undefined! on \verb!Crash! parameetriliselt polümorfne üle suvalise tüübi liigist \verb!Star! (\verb!*!). Seda saab panna suvalisse kohta avaldises veel kirjutamata kooditüki asenduseks, või luua funktsioone, mille käitumine ongi osade sisendite korral defineerimata.

        Haskelli \verb!undefined! ja Awfuli \verb!Crash! käitumine väärtustamisel on aga erinev selle tõttu, et Haskell on laisk ja Awful on agar keel. Näiteks Haskelli avaldis \verb!fst (0, undefined)! annab \verb!0!, aga Awfuli analoogne avaldis \verb!First (Pair 0 Crash)! resulteerub tulemuses \verb!Crash!.
      \subsubsection{Lambda-avaldis}
        Funktsionaalse programmeerimiskeelena sisaldab Awful loomulikult lambda-avaldisi. Mustrisobituse võimalust funktsiooni argumentides ei ole veel teostatud, aga seda on tulevikus plaanis lisada. Süntaks on sarnane Haskelli omaga, aga ei ole vajalik \verb!\! sümbol enne muutujanime. Toome siinkohal näite lambda-avaldist kasutavast funktsioonist.

        \begin{verbatim}Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T =
  Fmap (z -> Multiply z y) (Inverse x)\end{verbatim}

        Süntaktiline suhkur korraga kahe muutuja andmiseks Awfulis puudub. Kui Haskellis saab kirjutada \verb!\ x y -> x!, siis Awfulis peab kirjutama \verb!x -> y -> x!.
      \subsubsection{Mustrisobitus}\label{match}
        Mustrisobitus töötab tähtede, täisarvude, jäägiklassiringi elementide ja algebraliste andmetüüpide peal.

        \begin{verbatim}Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}\end{verbatim}

        Saab kirjutada ka \verb!Default! juhu, mida kasutatakse, kui ükski eelnev variant ei sobinud. See vaikevalik tuleb alati kirjutada mustrisobituse viimaseks juhuks.

        \begin{verbatim}Def Max[T : Star]<Ord T>(x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Turvalisuse tagamiseks kontrollitakse iga \verb!Match! avaldise puhul, kas kõik võimalikud juhud on käsitletud. Kattuvad või puuduvad juhud annavad vea. See tähendab, et \verb!Default! juhtum on kohustuslik tähtede ja täisarvude mustrisobituses ning ka jäägiklassiringi elementide ja algebraliste andmetüüpide jaoks juhul, kui eelnevalt ei ole kõiki võimalikke harusid käsitletud.

        Erinevalt Haskellist ei luba Awful kirjutada keerulisema struktuuriga mustrisobitust, näiteks sobitada sama \verb!Match! avaldisega tühja, 1-elemendilist ja 2-elemendilist listi. Sellise otsuse põhjuseks oli teostuse lihtsus.

        Samuti ei luba Awful \verb!Match! avaldist üle struktuuri (selle asemel tuleb kasutada väljade nimesid, ja tulevikus on plaanis lisada võimalus teha struktuuride mustrisobitust otse funktsiooni argumendis) ega üle hargneva andmetüübi (selle asemel on võimalik kasutada tüübiklasse viisil, mis on kirjeldatud jaotises~\ref{tyybiklassihakk}).
      \subsubsection{Let-avaldis}\label{letavaldis}
        Awfulis on olemas järjestikune let-avaldis. Let-avaldise lokaalsed definitsioonid peavad olema kirja pandud sellises järjekorras, et iga definitsioon võib kasutada ainult eelnevaid definitsioone aga mitte iseennast ega järgnevaid definitsioone. Toome näite let-avaldise kasutusest standardteegis. Funktsioon \verb!Brackets! võtab argumendiks klassi \verb!Writeable! esindaja ning annab tulemuseks sõne, mis on olenevalt vajadusest sulgudega ümbritsetud või mitte.

        \begin{verbatim}Def Brackets[T : Star]<Writeable T>(x : T) : List Char =
  Let
    y = Write_Brackets x
  In
    Match Second y {
      False -> First y,
      True -> Cat (Lift "(") (Cat (First y) (Lift ")"))}\end{verbatim}

        Let-avaldised on Awfulis süntaktiline suhkur, mis teisendatakse parsimise järel lambda-avaldiste rakendamise jadaks. Viime näitena läbi kahte lokaalset definitsiooni sisaldava let-avaldise teisenduse.

        \begin{verbatim}Let f x = Add x 1, y = 2 In f y\end{verbatim}

        Alguses viiakse let-avaldis kujule, kus iga definitsioon on eraldi let-avaldises. Peame meeles, et definitsioon \verb!f x = Add x 1! tähendab tegelikult \verb!f = x -> Add x 1!.

        \begin{verbatim}Let f = x -> Add x 1 In Let y = 2 In f y\end{verbatim}

        Seejärel teisendame iga let-avaldise \verb!Let! $x$ \verb!=! $e_0$ \verb!In! $e_1$ kujule \verb!(!$x$ \verb!->! $e_1$\verb!)! $e_0$.

        \begin{verbatim}(f -> (y -> f y) 2) (x -> Add x 1)\end{verbatim}

        Awfuli let-avaldised ei luba defineerida polümorfseid funktsioone. Põhjuseid on lähemalt selgitatud alamjaotises~\ref{deftyyp}. Seni aga toome näite polümorfsest let-avaldisest, mida Awfuli tüübikontroll ei luba.

        \begin{verbatim}Def Bug : Char * Int = Let Id x = x In Pair (Id "A") (Id 0)\end{verbatim}

        Antud näide töötaks juhul kui lokaalselt defineeritud funktsiooni \verb!Id! kasutataks kas ainult tähtede või ainult täisarvude peal. Kasutaja on aga eeldanud, et \verb!Id! on parameetriliselt polümorfne ühikfunktsioon, mis töötab suvalise tüübi peal, ja on seda kasutanud nii tähe kui ka täisarvu peal. Kuna let-avaldise all defineeritud funktsioonid on monomorfsed, üritab tüübikontrollija unifitseerida tüüpe \verb!Char! ja \verb!Int! ning tulemuseks on tüübiviga.
      \subsubsection{Tüübiargumentide eksplitsiitne edastamine}\label{typeargs}
        On juhtumeid, kus tüübituletus ei ole võimalik ja ei aita ka standartse Haskelli stiilis tüübiannotatsioonid avaldiste sees, näiteks \verb!show (read "0" :: Int)!. Awful võimaldab avaldises esineva polümorfse funktsiooni tüüpi täpsustada eksplitsiitsete tüübiargumentide abil. Pöördume tagasi jaotises~\ref{tyybiklassidawfulis} toodud näite juurde meetodist, mille teostust ei ole võimalik tüübist tuletada.

        \begin{verbatim}Class Nonzero{N : !Nat}(Div' : Int -> Int)\end{verbatim}

        Kuna Awful võimaldab meetodi teostust eksplitsiitselt täpsustada, ei ole tüübi mittetuletatavus enam takistuseks meetodi kasutamisele. Meetodi teostust täpsustatakse Awfulis tüübiga loogeliste sulgude vahel, näiteks antud juhul oleks kahega jagamiseks vaja valida meetodi \verb!Div'! teostus tüübi \verb!2! jaoks: \verb!Div'{2}!.

        Paneme tähele, et meetod \verb!Div'! võib olla kasutuses mitte ainult otse, vaid ka kaudselt mõne muu funktsiooni kaudu.

        \begin{verbatim}Def Div_5[N : !Nat]<Nonzero N> : Int = Div'{N} 5\end{verbatim}

        Juhul, kui kutsutakse funktsiooni \verb!Div_5!, ei ole võimalik tuletada, mis on tüübimuutuja \verb!N! väärtus, ja seega ei ole võimalik tuletada ka seda, millist meetodi \verb!Div'! teostust kasutab \verb!Div'{N}!. Seega pakub Awful võimalust täpsustada mitte ainult meetodi teostust, vaid ka tavalisi tüübimuutujaid, näiteks \verb!Div_5[2]!.

        Kui funktsioon on mõne klassi meetod ja on lisaks parameetriliselt polümorfne, näiteks \verb!Fmap!, saab kasutaja ise valida, kas ta spetsifitseerib ainult meetodi teostuse, ainult tavalised tüübimuutujad või mõlemad. Loomulikult on alati ka võimalus tüübiargumente mitte eksplitsiitselt edastada, kui tegu on avaldisega, mille peal on võimalik tüübituletus.

        \begin{verbatim}Fmap (Add 1) List
Fmap{List} (Add 1) Empty
Fmap[Int, Int] Id List
Fmap{List}[Int, Int] Id Empty\end{verbatim}

        Vaatleme, kuidas Awfuli tüübiargumentide eksplitsiitne edastamine võrdleb teiste keelte omaga.

        Standartne Haskell ei võimalda tüübiargumentide eksplitsiitset täpsustamist, aga see on võimalik kasutades laiendust \verb!TypeApplications!~\cite{Gla}. Tüübiargumente saab anda sümboliga \verb!@!, näiteks \verb!show (read @Int "0")!. Haskell lubab edastada ainult osad tüübiargumendid. Awfuli puhul tuleb edastada kõik tüübiargumendid või mitte ühtegi ja ainsaks erandiks on tüübiklassi meetodi teostuse spetsifitseerimine, mida saab teha sõltumatult ülejäänud tüübimuutujate täpsustamisest.

        Awful võtab tüübiargumentide edastamise süntaksis eeskuju hoopis sellistest keeltest nagu Visual Basic~\cite{Vis} ja C\#~\cite{C}, kus polümorfsete ehk geneeriliste (ing. k. \textit{generic}) funktsioonide kasutamisel on tüübiparameetrite nimekiri sulgude sees ja eraldatud komadega. Käesoleva töö arutori arvates on selline süntaks loetavam ja kasutajasõbralikum, sest tüübiargumendid ja tavalised argumendid on visuaalselt paremini eristatud.
    \subsection{Tüübiklasside kasutamine tüübimuutujate mustrisobituseks}\label{tyybiklassihakk}
      Vaatlesime, kuidas luua hargnevate andmetüüpide abil staatilise pikkusega vektoreid ja üldistatud ennikuid. Ainult andmestruktuuride deklareerimisest aga ei piisa -- soovime kirjutada funktsioone, mis nende andmestruktuuride peal töötaks. Näiteks tahame teostada \verb!Fmap! meetodit vektorite jaoks.

      Vektorite struktuur on sarnane listidele, selle vahega, et pikkus on tüübi osa. Meenutame, kuidas on teostatud listide \verb!Fmap!.

      \begin{verbatim}Instance Functor{List}(
  Fmap f x =
    Match x {
      Empty_List -> List,
      Construct_List y z -> Construct_List (f y) (Fmap f z)})\end{verbatim}

      Oleks loogiline analoogselt teostada ka vektorite \verb!Fmap! meetodit. Haskellis ongi see võimalik.

      \begin{verbatim}instance Functor (Array n) where
  fmap f x =
    case x of
      Empty_Array -> Empty_Array,
      Construct_Array y z -> Construct_Array (f y) (fmap f z)\end{verbatim}

      Awful aga sellist teostust ei luba, sest \verb!Array! on hargnev andmetüüp ja Awfuli \verb!Match! avaldis töötab ainult tavaliste algebraliste andmetüüpide mitte hargnevate andmetüüpide peal. Ning ka Haskellis on osadel juhtudel \verb!case! avaldise kasutamisele takistusi. Üks näide on klassi \verb!Applicative! meetod \verb!pure!, mis on tüüpi \verb!t -> f t!. Antud meetodil ei ole ühtegi argumenti, mille peal mustrisobitust teostada.

      Üks variant oleks mustrisobitus tüübimuutuja \verb!n! peal, mis tähistab vektori pikkust. Ei Haskell ega Awful ei toeta hetkel sellist lähenemist. Seni saab aga ajutise lahendusena kasutada vahendit, mis on keeles juba olemas -- tüübiklasse.

      \begin{verbatim}Class Functor_Array{N : !Nat}(
  Fmap_Array[T : Star, U : Star] : (T -> U) -> Array N T -> Array N U)
Instance Functor_Array{!Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(
  Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)\end{verbatim}

      Loome abiklassi \verb!Functor_Array! üle naturaalarvulise tüübimuutuja. See sisaldab sama meetodit mis \verb!Functor!, ainult et mitte suvalise funktori vaid vastava pikkusega vektori jaoks. Seejärel loome abiklassi esindajad nii nulli kui ka mittenulli jaoks. Lõpuks defineerime vektori klassi \verb!Functor! esindajaks, kasutades \verb!Functor_Array! meetodit.

      Sellel lähenemisel on kaks peamist puudust. Esiteks peab programmeerija kirjutama palju abiklasse. Teiseks resulteeruvad need abiklassid ebavajalikes kitsendustes.

      \begin{verbatim}Def Square_Array[N : !Nat, T : Star]<Functor_Array N, Ring T> :
  Array N T -> Array N T =
    Fmap Square\end{verbatim}

      Siinkohal oleks kitsendus \verb!Functor_Array N! tegelikult täiesti ebavajalik. Kõik naturaalarvulised tüübid on klassi \verb!Functor_Array! esindajad ning seega tüübimuutuja \verb!N! võiks antud juhul täiesti kitsendamata olla. Oleks hea, kui oleks võimalik vektorite ja teiste hargnevate andmetüüpide funktsioone teostada otse tüübimuutuja peal mustrisobitust tehes -- ning tulevikus on plaanis Awfulit vastavalt täiendada. Sellest ideest räägime põhjalikumalt jaotises~\ref{eemaldadatyybiklassihakk}.

      Toome veel ühe näite sellest, kuidas kasutada tüübiklasse kirjutamaks funktsioone, mis töötavad hargnevate andmetüüpide peal. Järgnev kood võimaldab defineerida üldistatud ennikud klassi \verb!Ord! esindajaks:

      \begin{verbatim}Class Ord_Tuple{L : !List Star}(
  Compare_Tuple : Tuple L -> Tuple L -> Comparison)
Instance Ord{Tuple L}<Ord_Tuple L>(Compare = Compare_Tuple)
Instance Ord_Tuple{!Empty_List[Star]}(Compare_Tuple _ _ = EQ)
Instance Ord_Tuple{!Construct_List[Star] T L}<Ord T, Ord_Tuple L>(
  Compare_Tuple x y =
    Compare
      (Pair (Head_Tuple x) (Tail_Tuple x))
      (Pair (Head_Tuple y) (Tail_Tuple y)))\end{verbatim}

      Kitsendus \verb!Ord_Tuple L! kannab teavet selle kohta, et kõik listi \verb!L! kuuluvad tüübid kuuluvad klassi \verb!Ord!. Seda kitsendust, erinevalt kõigi naturaalarvude peal kehtivatest kitsendustest, ei oleks enam võimalik lihtsalt ära jätta.
  \peatykk{Teostuse detailid}
    Awfuli interpretaator on kirjutatud Haskellis. Interpretaator on võrdlemisi tüüpilise arhitektuuriga, koosnedes lekserist, parserist, süntaktilist suhkrut eemaldavast vahesammust, nimekontollijast, tüübikontrollijast ja väärtustajast. Lisaks on eraldi moodul, mis vastutab kasutajaliidese ja impordite eest.
    \subsection{Parser}
      Awful kasutab aplikatiivset parsimist. Selles jaotises refereerime lühidalt monaadilist~\cite{Mon} ja aplikatiivset~\cite{App} parsimist ning selgitame, kuidas Awfuli parser on teostatud.
      \subsubsection{Parserite andmetüüp}\label{parserityyp}
        Selleks, et saaks kasutada aplikatiivset või monaadilist parsimist, tuleb kirjutada parserite andmetüüp. Toome siinkohal parserite andmetüübi, mis lisaks erinevatele võimalikele väljundtüüpidele ei piira ka sisendi tüüpi ega veateadete andmise viisi.

        \begin{verbatim}newtype Parser s m t = Parser {parser :: s -> m (t, s)}\end{verbatim}

        Selline parser võtab sisendteksti tüüpi \verb!s! ning annab tulemuseks väljundi tüüpi \verb!t! ja parsimata jäänud osa sisendekstist, kusjuures väljund antakse monaadi \verb!m! all.

        Sisend \verb!s! võib olla tähtede nimekiri, aga võib olla ka mõni keerulisem struktuur. Praktikas on oluliselt lihtsam parsida teksti, mille peal on eelnevalt tehtud leksiline analüüs, et parser ei peaks tegelema selliste detailidega nagu nimede ja arvude tähthaaval kokku korjamine või kommentaarid. Lisaks parsitavale tekstile võib olla kasulik kaasas kanda ka lisainfot, näiteks teavet selle kohta, kui kaugele on teksti ebaõnnestunud parsimiskatsete käigus ette vaadatud.

        Monaad \verb!m! on vajalik selle tõttu, et parsimine võib ka ebaõnnestuda või rohkem kui ühe tulemuse anda. See monaad võib olla näiteks \verb!Maybe! (juhul kui meid ei huvita, miks täpselt parsimine ebaõnnestus) või \verb!Either e! (juhul kui vajame veateateid tüüpi \verb!e!). Aga monaad \verb!m! võib olla ka näiteks list, juhul kui on tarvis mitmest parsimist.
      \subsubsection{Monaadiline parsimine}
        Parsereid saab vaadelda monaadidena~\cite{Mon}.

        Juhul, kui \verb!m! on funktor, on tüüp \verb!Parser s m! samuti funktor. Intuitiivselt tähendab see, et tüüpi \verb!t! väljundiga parseri puhul saame väljundile eduka parsimise korral rakendada funktsiooni tüüpi \verb!t -> u! ja saame niiviisi parseri väljundtüübiga \verb!u!.

        \begin{verbatim}instance Functor m => Functor (Parser s m) where
  fmap f (Parser p) = Parser (\x -> first f <$> p x)\end{verbatim}

        Funktsioon \verb!first! moodulist \verb!Data.Bifunctor! rakendab funktsiooni paari (või mõne muu bifunktori) esimesele elemendile.

        Juhul, kui \verb!m! on monaad, on tüüp \verb!Parser s m! samuti monaad. Operaator \verb!>>=!, mis võtab argumendiks parseri \verb!p! ja funktsiooni \verb!f!, rakendab sisendtekstile parserit \verb!p! ning, saades tulemuseks väärtuse \verb!r! ja teksti \verb!x!, parsib teksti \verb!x! parseriga \verb!f r!. See tähendab, et monaadilise parsimise puhul saab parsimise edasine käik sõltuda parsimistulemusest.

        Meetod \verb!return! teeb väärtusest \verb!r! parseri, mis ei muuda sisendteksti ja annab parsimise tulemuseks sellesama väärtuse \verb!r!.

        \begin{verbatim}instance Monad m => Monad (Parser s m) where
  Parser p >>= f = Parser (p >=> \(r, x) -> parser (f r) x)
  return r = Parser (\x -> return (r, x))\end{verbatim}

        Operaator \verb!>=>!, mis on defineeritud teegis \verb!Control.Monad!, käitub järgmiselt:

        \begin{verbatim}p >=> f = \x -> p x >>= f\end{verbatim}

        Monaad võimaldab muuhulgas parserite järjestikust kombineerimist. Juhul, kui soovime parsida teksti alguses parseriga \verb!p!, mille väljund on tüüpi \verb!t!, ja seejärel parsida ülejäänud teksti parseriga \verb!q!, mille väljund on tüüpi \verb!u!, ning võtta tulemused kokku üheks väärtuseks funktsiooni \verb!f :: t -> u -> v! abil, saab seda teha parseriga \verb!ap (fmap f p) q!. Funktsioon \verb!ap! on tüüpi \verb!m (t -> u) -> m t -> m u!, kus \verb!m! on monaad. 

        Lisaks parserite järjestikusele kombineerimisele on tarvis ka võimalust kahe või enama parseri vahel valida. Seda on võimalik teha klassi \verb!MonadPlus! abil, mis on \verb!Monad! alamklass. \verb!MonadPlus! sisaldab assotsiatiivset operatsiooni \verb!mplus! ja selle operatsiooni ühikut \verb!mzero!.

        \begin{verbatim}instance MonadPlus m => MonadPlus (Parser s m) where
  mplus (Parser p) (Parser q) = Parser (\x -> mplus (p x) (q x))
  mzero = Parser (\_ -> mzero)\end{verbatim}

        Meetod \verb!mplus! võtab argumendiks kaks parserit ja üritab rakendada esimest. Kui esimene parser ebaõnnestub, üritatakse rakendada teist. \verb!mzero! on parser, mis alati ebaõnnestub.
      \subsubsection{Aplikatiivne parsimine}\label{appars}
        Iga tüübikonstruktor, mis on monaad, on ka aplikatiivne funktor. Ka parserid on aplikatiivsed funktorid~\cite{App}.

        \begin{verbatim}instance Monad m => Applicative (Parser s m) where
  Parser p <*> Parser q = Parser (p >=> \(f, x) -> first f <$> q x)
  pure r = Parser (\x -> pure (r, x))\end{verbatim}

        Loetleme siinkohal \verb!Applicative! klassi esindajate jaoks saada olevaid operaatoreid, mida saab kasutada parserite järjestikuseks kompositsiooniks.

        \begin{itemize}
          \item
            \begin{verbatim}(<$>) :: Functor f => (t -> u) -> f t -> f u\end{verbatim}

            Tegu on meetodi \verb!fmap! operaatorkujuga.
          \item
            \begin{verbatim}(<*>) :: Applicative f => f (t -> u) -> f t -> f u\end{verbatim}

            Parserite järjestikust kompositsiooni \verb!ap (fmap f p) q! on aplikatiivse funktori operaatorite abil võimalik kirja panna kui \verb!f <$> p <*> q!.
          \item
            \begin{verbatim}(<$) :: Functor f => t -> f u -> f t\end{verbatim}

            See \verb!fmap! sarnane operaator on kasulik juhul, kui meid huvitab teiseks argumendiks oleva parseri õnnestumine või ebaõnnestumine, aga mitte selle tulemus.
          \item
            \begin{verbatim}(<*) :: Applicative f => f t -> f u -> f t
(*>) :: Applicative f => f t -> f u -> f u\end{verbatim}

            Need \verb!(<*>)! sarnased operaatorid eiravad vastavalt teise ja esimese parseri parsimistulemust. Operaatorid \verb!<$!, \verb!<*! ja \verb!*>! on kasulikud parsimaks näiteks võtmesõnu, operaatoreid, sulgusid ja eraldajaid.
        \end{itemize}

        Klassi \verb!MonadPlus! asemel saab erinevate alternatiivide vahel valimiseks kasutada ka klassi \verb!Alternative!, mis eeldab klassi \verb!Applicative!. Klass \verb!Applicative! on peaaegu identne klassiga \verb!MonadPlus!. Ainsaks sisuliseks vaheks on see, et kui \verb!MonadPlus! eelduseks on \verb!Monad!, siis \verb!Alternative! eelduseks on \verb!Applicative!, mis on vähem piirav eeldus.

        Klassis \verb!Alternative! on funktsiooni \verb!mplus! ja konstandi \verb!mzero! asemel samade tüüpidega operaator \verb!<|>! ja konstant \verb!empty!.

        \begin{verbatim}instance (Alternative m, Monad m) => Alternative (Parser s m) where
  Parser p <|> Parser q = Parser (\x -> p x <|> q x)
  empty = Parser (\_ -> empty)\end{verbatim}

        Aplikatiivne parsimine on vähem võimas kui monaadiline. Komponeerides parsereid operaatori \verb!>>=! abil võib teise parseri käitumine oleneda esimese parseri tagastatud parsimistulemusest; aplikatiivse parsimise korral ei ole see võimalik. Siiski on aplikatiivne parsimine paljudeks rakendusteks piisav ning üks oluline eelis aplikatiivselt kirjutatud parserite juures on see, et parseri teostus näeb välja väga sarnane grammatika formaalse spetsifikatsiooniga.
      \subsubsection{Awfuli parseri teostus}
        Awful kasutab aplikatiivset parsimist. Awfuli parser järgib alamjaotises~\ref{parserityyp} kirjeldatud mustrit, et parser on funktsioon, mis tagastab monaadi all paari parsimistulemisest ning järelejäänud sisendist. Võtame kasutusele tüübisünonüümi \verb!Parser'!, mis täpsustab konkreetse sisendtüübi ja veateadete andmise viisi.

        \begin{verbatim}type Parser' = Parser State (Either Location)\end{verbatim}

        Sisendiks on tüüp nimega \verb!State!, mis koosneb lekseri väljastatud süntaksiüksuste (ing. k. \textit{token}) nimekirjast ja lisaks asukohast, mis ütleb, kui kaugele on teksti ette vaadatud. See teave on vajalik andmaks võimalikult täpse asukohaga veateateid.

        \begin{verbatim}data State = State Tokens Location\end{verbatim}

        Tulemus antakse \verb!Either Location! monaadi all. Veateate tüübiks on seega \verb!Location!, mis ütleb, kust alates ei õnnestunud teksti enam edasi parsida.

        Parserite järjest komponeerimine (ning seega ka klassi \verb!Applicative! teostus) on täpselt sama mis jaotises~\ref{appars}. Küll aga muudab vigade asukohtade leidmine keerulisemaks valiku alternatiivide vahel~\cite{Err}. Selleks, et tüübisünonüümi \verb!Parser'! saaks defineerida klassi \verb!Alternative! esindajaks, mis varjutaks tüübi \verb!Parser! vastavat esindajat, kasutame laiendusi \verb!FlexibleInstances!, \verb!OverlappingInstances! ja \verb!TypeSynonymInstances!. Valik kahe võimaliku parsimisviisi vahel ja alati ebaõnnestuv parser on Awfuli jaoks teostatud järgnevalt:

        \begin{verbatim}instance Alternative Parser' where
  Parser p <|> Parser q =
    Parser
      (\x ->
        case p x of
          Left l -> q (update_location x l)
          Right r -> Right r)
  empty = Parser (\(State _ l) -> Left l)\end{verbatim}

        Kui toimub valik kahe alternatiivi vahel, proovime enne esimest parserit. Juhul, kui see õnnestub, tagastamegi vastava tulemuse. Juhul, kui esimene parser ebaõnnestub, tunduks loomulik lihtsalt samale sisendile teist parserit rakendada. Siis aga tekib probleem veateadete asukohtadega. Juhul, kui esimene parser jõuab kaugemale kui teine, aga mõlemad ebaõnnestuvad, ütleks selline süsteem, et viga juhtus varem kui tegelikult. Näiteks kui grammatika lubab sõnet \verb!"Catamorphism"! või \verb!"Category"!, aga parser saab sõne \verb!"Catastrophe"!, tahaksime kasutajale öelda, et viga juhtus tähemärgil \verb!5!, kus ebaõnnestus sõne \verb!"Catamorphism"! parsimine, mitte tähemärgil \verb!4!, kus ebaõnnestus sõne \verb!"Category"! parsimine.

        Ka kahest vea-asukohast suurima leidmine ei aita. Oletame, et tahame parsida teksti reegliga \verb!many p <* end!, kus \verb!p! parsib sõnet \verb!"aa"! ja \verb!end! nõuab, et kogu tekst oleks parsitud. Siis teksti \verb!"ab"! korral antaks vea asukohaks \verb!1! mitte \verb!2!. Parser \verb!p! ebaõnnestub tähemärgil \verb!2!. Parser \verb!many p! õnnestub, andes tulemuseks tühja listi, ja jätab jäägiks kogu teksti \verb!"ab"!. Rakendades sellele parserit \verb!end!, mis ei mäleta, kui kaugele parser \verb!p! jõudis, tulebki välja, nagu oleks viga kohe teksti alguses, kuigi tegelikult jõudis parser \verb!p! kaugemale.

        Selleks jätabki Awfuli parser alati meelde kõige suurema asukoha, kuhu mõnel katsel edukalt jõuti, ning see asukoht väljastataksegi programmeerijale veateates. Uue kõige kaugema vea-asukoha arvutamist teostab funktsioon \verb!update_location!.

        \begin{verbatim}update_location :: State -> Location -> State
update_location (State a b) c = State a (max b c)\end{verbatim}
    \subsection{Nimekontroll}
      Awful paneb nimekontrollil kõik nimed ühte keskkonda. Iga faili läbib nimekontrollija kaks korda. Esimesel läbimisel korjatakse keskkonda kõik globaalsed nimed:

      \begin{itemize}
        \item
          Andmetüüpide nimed
        \item
          Andmekonstruktorite nimed
        \item
          Struktuuride ja hargnevate andmetüüpide väljade nimed
        \item
          Klasside nimed
        \item
          Meetodite nimed
        \item
          Definitsioonide nimed
      \end{itemize}

      Teisel läbimisel kontrollitakse lokaalseid nimesid:

      \begin{itemize}
        \item
          Iga andmetüübi jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest ja teineteisest.

          \begin{itemize}
            \item
              Iga hargneva andmetüübi haru jaoks kontrollitakse, kas kõik antud harus sisse toodud tüübimuutujate nimed on erinevad globaalsetest nimedest, kogu hargneva andmetüübi jaoks kehtivatest tüübimuutujatest ja teineteisest.
          \end{itemize}
        \item
          Iga klassi jaoks kontrollitakse, kas klassi päises deklareeritud tüübimuutuja on erinev globaalsetest nimedest.

          \begin{itemize}
            \item
              Iga meetodi jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest, klassi päises deklareeritud tüübimuutujast ja teineteisest.
          \end{itemize}
        \item
          Iga definitsiooni ja esindaja jaoks kontrollitakse, kas kõik tüübimuutujate nimed on erinevad globaalsetest nimedest ja teineteisest.

          \begin{itemize}
            \item
              Iga avaldise jaoks kontrollitakse, kas iga uus sisse toodud lokaalne muutuja on erinev teistest antud skoobis kehtivatest nimedest.

              \begin{itemize}
                \item
                  Funktsiooni rakendamise korral kontrollitakse seda tingimust eraldi funktsiooni jaoks ja seejärel argumendi jaoks.
                \item
                  Lambda-avaldise korral kontrollitakse, kas muutuja nimi on erinev teistest antud skoobis kehtivatest nimedest. Seejärel kontrollitakse lambda-avaldise keha uue keskkonna all, mis on saadud vanast keskkonnast vastava muutuja lisamise teel.
                \item
                  Mustrisobitus-avaldise korral kontrollitakse sobitatav avaldis. Seejärel kontrollitakse kõik harud.

                  \begin{itemize}
                    \item
                      Iga haru jaoks kontrollitakse, kas mustrisobituse jaoks sisse toodud muutujate nimed on erinevad teistest antud skoobis kehtivatest nimedest ja teineteisest.
                    \item
                      Haru resultaadiks olevat avaldist kontrollitakse uues keskkonnas, kuhu on lisatud ka mustrisobituse käigus sisse toodud lokaalsete muutujate nimed.
                  \end{itemize}
              \end{itemize}
          \end{itemize}
      \end{itemize}
    \subsection{Tüübikontroll}
      Awfuli fail koosneb andmetüüpide deklaratsioonidest, klasside deklaratsioonidest ning definitsioonidest, sellises järjekorras. Kirjeldame, kuidas Awfuli tüübikontrollija neid keelekonstruktsioone käitleb.
      \subsubsection{Andmetüübid}
        Alustuseks sorteerib tüübikontrollija kõik failis esinevad andmetüübid edutatavateks ja mitteedutatavateks. Seejärel kontrollitakse ja kogutakse kogu vajalik teave alguses edutatavate ja seejärel mitteedutatavate andmetüüpide kohta. Selline läbimise järjekord on loogiline, sest edutatav andmetüüp ei tohi sõltuda ühestki mitteedutatavast andmetüübist, samas kui mitteedutatud andmetüübid võivad kasutada edutatavaid andmetüüpe nii tavalisel kui ka edutatud kujul.

        Nii edutatavad kui ka mitteedutatavad andmetüübid läbitakse kaks korda. Kuna andmetüübid võivad teineteisest sõltuda, ei ole võimalik andmekonstruktorite argumentide tüüpide korrektsust kontrollida ühe läbimisega, sest selleks on tarvis teavet kõigi andmetüüpide kohta.

        Esimesel läbimisel kontrollitakse, kas tüübimuutujate liigid on korrektsed. Kogutakse kokku teave tüübikonstruktorite liikide kohta. Ühtlasi lisatakse väärtustamiskeskkonda kõik andmekonstruktorid ja väljade nimed (kuigi nende tüüpide korrektsust kontrollitakse alles teise läbimise käigus).

        Hargnevate andmetüüpide puhul kontrollitakse lisaks tüübimuutujate liikide korrektsusele ka seda, et andmetüüp hargneks üle mõne liigi, mis on edutatud algebraline andmetüüp, ning et oleks kirjas täpselt üks haru iga vastava liigi tüübikonstruktori jaoks.

        Teisel läbimisel, kui meil on juba olemas info kõigi tüüpide ja liikide kohta, kontrollitakse, kas andmestruktuuride väljade tüübid on korrektsed. Tüüpimiskeskkonda lisatakse andmekonstruktorite ja väljade tüübid.
      \subsubsection{Klassid}
        Andmetüüpide järel läbib Awfuli tüüpija klassid, kuna klassid kasutavad andmetüüpe aga mitte vastupidi. Klasse tuleb samuti läbida kaks korda, sest klasside meetodid võivad sisaldada kitsendusi ning seega on meetodeid kontrollides vaja teavet ka kõigi teiste klasside kohta.

        Klasside esimesel läbimisel kontrollitakse, et liigid, üle mille klassid on deklareeritud, oleks korrektsed, ning kogutakse kokku teave klasside liikide kohta. Kogutakse kokku pärilust puudutav teave ning kontrollitakse, et ei esineks ringpärilust.

        Iga meetodi jaoks kontrollitakse esimesel läbimisel, et tüübimuutujate liigid ja meetodi tüüp oleks korretksed.

        Teisel läbimisel kontrollitakse, et klassid päriks ainult sama liiki klasse. Seda tuleb teha teisel läbimisel, kuna Awful ei nõua klasside kirja panemist pärilushierarhia järjekorras ja seega on päritavate klasside liikide sobivuse tuvastamiseks vaja enne koguda kokku kõigi klasside info.

        Lisaks kontrollitakse teisel läbimisel meetodite kitsendusi, ehk seda, et kitsendused oleks rakendatud sobivat liiki tüübiparameetritele. Pärast meetodi kitsenduste kontrollimist lisatakse meetodi tüüp tüüpimiskeskkonda.
      \subsubsection{Definitsioonid, esindajad, avaldised ja tüübituletus}\label{deftyyp}
        Andmetüüpide ja klasside järel liigub tüübikontrollija definitsioonide ja esindajate juurde. Definitsioonid ja esindajad kontrollitakse viimasena, sest nad kasutavad nii andmetüüpe kui ka klasse, samas kui andmetüübid ja klassid ei ole definitsioonidest kuidagi mõjutatud.

        Ka definitsioonid ja esindajad läbitakse kaks korda, sest võib esineda rekursiooni ning avaldise tüübikontrolliks on tarvis teada kõigi definitsioonide tüüpe. Kitsenduste kontrolli jaoks on vaja teada, milliseid esindajaid programmis leidub.

        Definitsioonide esimesel läbimisel kontrollitakse, et tüübimuutujate liigid ja kitsendused ning definitsiooni tüüp oleks korrektsed. Tüübikeskkonda lisatakse teave definitsiooni tüübi kohta.

        Esindajate esimesel läbimisel tagatakse, et ei oleks deklareeritud korduvaid esindajaid. Iga esindaja puhul kontrollitakse esiteks, et klass ja tüübikonstruktor, millele üritatakse esindajat kirjutada, tõepoolest eksisteerivad. Kontrollitakse, kas tüüp, mida programmeerija üritab klassi esindajaks defineerida, on antud klassi jaoks õiget liiki. Kontrollitakse, et esindajas leiduks õiges järjekorras kõik klassi meetodid.

        Definitsioonide ja esindajate teisel läbimisel tüübitakse avaldised, kasutades esimesel läbimisel kogutud teavet definitsioonide tüüpide ning programmis leiduvate esindajate kohta.

        Lisaks kontrollitakse teisel läbimisel, et kirjutatud esindajad rahuldaks pärilussuhteid. Juhul, kui tüüp $T$ on teatud kitsendustel klassi $C$ esindaja ning $C$ on klassi $B$ alamklass, siis tüüp $T$ peab samadel või nõrgematel kitsendustel olema ka klassi $B$ esindaja.

        Awful võimaldab parameetrilist polümorfismi. Sarnaselt Haskelliga~\cite{Has} ei nõua Awful polümorfsete funktsioonide kutsel tüübiargumentide eksplitsiitset edastamist. Selle tõttu on vajalik tüübituletus.

        Avaldise tüüpimisel koostab Awful kaks võrrandisüsteemi. Esimene võrrandisüsteem koosneb tüüpide paaridest ja tähistab võrdusi tüüpide vahel. Teine võrrandisüsteem koosneb sõnede ja tüüpide paaridest ning tähistab kitsendusi. Kirjeldame lühidalt, kuidas Awfuli interpretaator avaldisi tüübib ja võrrandisüsteemid koostab. Olgu tüübitava avaldise tüübiks~$T$.

        \begin{itemize}
          \item
            Primitiivide korral lisatakse süsteemi võrrand, et $T$ on ekvivalentne vastava primitiivi tüübiga.
          \item
            Muutujanime $x$ korral otsitakse nimi tüüpimiskeskkonnast üles. Juhul, kui seda ei leita, antakse kasutajale veateade, et muutuja $x$ vastavas asukohas on defineerimata. Kui $x$ leitakse tüüpimiskeskkonnast ning tema tüüp on $U$, kusjuures $U$ võtab $n$ tüübimuutujat, tuuakse sisse $n$ uut tüübimuutujat $V_1$ \ldots $V_n$. Süsteemi märgitakse, et tüüp $T$ võrdub tüübiga $U$ $V_1$ \ldots $V_n$.

            Muutuja $x$ tüüp võib sisaldada ka kitsendusi. Juhul, kui $x$ tüübimuutuja number $i$ on kitsendatud klassiga $C$, lisatakse kitsenduste võrrandisüsteemi kitsendus $C$ $V_i$.
          \item
            Funktsiooni rakendamise avaldise $e_0$ $e_1$ jaoks tuuakse sisse uus tüübimuutuja $U$, millega tähistatakse argumendi tüüpi. Avaldis $e_0$ tüübitakse arvestusega, et tema tüüp peab olema \verb!Function! $U$ $T$, ja avaldis $e_1$ tüübitakse arvestusega, et tema tüüp peab olema $U$.
          \item
            Lambda-avaldise $x$ \verb!->! $e$ korral tuuakse sisse kaks uut tüübimuutujat $U$ ja $V$ ning süsteemi märgitakse, et tüüp $T$ võrdub tüübiga \verb!Function! $U$ $V$. Seejärel tüübitakse avaldis $e$ keskkonnas, kuhu on lisatud teave, et muutuja $x$ tüüp on $U$, arvestusega, et avaldise tüüp peab olema $V$.
          \item
            Mustrisobitusavaldise puhul üle avaldise $e$ kontrollitakse, et kõik mustrid oleks mõeldud sama tüüpi avaldise jaoks. Mustrid peavad kõik olema kas täisarvud, tähed, sama algebralise andmetüübi konstruktorid või sama mooduliga jäärgiklassiringi elemendid. Ühtlasi kontrollitakse ka seda, et ei oleks kattuvaid mustreid ning et juhul, kui ei ole loetletud kõik võimalikud harud, leiduks lõpus ka vaikevalik.

            Mustritest saab leida, mis on avaldise $e$ tüüp. Juhul, kui tegu on primitiivide mustrisobitusega, saab avaldist $e$ tüüpida arvestusega, et tema tüüp on vastava primitiivi tüüp. Juhul, kui tegu algebralise andmetüübi $U$ mustrisobitusega ja tüübil $U$ on $n$ parameetrit, tuleb algebralise andmetüübi tüübiparameetrite jaoks sisse tuua tüübimuutujad $V_1$ \ldots $V_n$ ning $e$ tüübitakse arvestusega, et tema tüüp on $U$ $V_1$ \ldots $V_n$. See on mõnevõrra sarnane muutujanime tüüpimisega.

            Tüüpida tuleb ka harude tulemuseks olevad avaldised. Kuna mustrisobituse tulemuse tüüp peab olema $T$, tuleb iga haru tulemuseks olev avaldis tüüpida arvestusega, et tema tüüp on $T$. Algebraliste andmetüüpide mustrisobituse korral lisanduvad igas harus keskkonda ka mustrisobituse käigus sisse toodud lokaalsed muutujad.
        \end{itemize}

        Awfuli parameetriline polümorfism on teatud määral sarnane Hindley-Milneri tüübisüsteemiga~\cite{A}, mida kasutab ka Haskell~\cite{Has}. Awful on vähem võimas ja ei luba let-avaldise sees polümorfset funktsiooni defineerida. Awfulis saab polümorfseid funktsioone defineerida ainult globaalsel tasemel ja neile on kohustuslik lisada tüübisignatuur. Kuna Awfuli let-avaldis on järjestikune ja võimaldab ainult monomorfseid väärtusi defineerida, teisendatakse see parsimise järel lambda-avaldiste rakendamise jadaks ning seda ei ole tüübikontrolli käigus vaja eraldi käsitleda.

        Let-avaldise all polmorfsete funktsioonide defineerimine ei ole praktikas kuigi sageli kasulik ning Hindley-Milneri tüübisüsteemi täiendamine lisavõimalustega nagu näiteks tüübiklassid ja üldistatud algebralised andmetüübid muudab selliste üldistatud let-avaldiste tüübituletuse oluliselt keerulisemaks. Selle tõttu on tehtud ettepanek Haskellist let-avaldiste all polümorfsete funktsioonide defineerimise võimalus eemaldada~\cite{Let_Sho} ja GHC keelab üldistatud algebraliste andmetüüpide laienduse kasutamise korral polümorfsed let-avaldised, mis kasutavad lokaalseid muutujaid~\cite{Let_Gen}.

        Ka Awfulis on tüübiklassid. Hargnevate andmetüüpide kasutajasõbralikkuse huvides on tulevikus plaanis teostada mustrisobitus tüübimuutujate peal, mis sarnaselt üldistatud algebraliste andmetüüpide mustrisobitusega toob kaasa lokaalsed kitsendused. Lisaks ei ole veel teada, kuidas üldistatud let-avaldise tüübituletus ühilduks Awfulis tulevikus plaanitava tüübisüsteemi täiendusega: ideega käsitleda klasse kui alamliike, mida kirjeldame jaotises~\ref{klassliik}. Seega võib väita, et lokaalsete polümorfsete funktsioonide puudumine on pigem eelis kui puudus.
    \subsection{Väärtustamine}
      Awfulis kustutatakse tüübikontrolli järel avaldiste tüübid. Väärtustaja kasutab avaldisi, mille küljes ei ole teavet tüüpide kohta.
      \subsubsection{Struktuurid}
        Väärtustajas on struktuur esitatud tüübi \verb!Map! abil. Struktuur on esitatud kui \verb!Map!, kus sõnedele (väljade nimedele) vastavad avaldised. Struktuuri välja leidmiseks kasutab väärtustaja \verb!Data.Map! mooduli meetodit \verb!lookup!.
      \subsubsection{Algebralised andmetüübid}
        Algebralise andmetüübi esitus väärtustajas on list väljade sisust, millele on lisatud konstruktori nimi. Konstruktori nimi on algebraliste andmetüüpide puhul erinevalt struktuurist vajalik, sest seda kasutatakse mustrisobitusel õige haru leidmiseks.
      \subsubsection{Hargnevad andmetüübid}
        Kuna hargnevate andmetüüpide peal ei tehta mustrisobitust ja nende puhul on vaja väljade nimesid, siis nende esitamiseks kasutab väärtustaja sama viisi mis struktuuride jaoks.
      \subsubsection{Funktsiooni rakendamine}
        Awful on agar keel. See tähendab, et juba enne funktsiooni rakendamise tulemuste arvutamist väärtustatakse kõik argumendid.
      \subsubsection{Defineerimata käitumine}
        Muutuja \verb!Crash! on keelde sisse ehitatud muutuja, mis esineb tüüpimiskeskkonnas, aga seda ei ole lisatud väärtustamiskeskkonda. Väärtustaja annab tulemuse \verb!Maybe! monaadi all, ning kui muutuja väärtustamiskeskkonnast leidmine ebaõnnestub (mis võib juhtuda ainult muutuja \verb!Crash! korral), antakse väärtustamise tulemuseks \verb!Nothing! ja kasutajale kuvatakse, et väärtustamise lõpptulemuseks oli \verb!Crash!.
      \subsubsection{Lambda-avaldised}
        Awfuli väärtustaja ei võimalda hetkel väärtustamiskeskkonda lokaalseid muutujaid lisada. Seetõttu on lambda-avaldise rakendamine teostatud asendamise abil: väärtustatakse argument, funktsiooni kehas asendatakse muutuja kõik esinemised väärtustatud argumendiga, ja seejärel väärtustatakse tulemuseks olev avaldis.
      \subsubsection{Mustrisobitus}
        Mustrisobitusavaldis on väärtustajas esitatud tüübi \verb!Map! abil. Võtmeteks on primitiivide puhul vastavad primitiivid ja algebraliste andmetüüpide korral konstruktori nimesid tähistavad sõned. Alguses väärtustatakse sobitatav avaldis. Seejärel leitakse õige haru meetodi \verb!lookup! abil. Juhul, kui tegu on mustrisobitusega, mis toob sisse uusi lokaalseid muutujaid, asendatakse need muutujad vastavate avaldistega. Seejärel väärtustatakse tulemuseks olev avaldis.
      \subsubsection{Meetodid ja kitsendused}
        Kuna Awfuli väärtustajal ei ole teavet tüüpide kohta, ei saa meetodite puhul väärtustamise ajal otsustada, millist teostust on tarvis. Näiteks nähes nime \verb!Write_Brackets!, ei teaks väärtustaja, kas tegu on tähemärkide, täisarvude või mõne muu tüübi kirjutamise meetodiga.

        Jaotistes~\ref{peidetudargumendid} ja~\ref{haskklass} selgitasime, kuidas tüübiklassid võimaldavad anda sarnase otstarbega funktsioonidele sama nime ning lubavad vältida osade argumentide kirjutamist. Selleks, et saaks väärtustada ilma tüübiannotatsioonideta avaldisi, teostatakse tüübikontrolli järel vastupidine protsess~\cite{How}. Meetodite nimed täpsustatakse, nii et iga tüübi jaoks, mis on klassi esindaja, oleks meetodil unikaalne nimi. Kitsendused teisendatakse argumentideks. Kitsendatud funktsioonidele antakse lisa-argumendid.

        Näiteks kui meil on klass

        \begin{verbatim}Class C{T : Star}(f : T -> T)\end{verbatim}

        ning täisarvud ja kompleksarvud on selle klassi esindajad

        \begin{verbatim}Instance C{Int}(f = Negate)
Instance C{Complex T}<C T>(f = Complex (f (Real x)) (f (Imaginary x)))\end{verbatim}

        siis avaldis

        \begin{verbatim}f (Complex 1 0)\end{verbatim}

        teisendatakse enne väärtustamist järgmisele kujule:

        \begin{verbatim}f{Complex} f{Int} (Complex 1 0)\end{verbatim}

        Kui kasutaja jaoks on meetod \verb!f! ühe argumendiga funktsioon, siis väärtustaja näeb kitsendusi lisa-argumentidena. Näiteks meetodi \verb!f! teostus kompleksarvude jaoks näeb väärtustajas välja järgnev:

        \begin{verbatim}f{Complex} f{T} x = Complex (f{T} (Real x)) (f{T} (Imaginary x))\end{verbatim}
  \peatykk{Edasine töö}
    Awfuli peamisteks edasisteks eesmärkideks on võimalus kohelda liike kui kategooriaid ja klasse kui alamliike. Lisaks on kavas ka väiksemad täiendused parandamaks keele kasutuskõlblikkust.
    \subsection{Mustrisobitus tüübimuutujate peal}\label{eemaldadatyybiklassihakk}
      Hetkel on Awfulis ainus viis hargnevate andmetüüpide peal funktsioone teostada abitüübiklassid, mida kirjeldasime jaotises~\ref{tyybiklassihakk}. Selle asemel on tulevikus kavas võimaldada mustrisobituavaldist tüübimuutujate peal. Mustrisobitus tüübimuutuja mitte andmetüübi enda peal võimaldaks ilma abiklasse kirjutamata ka selliseid meetodeid, millel ei ole argumente ja mille jaoks ei ole mustrisobitus argumentide peal seega põhimõtteliselt võimalik. Toome siinkohal näite vektorite tüübist kui \verb!Applicative! klassi esindajast.

      \begin{verbatim}Instance Applicative{Array N}(
  Apply =
    Match N {
      !Zr -> _ -> _ -> Empty_Array,
      !Next N' ->
        Construct_Array f x -> Construct_Array y z ->
          Construct_Array (f y) (Apply x z)},
  Lift x =
    Match N {
      !Zr -> Empty_Array,
      !Next N' -> Construct_Array x (Lift x)})\end{verbatim}

      Mustrisobitus tüübimuutujate peal ei pea tingimata tähendama tüüpide kaasas kandmist väärtustamise ajal. Mustrisobitust tüübimuutujate peal oleks tüüpimise käigus võimalik teisendada abitüübiklasside abil töötavaks lahenduseks, mida kirjeldasime jaotises~\ref{tyybiklassihakk}. Sellisel juhul oleks tegu kasutajasõbralikuma süntaktilise suhkruga praegusele lahendusele.
    \subsection{Operaatorid}
      Magistritöö raames keskendus töö tüübiklasside ja edutamise arendamisele ning töö skoobist jäid välja mõned keele võimalusi otseselt mitte laiendavad, aga keele kasutusmugavuse ja koodi loetavuse seisukohast olulised aspektid. Hetkel on Awfuli süntaksi kõige suuremaks probleemiks operaatorite puudumine. See põhjustab pikemate avaldiste raskestiloetavust. On plaanis lisada võimalus lubada kasutajal binaarseid operaatoreid defineerida.
    \subsection{Struktuuride mustrisobitus}
      Operaatorite puudumise järel on Awfuli liigpikkade avaldiste ja halva loetavuse teine olulisim allikas struktuuride mustrisobituse puudumine. Selle tõttu on vaja sageli väljade nimesid kasutada.

      \begin{verbatim}Instance Bifunctor{Pair}(Bimap f g x = Pair (f (First x)) (g (Second x)))\end{verbatim}

      Tulevikus on plaanis lisada struktuuride mustrisobituse võimalus:

      \begin{verbatim}Instance Bifunctor{Pair}(Bimap f g (Pair x y) = Pair (f x) (g y))\end{verbatim}
    \subsection{Detailsemad veateated}
      Hetkel antakse tüübivigade puhul ainult funktsioon, kus viga tekib. Ei öelda täpsemat põhjust. Tulevikus on plaanis veateatele lisada teave selle kohta, millise kahe tüübi unifitseerimine ebaõnnestus.

      Teine veateadete liik, mida saaks oluliselt informatiivsemaks muuta, on veateated, mis tulenevad sellest, et kitsendatud meetodit üritatakse kutsuda väärtuse peal, mille tüübi jaoks need klassikitsendused ei kehti.

      \begin{verbatim}Def Max[T : Star](x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

      Antud näites on kasutaja unustanud kirjutada tüübikitsenduse, mistõttu funktsioon ei tüüpu. Hetkel öeldakse veateates, et vea põhjustas klass \verb!Ord!, aga kasutajale ei öelda, et vea põhjustas meetod \verb!Compare! ja et tüüp, mille jaoks klassikitsendus täitmata on, on \verb!T!. Kasutaja peab ise välja mõtlema, kas viga tuleb puuduvast tüübimuutuja kitsendusest või hoopis kirjutamata jäänud klassi esindajast. Veateade, mis ütleks, mis tüübi või tüübimuutuja jaoks on kitsendus rahuldamata, aitaks seda laadi vigu kiiremini parandada.
    \subsection{Mitmene pärilus}
      Awfuli tüübiklasside kõige olulisem puudus võrreldes Haskelli omadega on mitmese päriluse puudumine. Edasise töö käigus on plaanis täiendada Awfuli tüübiklasse toetamaks mitmest pärilust.
    \subsection{Liik kui kategooria}
      Tüüpe saab vaadelda kui kategooriat. Kategooria objektid on tüübid ning nooled tüüpide \verb!T! ja \verb!U! vahel on funktsioonid tüüpi \verb!Function T U!. Noolte kompositsiooniks on funktsioonide kompositsioon ja iga objekti (tüübi) ühiknool on vastava tüübi peal opereeriv ühikfunktsioon~\cite{Car, Fas}. Selline vaade tüüpidele kui kategooriale on võimalik ka Awfuli puhul.

      Kategooriatena saab aga vaadelda ka teisi liike peale liigi \verb!Star!, näiteks paaride liiki (mis annab meile korrutiskategooria) ja liiki \verb!Arrow!.
      \subsubsection{Kategooriate defineerimiseks vajalikud keele täiendused}
        Selleks, et liikide jaoks saaks defineerida noolte tüüpi, noolte kompositsiooni ja ühiknoolt, oleks Awfulit vaja täiendada järgmistel viisidel.

        \begin{itemize}
          \item
            Haskellis saab kategooriate defineerimiseks kasutada tüübiklasse, kuna Haskell võimaldab luua tüübiklasse, mis töötavad liikide mitte tüüpide peal, ning võimaldab tüübiklassi sees tüüpe defineerida. Awfuli tüübiklassid selliseid võimalusi hetkel ei paku. Üks võimalus Awfulis kategooriaid defineerida oleks tüübiklasse vastavalt täiendada. Teine võimalus oleks luua uus konstruktsioon tüübiklassidele sarnase süntaksiga, mis oleks mõeldud spetsiaalselt kategooriate defineerimiseks. Liigi \verb!Star! kategooria võik selles süntaksis välja näha näiteks niiviisi:

            \begin{verbatim}Category{Star}(
  T -> U = Function T U,
  Compose f g x = f (g x),
  Id x = x)\end{verbatim}

            Eemaldame keelest süntaktilise suhkru, kus operaator \verb!->! tähistab tüüpi \verb!Function!. Üldistame selle operaatori tähistama suvalise liigi noole tüüpi. Meetod \verb!Compose! tähistab noolte kompositsiooni ja meetod \verb!Id! tähistab ühiknoolt.
          \item
            Nagu näeme järgmistes jaotistes, on paljude kasulike kategooriate noolte tüübid liigipolümorfsed. Awfuli tüübisüsteemi on tegelikult juba ehitatud tugi liigipolümorfsete tüüpide jaoks, sest liigipolümorfsed tüübid on parametriseeritud andmetüüpide, näiteks listide edutamise vältimatu tagajärg. Tegu ei ole aga võimalusega, mida kasutajal on võimalik otse kasutada uute andmetüüpide loomisel -- süntaks ei võimalda liigimuutujaid kasutada.

            Keelt oleks tarvis täiendada viisil, mis lubaks kasutajal liigipolümorfseid andmetüüpe luua. Plaanis on lubada liigimuutujate sisse toomine topeltkandiliste sulgude abil, näiteks \verb![[K, L]]!. Süntaks võtab eeskuju tüübimuutujate omast, selle vahega, et kui tüübimuutujate puhul tuleb märkida liigid, siis liigimuutujate puhul ei ole sortide täpsustamist tarvis. Kuna ei ole plaanis lubada polümorfismi üle argumente nõudvate liigikonstruktorite, on kõik liigimuutujad ühest sordist.

            Lisaks on vaja sisse ehitada liigipolümorfsete funktsioonide tugi, mida hetkel ei ole. Seda on tarvis põhjusel, et liigipolümorfsete tüüpide andmekonstruktorid ja väljad on samuti liigipolümorfsed.
          \item
            Samuti selgub järgmiste jaotiste näiteid vaadeldes, et praegused võimalused tüübimuutujate sisse toomiseks ei ole piisavad. Vahel, kui meil on ainult ühe tüübikonstruktoriga liik, on kasulik teostada tüübi mustrisobitust otse seal, kus deklareerime tüübimuutujaid. Toome näiteks liigi \verb"!Wrapper", millel on ainult üks tüübikonstruktor \verb"!Wrapper". Tahame struktuuri \verb!Example! puhul kirjutada mitte \verb"[W : !Wrapper K]", vaid \verb"[!Wrapper T : !Wrapper K]", selleks, et saaks tüübi \verb"!Wrapper" argumenti kasutada.

            \begin{verbatim}Struct Wrapper[T : Star](Unwrap : T)
Struct Example[[K]][!Wrapper T : !Wrapper K](f : T -> T)\end{verbatim}
          \item
            Tüübikonstruktorite liigi \verb!Arrow! kategooria kirjutamisel tekib vajadus anda andmekonstruktorile polümorfset argumenti. Seega peab keel lubama tüüpe, mis sisaldavad mitte ainult kogu tüübi peal kehtivaid üldsuse kvantoreid, vaid ka üldsuse kvantoreid, mis kehtivad ainult ühe funktsiooniargumendi peal.

            \begin{verbatim}Fun_Hom[F : Star -> Star, G : Star -> Star] :
  (Forall [T : Star] F T -> G T) -> Fun_Hom F G\end{verbatim}
        \end{itemize}

        Järgnevates alamjaotistes toome mõned näited kategooriatest, mida võiks Awfulis defineerida saada.
      \subsubsection{Vastandkategooria}
        Kategooria \verb!K! vastandkategooria on kategooria, mis sisaldab samu objekte (tüüpe), aga kõik nooled on ümber pööratud. Vastandkategooria jaoks loome struktuuri

        \begin{verbatim}Struct Opp[T : Star](Opp' : T)\end{verbatim}

        Edutamise teel saadakse sellest ühe argumendiga liigikonstruktor \verb"!Opp" ning liigipolümorfne tüübikonstruktor \verb"!Opp" liiki \verb"K -> !Opp K", kus \verb!K! on suvaline liik. Lisaks objektidele on kategooria jaoks vaja ka nooli. Loome noolte jaoks tüübi

        \begin{verbatim}Struct Opp_Hom[[K]][!Opp T : !Opp K, !Opp U : !Opp K](Opp_Hom' : U -> T)\end{verbatim}

        Juhul, kui liik \verb!K! on kategooria, on kategooria ka liik \verb"!Opp K".

        \begin{verbatim}Category{!Opp K}<Category K>(
  T -> U = Opp_Hom T U,
  Compose (Opp_Hom f) (Opp_Hom g) = Opp_Hom (Compose g f),
  Id = Opp_Hom Id)\end{verbatim}
      \subsubsection{Korrutiskategooria}
        Korrutiskategooria moodustatakse kahest kategooriast \verb!K! ja \verb!L! niiviisi, et uue kategooria objektid (tüübid) on paarid, mille esimene element on kategooriast \verb!K! ja teine element kategooriast \verb!L!. Korrutiskategooria nooled on paarid kategooria \verb!K! ja kategooria \verb!L! nooltest.

        Meil on juba olemas paaride tüüp ja andmekonstruktor. Sellest saab edutamise teel kahe argumendiga liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"K -> L -> !Pair K L", kus \verb!K! ja \verb!L! on suvalised liigid. Loome paaride noolte tüübi.

        \begin{verbatim}Struct Pair_Hom[[K, L]][!Pair T U : !Pair K L, !Pair V W : !Pair K L](
  First_Hom : T -> V,
  Second_Hom : U -> W)\end{verbatim}

        Paaride kategooria kood näeks välja niiviisi:

        \begin{verbatim}Category{!Pair K L}<Category K, Category L>(
  T -> U = Pair_Hom T U,
  Compose (Pair_Hom f g) (Pair_Hom h i) =
    Pair_Hom (Compose f h) (Compose g i),
  Id = Opp_Hom Id)\end{verbatim}
      \subsubsection{Tüübikonstruktorite kategooria}
        Ka tüübikonstruktorid on kategooria, eeldusel, et tulemuseks olevad tüübid moodustavad kategooria. Loome tüübikonstruktorite noolte tüübi, mis on liigipolümorfne üle tüübikonstruktori argumendi ja tulemuse liikide \verb!K! ja \verb!L! ning võtab kaks argumenti \verb!F! ja \verb!G! liigist \verb!K -> L!. Andmekonstruktor võtab argumendiks ühe funktsiooni, mis on polümorfne üle tüübi \verb!T! liigist \verb!K! ja mille tüüp on \verb!F T -> G T!.

        \begin{verbatim}Struct Fun_Hom[[K, L]][F : K -> L, G : K -> L](Fun_Hom'[T : K] : F T -> G T)
Category{Arrow K L}<Category L>(
  T -> U = Fun_Hom T U,
  Compose (Fun_Hom f) (Fun_Hom g) = Fun_Hom (Compose f g),
  Id = Fun_Hom Id)\end{verbatim}
    \subsection{Klass kui alamliik}\label{klassliik}
      Funktsioonid vajavad sageli kitsendusi. Näiteks kui meil on polünoomide tüüp \verb!Polynomial T!, siis enamik kasulikke definitsioone ja klasse, mida polünoomide jaoks kirjutada saab, nõuavad, et tüüp \verb!T! oleks kommutatiivne ring.

      Üks kasulik funktsioon, mida saab kirjutada tüübi \verb!F T! jaoks, kus \verb!F! on funktor ja \verb!T! on ring, on kõigi elementide sama väärtusega korrutamine. Niiviisi saame kirjutada skalaariga korrutamise funktsiooni paljude vektorruumide jaoks, näiteks kompleksarvud, maatriksid, kvaternionid ja staatilise pikkusega vektorid. Toome siinkohal funktsiooni, mis korrutab kõik \verb!y! elemendid vasakult väärtusega \verb!x!.

      \begin{verbatim}Def Multiply_left[T : Star, F : Star -> Star]<Functor F, Ring T>
  (x : T, y : F T) : F T =
    Fmap (Multiply x) y\end{verbatim}

      Ka polünoome saab arvuga läbi korrutada. Kuid erinevalt vektoritest ja maatriksitest, millel on kindel struktuur, mis jääb skalaariga korrutamisel muutumatuks, koosneb polünoom kordajate listist, ning selle listi pikkus võib arvuga korrutamise käigus muutuda, juhul kui see arv annab kõige kõrgema liikme kordajaga korrutades tulemuseks nulli.

      Võtame näiteks polünoomi $p(x)=2x+3$ jäägiklassiringis mooduliga $4$. Korrutades polünoomi $p$ väärtusega $2$, saame tulemuseks $3p(x)=2$, sest $2$ ja $2$ on ringis mooduliga $4$ nullitegurid. Algse polünoomi kordajate list on pikkusega $2$, aga tulemuse kordajate listi pikkus on kõigest $1$. Seega võiks \verb!Fmap f! polünoomide korral pärast listi igale elemendile funktsiooni \verb!f! rakendamist eemaldada kõrgematesse kordajatesse tekkinud nullid, et polünoom oleks ka pärast arvuga korrutamist normaalkujul. Seda aga ei ole võimalik saavutada standartses Haskellis ega ka Awfulis, sest meetodi \verb!Fmap! tüüp on \verb!(T -> U) -> F T -> F U!, kus \verb!F! on funktor ning \verb!T! ja \verb!U! on kitsendamata tüübimuutujad. Samas \verb!Fmap! meetodi teostus polünoomide jaoks, mis kustutaks pärast funktsiooni rakendamist ebavajalikud nullid, nõuaks, et \verb!U! oleks ring (et oleks võimalik nulliga võrdlemine).

      Teine näide tüübikonstruktorist, mille puhul nõuaks klasside meetodid lisakitsendusi, on \verb!Set!~\cite{Cat}. Kuna \verb!Set T! peal töötavad funktsioonid eeldavad, et \verb!T! kuulub klassi \verb!Ord!, tekib tüübikonstruktori \verb!Set! jaoks \verb!Fmap! meetodi kirjutamisel sama probleem mis polünoomide puhul.
      \subsubsection{Kitsenduste liik Haskellis}
        Üks võimalik lahendus antud probleemile Haskellis on kitsenduste liik \verb!Constraint!. Näiteks saab Haskellis üldisema funktorite tüübi kirja panna järgmisel viisil~\cite{Cat}:

        \begin{verbatim}class Functor' f where
  type FConstraint f t :: Constraint
  fmap' :: (FConstraint f t, FConstraint f u) => (t -> u) -> f t -> f u\end{verbatim}

        Klass \verb!Functor'! sisaldab tüüpi \verb!FConstraint!, mis võimaldab anda \verb!f! argumendile kitsendusi. Kõik tüübikonstruktorid, mis on klassi \verb!Functor! esindajad, on ka klassi \verb!Functor'! esindajad. Lisaks saab klassi \verb!Functor'! esindajaks defineerida selliseid tüübikonstruktoreid nagu \verb!Set!, mille operatsioonid seavad tüübiargumendile kitsendusi.

        \begin{verbatim}instance Functor' Set where
  type FConstraint Set t = Ord t1
  fmap' f x = fromList (fmap f (elems x))\end{verbatim}
      \subsubsection{Klassikitsendused kui liigi osa}
        Liigi \verb!K! peal töötavat klassi saab vaadelda liigi \verb!K! alamliigina, ehk kitsendusi saab vaadata kui liigi osa. Muuhulgas võimaldab selline lähenemine teha kitsendatud operatsioonidega tüüpe tüübiklasside esindajateks ilma eelmises jaotises mainitud kitsenduste liiki kasutusele võtmata.

        Toome näite sellest, kuidas see võiks toimida klassi \verb!Functor! jaoks. Muudame klassi \verb!Functor! liigipolümorfseks, andes talle liigimuutujad \verb!K! ja \verb!L!. Tüübimuutuja \verb!F! liik on nüüd mitte \verb!Star -> Star! vaid \verb!K -> L! arvestamaks sellega, et funktor ei pruugi olla liigi \verb!Star! endofunktor~\cite{Cat}, vaid võib olla funktor kahe suvalise liigi vahel, mille jaoks on defineeritud kategooria koos vastava noole tüübiga.

        Meetodi \verb!Fmap! teostus on sarnane mis enne, selle vahega, et tüübimuutujate \verb!T! ja \verb!U! liik on nüüd \verb!K! mitte \verb!Star!. Meetod \verb!Fmap! tavalise funktori korral on meetod, mis võtab argumendiks funktsioon tüüpi \verb!Function T U! ja teeb sellest funktsiooni tüüpi \verb!Function (F T) (F U)!. Üldistatult saab seda vaadata kui meetodit, mis võtab argumendiks liigi \verb!K! noole tüüpide \verb!T! ja \verb!U! jaoks ning tagastab liigi \verb!L! noole tüüpide \verb!F T! ja \verb!F U! jaoks.

        \begin{verbatim}Class Functor[[K, L]]{F : K -> L}(
  Fmap[T : K, U : K] : (T -> U) -> F T -> F U)\end{verbatim}

        Juhul, kui kohtleme klasse alamliikidena, saab tüübikonstruktori \verb!Set! liiki panna kirja kui \verb!Ord -> Star!, mis võimaldab defineerida tüüpi \verb!Set! klassi \verb!Functor! esindajaks.
  \peatykk{Kokkuvõte}
    Käesoleva töö raames loodud keel Awful on staatiliselt tüübitud puhas funktsionaalne programmeerimiskeel. Töö käigus sai teostatud Awfuli interpretaator ning kirjutatud keele süntaksi formaalne spetsifikatsioon ja keele kirjeldus koos ülevaatega vajalikest programmeerimiskeelte alastest taustateadmistest.

    Erinevalt Haskellist, kus on kasutusel tavalised algebralised andmetüübid ning üldistatud algebralised andmetüübid, on Awfulis struktuurid, mis on mõeldud ühe konstruktoriga tüüpide jaoks, algebralised andmetüübid, mis sarnanevad Haskelli algebralistele andmetüüpidele selle vahega, et nõuavad vähemalt kahte konstruktorit, ning hargnevad andmetüübid, mis võimaldavad teatud piiratud juhtudel asendada üldistatud algebralisi andmetüüpe ilma tüübisüsteemi oluliselt täiendamata.

    Awfuli tüübi- ja liigisüsteemi on täiendatud andmetüüpide edutamisega võttes eeskuju Haskellist. Edutamine muudab tüübisüsteemi rikkalikumaks, võimaldades tüübiturvaliselt luua näiteks tüübitaseme naturaalarvusid ja liste. Käesolev töö näitab, et edutatud liikidele ja tüüpidele leidub kasulikke rakendusi ka keeles, milles puuduvad üldistatud algebralised andmetüübid. Awfuli hargnevad admetüübid võimaldavad paljusid kasulikke edutamise rakendusi, näiteks staatilise pikkusega vektoreid ja üldistatud ennikuid.

    Awfulis on olemas parameetriline polümorfism ja \textit{ad hoc} polümorfism. Awfuli tüübiklassid võtavad üldjoontes eeskuju standartsest Haskellist. Ainus olulisem erinevus on mitmese päriluse puudumine, mis on kavas teostada edasise töö käigus. Käesolev töö näitab muuhulgas, kuidas tüübiklasse saab kasutada loomaks hargnevate andmetüüpide peal töötavad funktsioone, juhul kui keel ei toeta mustrisobitust tüübimuutujate ega hargnevate andmetüüpide peal. Tegu on võttega, mida saab kasutada ka Haskellis nendel juhtudel, kus üldistatud algebraliste andmetüüpide jaoks on vaja kirjutada meetodeid, mis ei võimalda mustrisobitust argumendi peal, näiteks klassi \verb!Applicative! meetod \verb!pure!.

    Edasise töö käigus on plaanis täiendada keele tüübisüsteemi käsitlemaks liike kui kategooriaid ja klasse kui alamliike. See laseks üldistada teatud tüübiklasse (näiteks \verb!Functor!) ja võimaldaks muuhulgas lahendada probleemi kitsendatud meetoditega, näiteks meetodi \verb!Fmap! teostus tüübi \verb!Set! jaoks, mis nõuab Haskellis kitsenduste liiki. Lisaks on kavas teostada mustrisobitus tüübimuutujate peal (eesmärgiga parandada hargnevate andmetüüpide kasutajasõbralikkust), mitmene pärilus ning mõned väiksemad täiendused, peamiselt kasutusmugavuse ja süntaksi vallas: operaatorid, struktuuride mustrisobitus ja detailsemad veateated.
  \newpage
  \addcontentsline{toc}{section}{\refname}
  \bibliography{bachelor-thesis}
  \peatykktarn{Litsents}
    \subsection*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele kättesaadavaks tegemiseks}
      Mina, \textbf{Liisi Kerik},

      \begin{enumerate}
        \item
          annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose

          \textbf{\pealkiri}

          mille juhendaja on Härmel Nestra

          \begin{enumerate}
            \item[1.1]
              reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni;
            \item[1.2]
              üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace´i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
          \end{enumerate}
        \item
          olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
        \item
          kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi. 
      \end{enumerate}

      \noindent
      Tartus, 21.05.2018
\end{document}