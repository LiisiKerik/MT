% Institute of Computer Science thesis template
% authors: Sven Laur, Liina Kamm
% last change Tõnu Tamme 09.05.2017
\documentclass[12pt]{article}
\usepackage{CormorantGaramond}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{array}
\usepackage[english, estonian]{babel}
\usepackage[labelsep = period]{caption}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{inconsolata}
\usepackage[utf8x]{inputenc}
\usepackage{listings}
\usepackage{proof}
\usepackage{todonotes}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{xspace}
\addto\captionsestonian{
  \renewcommand\refname{Viidatud kirjandus}
}
\bibliographystyle{plain}
\definecolor{ereroheline}{RGB}{0,255,0}
\definecolor{hall}{RGB}{128,128,128}
\definecolor{helehall}{RGB}{192,192,192}
\definecolor{must}{RGB}{0,0,0}
\definecolor{roheline}{RGB}{0,128,0}
\lstset{
  basicstyle = \color{helehall}\ttfamily,
  mathescape}
\newcommand\peatykk[1]{
  \clearpage
  \section{#1}}
\newcommand\peatykktarn[1]{
  \clearpage
  \section*{#1}
  \addcontentsline{toc}{section}{#1}}
\newcommand\markus[1]{\textcolor{roheline}{\textbf{#1}}}
\begin{document}
  \thispagestyle{empty}
  \begin{center}
    \large
      TARTU ÜLIKOOL\\
      Arvutiteaduse instituut\\
      Informaatika õppekava\\

    \vspace{25mm}

    \Large
      Liisi Kerik

    \vspace{4mm}

    \huge
      Funktsionaalse programmeerimiskeele liigisüsteem

    \vspace{20mm}

    \Large
      Magistritöö (30 EAP)
  \end{center}

  \vspace{2mm}

  \begin{flushright}
    \begin{tabular}{rl} 
      Juhendaja: & Härmel Nestra, PhD
    \end{tabular}
  \end{flushright}
  \vfill
  \centerline{Tartu 2018}
  \newpage
{
\selectlanguage{estonian}
\noindent\textbf{\large Funktsionaalse programmeerimiskeele liigisüsteem}

\vspace*{1ex}

\noindent\textbf{Lühikokkuvõte:} 

\markus{One or two sentences providing a basic introduction to the field, comprehensible to a scientist in
any discipline.}

\markus{Two to three sentences of
more detailed background, comprehensible to scientists in related disciplines.}

\markus{One sentence clearly stating the general problem being addressed by this particular
study.}

\markus{One sentence summarising the main result (with the words ``here we show´´ or their equivalent).}

\markus{Two or three sentences explaining what
the main result reveals in direct
comparison to what was thought to be the case previously, or how the main result adds to previous knowledge.}

\markus{One or two sentences to put the results into a more general context.}

\markus{Two or three sentences to provide a broader perspective, readily comprehensible to a scientist in any discipline, may be included in the first paragraph if the editor considers that the accessibility of the paper is significantly enhanced by their inclusion.}

\vspace*{1ex}

\noindent
\textbf{Võtmesõnad:} andmetüübid ja struktuurid, funktsionaalprogrammeerimine, liigid, polümorfism, edutamine, tüübisüsteemid

\vspace*{1ex}

\noindent\textbf{CERCS:} P175 Informaatika, süsteemiteooria

\vspace*{1ex}}

{
\selectlanguage{english}
\noindent
\textbf{\large Type Inference for Fourth Order Logic Formulae}

\vspace*{3ex}

\noindent
\textbf{Abstract:}

\noindent
Many interpreting program languages are dynamically typed, such as Visual Basic or Python. As a result, it is easy to write programs that crash due to mismatches of provided and expected data types.  One possible solution to this problem is automatic type derivation during compilation. In this work, we consider study how to detect type errors in the \textsc{Whitespace} language by using fourth order logic formulae as annotations. The main result of this thesis is a new triple-exponential type inference algorithm for the fourth order logic formulae. This is a significant advancement as the question whether there exists such an algorithm was an open question. 
All previous attempts to solve the problem lead lead to logical inconsistencies or required tedious user interaction in terms of interpretative dance. Although the resulting algorithm is slightly inefficient, it can be used to detect obscure programming bugs in the \textsc{Whitespace} language. The latter significantly improves productivity. Our practical experiments showed that productivity is comparable to average Java programmer.   
From a theoretical viewpoint, the result is only a small advancement in rigorous treatment of higher order logic formulae. The results obtained by us do not generalise to formulae with the fifth or higher order. 

\vspace*{1ex}

\noindent
\textbf{Keywords:} data types and structures, functional programming, kinds, polymorphism, promotion, type systems

\vspace*{1ex}

\noindent
\textbf{CERCS:} P175 Informatics, systems theory

\vspace*{1ex}
}
\newpage
  \tableofcontents
  \peatykktarn{Tänusõnad}
    
  \peatykk{Sissejuhatus}
    \markus{What is it in simple terms (title)?} Käesoleva töö eesmärgiks oli arendada funktsionaalse programmeerimiskeele tüübisüsteemi. \markus{Seletada mis on tüübiturvalisus.}

    \markus{Why should anyone care?}

    \markus{What was my contribution?} Käesoleva töö tulemuseks on funktsionaalne programmeerimiskeel nimega Awful. Awful on puhas funktsionaalne interpreteeritud agar keel. Üks keele oluline erinevus teistest funktsionaalsetest programmeerimiskeeltest on viis, kuidas on teostatud andmestruktuurid. Kui Haskellis on olemas algebralised andmetüübid ja üldistatud algebralised andmetüübid, siis Awful asendab \markus{Märkida ära enda originaalne idee: hargnevad andmetüübid.}

    \markus{What you are doing in each section (a sentence or two per section)}

    Tip: if it's hard for you to start writing, then try to split it to smaller parts, e.g. if the title is ``Type Inference for a Cryptographic Protocol Prover Tool'' then the ``What is it'' can be divided into ``what is type inference'', ``what is cryptographic protocol'' and ``what is the prover tool''. These three can also be split to smaller parts etc.

    \markus{1) Motivatsioon 2) Mis sai valmis; tulemused 3) Mis mitte}
  \peatykk{Tüübiklassid ja üldistatud algebralised andmetüübid}
    Selles peatükis meenutame lühidalt
    \subsection{Tüübiklassid}
      \markus{sissejuhatav lõik: ad hoc polümorfism, mis on, milleks vajalik. paar näidet? lühidalt mainida teiste keelte ad hoc polümorfismi tegemise viise?}

      \markus{mainida, et ad hoc polümorfism on eriti kasulik kui tahta kasutada operaatoreid, nt + ja *}

      \markus{näiteid tüübiklasside kasutusest}

      \markus{mis kitsendused on tüübiklassidel ja esindajatel standard-Haskellis (vt 2010 std)? laiendustega Haskellis? Awful-is?}
    \subsection{Üldistatud algebralised andmetüübid}
      \markus{TODO: kusagil seletada, mis on hargnevate andmetüüpide piirangud võrreldes GADT-ga. Mis kasulikke asju nende abil teha ei saa; näited.}

      \markus{Alustuseks näiteid sellest, kuidas saab tavalisi andmetüüpe (nt nat ja list) GADT süntaksiga kirja panna?}
  \peatykk{Tüübitaseme andmed ja edutamine}
    Selles peatükis refereerime, mis on edutamine ning kuidas see muudab tüübisüsteemi väljendusrikkamaks ja aitab kirjutada tüübiturvalisemat koodi. Kuna käesoleva töö autori loodud keelt tutvustatakse alles peatükkides~\ref{syntaks} ja~\ref{manual}, ning kuna Haskell on esimene keel mille tüübisüsteem sisaldab edutamist~\cite{Giv}, on antud peatükis edutamise põhimõtete selgitamiseks kasutatud Haskelli süntaksit.

    Sageli on tüübiturvalisema koodi kirjutamiseks kasulik, kui saab tüüpide tasemel väärtusi kasutada. Näiteks võimaldavad tüübitaseme naturaalarvud luua vektoreid, mille pikkus, erinevalt listide omast, on juba tüübikontrolli ajal teada. Vektorite pikkustega seotud vead tulevad sellisel juhul välja juba tüübikontrollis, enne interpreteerimist või kompileerimist.

    See võimaldab kirjutada näiteks vektorite liitmise või viimase elemendi leidmise funktsiooni tüübiturvaliselt. Juhul, kui kirjutada neid funktsioone listide abil, ei ole kuidagi tagatud, et programmeerija ei kutsu vektorite liitmise funktsiooni välja kahe erineva pikkusega listi peal või ei kutsu viimase elemendi leidmise funktsiooni tühja listi peal.

    Lisaks kannavad tüübid kasulikku teavet funktsioonide sisendite ja väljundite kohta, ning mida väljendusrikkam tüübisüsteem on seda detailsemalt saavad funktsioonide tüübid funktsioonide sisu kirjeldada. Näiteks juhul kui keeles on võimalik kasutada tüübitaseme naturaalarve, saab vektorite liitmise funktsiooni tüüpi vaadates kohe teada, et kaks vektorit peavad olema sama pikad. Vaadates vektori viimase elemendi leidmise funktsiooni tüüpi, on kohe aru saada, et vektor ei tohi olla pikkusega null.

    Tüübitaseme andmed parandavad tüübiturvalisust, vähendavad korduva koodi hulka ning lisaks aitavad kaasa sellele, et tüübisüsteem oleks väljendusrikkam ja tüübid dokumenteeriks paremini funktsioonide sisu.
    \subsection{Tüübitaseme andmed}\label{tyybitasemeandmed}
      Mõnedes keeltes, näiteks Idris~\cite{The_Idr}, saab tüübitaseme andmete saavutamiseks kasutada sõltuvaid tüüpe. Sõltuvatest tüüpidest anname lühikese ülevaate jaotises~\ref{soltuvad}. Keeles, kus sõltuvaid tüüpe ei ole, on tüübitaseme andmeid võimalik kirjutada algebraliste andmetüüpide abil~\cite{Giv}. Tüübitaseme naturaalarvud näeksid Haskelli algebralisi andmetüüpe kasutades välja sellised:

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Sarnasel viisil saab teostada ka näiteks tüübitaseme liste:

      \begin{verbatim}data Empty_List
data Construct_List t l\end{verbatim}

      Tegu on tühjade tüüpidega, millel puuduvad andmekonstruktorid ja mis on mõeldud spetsiaalselt tüübitaseme andmete rolli täitmiseks.

      Toome mõned lihtsad näited andmetüüpidest, mille konstrueerimiseks on vaja tüübitaseme andmeid. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada. Neil on kaks konstruktorit: üks tühja vektori jaoks, ja teine vektori jaoks pikkusega \verb!n + 1!, mis võtab argumendiks pea ja \verb!n!-elemendilise saba.

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua suvalise arvu muutujatega Boole'i funktsiooni tüüp. \verb!0! muutuja Boole'i funktsioon on üks konstant. \verb!n + 1! muutuja Boole'i funktsioon saab esitada kahe \verb!n! muutuja Boole'i funktsiooni abil (jääkfunktsioonid, mille saame, asendades esimese muutuja vastavalt konstandiga \verb!False! või \verb!True!).

      \begin{verbatim}data Fun :: * -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid, mis sarnanevad struktuuri poolest üleelmises näited toodud vektoritele, selle vahega, et nad võivad sisaldada erinevat tüüpi andmeid.

      \begin{verbatim}data Tuple :: * -> * where
  Empty_Tuple :: Tuple Empty_List
  Construct_Tuple :: t -> Tuple l -> Tuple (Construct_List t l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: * -> * -> * where
  Empty_Array' :: t -> Array' Empty_List t
  Construct_Array' :: Array n (Array' l t) -> Array' (Construct_List n l) t\end{verbatim}

      Tüübitaseme andmed on kasulikud selleks, et saaks kirjutada tüübiturvalisemaid funktsioone. Näiteks kui tahame kirjutada vektorite liitmise funktsiooni, siis juhul kui kasutada vektorite esitamiseks liste, siis on tarvis arvestada ohuga, et programmeerija annab funktsiooni sisendiks erineva pikkusega listid. Erineva pikkusega listid resulteeruvad defineerimata käitumises või erindis programmi töö käigus ning tüüpimise ajal ei ole seda võimalik ennetavalt tuvastada.

      Tüübitaseme andmete olemasolul saab vektorite liitmise funktsiooni kirjutada eelpool näiteks toodud \verb!Array! tüübi peal, ning see tagab, et iga vektorite liitmise funktsiooni kutse puhul kontrollitakse juba tüüpimise ajal, et mõlemad argumendid oleks sama pikad.
    \subsection{Tüübid, liigid ja sordid}
      \markus{Seletada, mis on liik ja sort + viited.} \markus{Nüüd, kui see jupp on eraldi jaotis, on sellele sujuvamat algust vaja.} Niiviisi teostatud tüübitaseme andmetel on oluline puudus. Liigisüsteem ei ole piisavalt keeruline kirjeldamaks programmeerija tegelikke kavatsusi. Tüübid ei ole piisavalt tugevalt tüübitud. Ei ole liike, mis lubaks kirjeldada, et kohas kus võib esineda näiteks tüüp \verb!Char! või \verb!Int!, ei tohi esineda naturaalarvuline tüüp, ja vastupidi~\cite{Giv}. Tüübikontrollist lähevad läbi koodinäited, mis ei ole programmeerija tegelike kavatsustega kooskõlas, näiteks:

      \begin{verbatim}data Array :: * -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next t) n\end{verbatim}

      Siin on konstruktori \verb!Construct_Array! tulemuse tüübis vahetusse läinud tüübimuutujad \verb!n! ja \verb!t!. Koodinäide ei tohiks tegelikult tüüpuda, sest need tüübimuutujad on erinevat liiki. Vältimaks seda laadi vigu, oleks vaja liigisüsteemi, mis on piisavalt võimas kirjeldamaks, et tüübikonstruktori \verb!Array! esimene argument peab olema naturaalarv ja teine tavaline tüüp, ja et tüübikonstruktorit \verb!Next! saab rakendada ainult naturaalarvule.

      Lisaks eelmainitud peamisele puudusele, on oluline miinus ka see, et programmeerija peab tüüpide tasemel duplitseerima andmeid, mis on algebralise andmetüübi kujul tegelikult juba olemas.

      Edutamine lahendab need probleemid, muutes tüübi- ja liigisüsteemi võimsamaks ning tagades, et programmeerija ei peaks ise käsitsi tüübitaseme andmeid kirjutama. Järgmistes jaotistes räägimegi sellest, kuidas edutamine töötab, kuidas see muudab tüübisüsteemi ja millised andmetüübid on edutatavad.
    \subsection{Edutamine}
      Edutamine tõstab sobivad andmetüübid automaatselt "`üks tase ülespoole"'. Andmetüübi edutamisel tehakse tüübikonstruktorist liigikonstruktor, kusjuures tüübiparameetritest saavad liigiparameetrid. Andmekonstruktoritest saavad vastava liigi tüübikonstruktorid, kusjuures argumentide tüüpidest saavad tüübikonstruktorite argumentide liigid~\cite{Giv}.
      \subsubsection{Edutamise näiteid}
        \markus{siia natuke pikem kirjeldus edutamisest}

        Võtame esimeseks näiteks lihtsa andmetüübi, kus puudub polümorfism: naturaalarvud.

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        Ilma edutamiseta saab siit tüübi \verb!Nat :: *! ning kaks andmekonstruktorit \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!. Edutamise olemasolul saab lisaks ka liigi \verb!Nat! ning kaks tüübikonstruktorit \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!.

        Vaatleme keerulisemat näidet: liste.

        \begin{verbatim}data List (t :: *) = Empty_List | Construct_List t (List t)\end{verbatim}

        Ilma edutamiseta saab sellest andmetüübist tüübikonstruktori \verb!List :: * -> *! ning kaks andmekonstruktorit \verb!Empty_List! tüüpi \verb!List (t :: *)! ja \verb!Construct_List! tüüpi \verb!(t :: *) -> List t -> List t!. Edutamise olemasolul saab sellest andmetüübist lisaks ka ühe argumendiga liigikonstruktori \verb!List! ning kaks tüübikonstruktorit \verb!Empty_List! liiki \verb!List k! ja \verb!Construct_List! liiki \verb!k -> List k -> List k!.

        Listide puhul tuleb mängu polümorfism. Parametriseeritud tüüp muutub parametriseeritud liigiks. Tüübipolümorfsetest andmekonstruktoritest saavad liigipolümorfsed tüübikonstruktorid.
      \subsubsection{Andmetüübid, mida saab edutada}\label{kitsendused}
        Edutamisele on mõistlik seada teatud piirangud ning edutada ainult osasid andmetüüpe, mitte kõiki. Piirangud on seotud sooviga kasutada edutamise võimalusi (näiteks tüübitaseme naturaalarvusid ja liste) ilma muutmata tüübisüsteemi keerulisemaks kui hädapärast vajalik. Loetleme siinkohal piirangud, mida on kasutatud Haskellis~\cite{Giv}.

        \begin{itemize}
          \item
            Ei edutata üldistatud algebraliseid andmetüüpe. \markus{Too difficult to promote as they would complicate the kind system with equality constraints and coercions.}
          \item
            Ei edutata primitiive, näiteks tähti ja täisarvusid. Primitiivide edutamisega ei kaasne tegelikult sisulisi raskusi, küll aga võib neile praktiliste rakenduste leidmine nõua teisi keele täiendusi, mis ei ole sama lihtsad. Haskellis on primitiivide edutamata jätmise põhjuseks see, et keele laienduse autorite arvates ei ole primitiivide edutamine kasulik kui ei ole võimalik edutada tüübitasemele ka tehteid primitiividega (näiteks \verb!Int! tüüpi täisarvude liitmist).
          \item
            Ei edutata andmetüüpe, millel on tüübiparameetreid muud liiki kui liik \verb!*!. Juhul kui edutada ainult sellele kitsendusele vastavaid andmetüüpe, on sortide süsteem äärmiselt lihtne. Kõik liigimuutujad on ühte sorti. See tähendab, et liigipolümorfismi korral ei pea liigimuutujate sorte märkima. Liigikonstruktori sort on lihtsalt naturaalarv, mis näitab, mitut argumenti liigikonstruktor vajab.

            Juhul, kui soovida edutada andmetüüpe, mis sisaldaks tüübiparameetrites mitte ainult liiki \verb!*! vaid ka liigikonstruktorit \verb!->!, ei ole sellele põhimõttelisi takistusi, aga selline täiendus nõuaks keerulisemat sortide süsteemi. Liigimuutujad võivad olla erinevat sorti. Liigipolümorfismi korral oleks vaja liigimuutujate sorte märkida. Edutamise teostamine muutuks keerulisemaks, samas kui vajadus sellise võimsusega liigisüsteemi järele on küsitav.

            Kui tahta minna veel kaugemale ja edutada andmetüüpe, mis on parametriseeritud üle omakorda edutamise teel saadud liikide, oleks see veel keerulisem. Sellisel juhul oleks vaja \textit{topeltedutamist} -- tüübid, mis ei ole parametriseeritud üle edutamise teel saadud liikide, tuleks edutada kaks taset ülespoole -- või peaks tüübid ja liigid sõltuvad olema.
          \item
            Ei edutata liigipolümorfseid tüüpe, kuna sellisel juhul oleks vajalik sordipolümorfism.
          \item
            Loomulikult ei tohi edutada andmekonstruktoreid, mis võtavad mitte-edutatavat tüüpi argumente. Andmekonstruktorite edutamisel muutub tüüp liigiks, aga mitte-edutatavat tüüpi liigiks muuta ei saa, ei ole see võimalik. Tüübi mitte-edutatavus levib kõigile andmekonstruktoritele mis teda kasutavad.
        \end{itemize}

        Sarnastest piirangutest on lähtutud ka keele Awful loomisel, teatud muudatustega.

        \begin{itemize}
          \item
            Keeles ei ole üldistatud algebralisi andmetüüpe, aga on hargnevad andmetüübid, mida kirjeldame alamjaotises~\ref{hargnevad}. Reegli asemel, et ei edutata üldistatud algebralisi andmetüüpe, on keeles Awful tüübisüsteemis reegel, et ei edutata hargnevaid andmetüüpe.
          \item
            Isegi kui jätta kõrvale asjaolu, et tüübitaseme tehteid ei ole keelde Awful plaanis lisada, siis võimalused andmetüüpide konstrueerimiseks on palju piiravamad kui üldistatud algebralised andmetüübid. Selle tõttu ei näe käesoleva töö autor hetkel keeles Awful primitiivide edutamisele mõttekaid rakendusi. Tulevikku vaadates on see siiski teostatud, juhuks kui andmetüüpide konstrueerimise viisid tulevikus võimsamaks muutuvad.
          \item
            Lihtsuse huvides edutab Awful ainult neid andmetüüpe, mille kõik konstruktorid on edutatavad. Andmetüübi edutamist koos ainult osade konstruktorite edutamist ei tehta.
          \item
            Oleks võimalik edutada funktsiooni tüüpi sisaldavaid andmekonstruktoreid, näiteks

            \begin{verbatim}data Fun t u = Fun (t -> u)\end{verbatim}

            Siit oleks võimalik edutamise teel saada kahe argumendiga liigikonstruktor \verb!Fun! ning liigipolümorfne tüübikonstruktor \verb!Fun! liiki \verb!Fun!(t -> u) -> Fun t u!, kus sümbol \verb!->! tähistab tüübikonstruktori liiki. Selline edutamine võimaldaks edutada andmekonstruktoreid, mis võtavad argumendiks funktsioone, ja neist tuleks tüübikonstruktorid, mis võtavad argumendiks tüübikonstruktoreid.

            Keeles Awful sellist tüüpi hetkel ei edutata, sest selleks ei olnud otsest vajadust, aga antud täiendusele ei tundu olevat põhimõttelisi takistusi ja ei ole välistatud tulevikus selle võimaluse lisamine.
        \end{itemize}
      \subsubsection{Tüübisüsteemi täiendused edutamise lisamisel}
        Selleks, et saaks toimuda edutamine (alamjaotises~\ref{kitsendused} kirjeldatud kitsendustega), on tarvis tüübisüsteemi täiendada. Selles alamjaotises kirjeldame lühidalt, mis muudatused olid keeles Awful edutamise teostamiseks vajalikud.

        \begin{itemize}
          \item
            Kui edutame tüübipolümorfseid andmekonstruktoreid, näiteks listikonstruktorid, muutub tüübipolümorfism liigipolümorfismiks. Seega tekib vajadus liigipolümorfsete tüüpide järele.

            Täpselt nagu tüübipolümorfism ilma kohustusliku tüübirakenduseta toob kaasa vajaduse tüübituletuse järele, toob liigipolümorfism ilma kohustusliku liigirakenduseta kaasa vajaduse liigituletuse järele. Keel Awful nõuab teostuse lihtsuse huvides liigirakendust kõigi liigipolümorfsete tüüpide kasutamisel, et vätida liigituletust. Kuna liigipolümorfsed tüübid ei ole nii laias kasutuses kui tüübipolümorfsed andmekonstruktorid ja funktsioonid, ei muuda liigituletuse puudumine keelt nii kohmakaks kui tüübituletuse puudumine.
          \item
            Liigisüsteem peab olema piisavalt võimas ja paindlik, et võimaldada tüüpidest uusi liike teha. Enne edutamise lisamist oli keeles Awful ainult äärmiselt primitiivne liigisüsteem, mis sisaldas liiki \verb!Star! (analoogne Haskelli liigiga \verb!*!) ja liiki \verb!Arrow! (tüübikonstruktorite liik, analoogne Haskelli liigiga \verb!->!). Interpretaatori sees olid liigid esitatud järgneva andmetüübi abil:

            \begin{verbatim}data Kind = Star_kind | Arrow_kind Kind Kind\end{verbatim}

            Selgelt ei ole sellisele fikseeritud liigisüsteemile võimalik edutamist üles ehitada ja on tarvis olulisi muudatusi. Keele Awful interpretaator kasutab liigi esitamiseks andmetüüpi

            \begin{verbatim}data Kind = Name_kind | Application_kind Kind Kind\end{verbatim}

            Liike \verb!Star! ja \verb!Arrow! käsitletakse muudatuse järel lihtsalt kui nimede erijuhtumeid.
          \item
            Enne edutamise teostamist ei olnud keeles Awful sorte. Sortide järele ei olnud vajadust, sest oli ainult kaks fikseeritud liigikonstruktorit ning programmeerija kirjutatud liigi korrektsust oli võimalik kontrollida otse parseri tasandil.

            Liigisüsteem, mida saab lõpmatult uute liikidega laiendada, nõuab sorte. Liike ei saa üksteisele suvaliselt rakendada. Näiteks \verb!Star Arrow! ei ole korrektne liik ega isegi liigikonstruktor, sest \verb!Star! ei võta argumente ja seega ei tohi teda millelegi rakendada. Õnneks on edutamisele seatud piisavalt ranged piirangud ja sortide süsteem ei ole seega keeruline: liigikonstruktori sordiks on naturaalarv, mis näitab, mitut argumenti on tarvis.

            \begin{verbatim}data Sort = Star_sort | Arrow_sort Sort\end{verbatim}
          \item
            Primitiivide edutamisel on vaja lisada vastavad tüübid.
        \end{itemize}
      \subsubsection{Edutamise kasutusjuhtusid}
        Selles alamjaotises külastame uuesti näiteid, mida tõime alamjaotises~\ref{tyybitasemeandmed} rääkides tüübitaseme andmete rakendustest. Näitame, kuidas edutamine muudab nad tüübiturvaliseks ja aitab vältida korduvat koodi.

        Esiteks ei ole edutamise olemasolu korral enam tarvis käsitsi eksplitsiitselt tüübitaseme andmeid kirjeldada. Kirjutame naturaalarvude andmetüübi

        \begin{verbatim}data Nat = Zr | Next Nat\end{verbatim}

        ja sellest tuletatakse automaatselt liik \verb!Nat! ning vastava liigi tüübikonstruktorid \verb!Zr :: Nat! ja \verb!Next :: Nat -> Nat!. Mis kõige tähtsam, tänu sellele, et nüüd on olemas liik \verb!Nat!, on tüübitaseme naturaalarvud teostatud tüübiturvaliselt: tüübikonstruktori \verb!Next! puhul on teada, et tema argumendiks kõlbab ainult naturaalarv ja mitte näiteks täht või list.

      \begin{verbatim}data Zr
data Next n\end{verbatim}

      Toome mõned lihtsad näited sellest, milleks saab tüübitaseme andmeid kasutada. Üldistatud algebraliste andmetüüpide abil saab tüübitaseme andmeid tarvitada loomaks näiteks vektoreid, mille pikkus on tüübi tasemel teada.

      \begin{verbatim}data Array :: Nat -> * -> * where
  Empty_Array :: Array Zr t
  Construct_Array :: t -> Array n t -> Array (Next n) t\end{verbatim}

      Tüübitaseme naturaalarvusid saab kasutada ka selleks, et luua \verb!n! muutuja Boole'i funktsiooni tüüp.

      \begin{verbatim}data Fun :: Nat -> * where
  Constant :: Bool -> Fun Zr
  Branch :: Fun n -> Fun n -> Fun (Next n)\end{verbatim}

      Tüüpide listi abil saame luua üldistatud ennikuid.

      \begin{verbatim}data Tuple :: [*] -> * where
  Empty_Tuple :: Tuple []
  Construct_Tuple :: t -> Tuple l -> Tuple (t : l)\end{verbatim}

      Kui saame teha tüübitaseme listi naturaalarvudest, on seda võimalik kasutada loomaks mitmemõõtmelist tabelit, mille kõik mõõtmed on tüübi tasemel teada.

      \begin{verbatim}data Array' :: [Nat] -> * -> * where
  Empty_Array' :: t -> Array' [] t
  Construct_Array' :: Array n (Array' l t) -> Array' (n : l) t\end{verbatim}

      Siinkohal võib tekkida küsimus, kas edutamise praktiline kasutamine on võimalik keeles, kus ei ole üldistatud algebralisi andmetüüpe. Need lihtsad ja kasulikud rakendused, mida oleme selles alamjaotises vaadelnud, ei ole teostatavad ainult algebraliste andmetüüpide abil, kuna andmekonstruktorite resultaattüübid peavad erinema. Näiteks vektorite puhul annab üks andmekonstruktor tulemuseks vektori, mille pikkus on \verb!Zr!, aga teine annab tulemuseks vektori pikkusega \verb!Next n!.

      Hea uudis on see, et paljud edutatud andmetüüpide rakendused on siiski võimalikud ilma keelde üldistatud algebralisi andmetüüpe lisamata. On võimalik kasutada piiravamat ja lihtsamat viisi andmetüüpide konstrueerimiseks. Awful toob sisse \textit{hargnevad andmetüübid}, mida tutvustame alamjaotises~\ref{hargnevad}.
    \subsection{Edutamisega kaasnev nimekonflikt}
      Haskellis on tihti tavaks, et andmetüübi konstruktori nimi ühtib tüübi nimega, näiteks

      \begin{verbatim}data Pair t u = Pair t u\end{verbatim}

      Kuna andmekonstruktor \verb!Pair! esineb ainult avaldiste tasandil ja sama nimega tüübikonstruktor esineb ainult tüüpide tasandil, ei teki vajadust neil kahel vahet teha. Edutamine muudab olukorda.

      Edutades ülalpool mainitud andmetüüpi, saame lisaks tüübikonstruktorile \verb!Pair! liiki \verb!* -> * -> *! samanimelise tüübikonstruktori liiki \verb!t -> u -> Pair t u!, kus t ja u on liigimuutujad ning \verb!Pair! on edutamise teel saadud liigikonstruktor. Seega on kaks erineva liigi ja otstarbega aga samanimelist tüübikonstruktorit. Nendel vahet tegemiseks on mitmeid erinevaid võimalusi.
      \subsubsection{Eksplitsiitne edutamine vajaduse korral}
        Haskellis kasutatakse juhtudel, kus tekib nimede konflikt, edutamise teel saadud tüübikonstruktori ees ülakoma~\cite{Giv}. Antud näite korral tähistab tüübikonstruktor \verb!Pair! tavalist tüübikonstruktorit liiki \verb!* -> * -> *! ning \verb!'Pair! tähistab edutamise teel saadud tüübikonstruktorit liiki \verb!t -> u -> Pair t u!.

        Tasub mainida ka, et juhul kui kasutaja otsustab Haskellis \verb!-Wall! võtit kasutada, antakse hoiatused kõigi edutamise teel saadud tüübikonstruktorite kohta, mille ette ei ole ülakoma pandud -- ka nende kohta, mille puhul ei ole nimekonflikti võimalust~\cite{Gla}.
      \subsubsection{Nimekonflikti vältimine}
        Üks võimalus nimekonflikti lahendada on keelata tüübikonstruktori ja andmekonstruktori nimede ühtimine.

        \begin{verbatim}data Pair t u = MkPair t u\end{verbatim}

        Antud lahendus on lihtne, aga tal on puudusi. Nii on võimalik vältida edutamise eksplitsiitset märkimist, aga samas muutuvad pikemaks tavalised andmekonstruktorid. Programmeerijatele, kes on harjunud tüübikonstruktorit ja andmekonstruktorit sama nimega nimetama, võib olla kergem kohaneda edutamise eksplitsiitse märkimisega kui andmekonstruktorite teisiti nimetamisega.
      \subsubsection{Eksplitsiitne edutamine alati}
        Nimekonflikti saab lahendada ka märkides kõik edutamise teel saadud liigid ja tüübid mõne spetsiaalse sümboliga, näiteks ülalpool mainitud andmetüübi \verb!Pair! deklaratsioon annaks lisaks tavalisele andmekonstruktorile ja tüübikonstruktorile ka 2 argumendi liigikonstruktori \verb"!Pair" ja tüübikonstruktori \verb"!Pair" liiki \verb"t -> u -> !Pair t u".

        Käesoleva töö autori arvates on tegu hea lahendusega, sest erinevalt eksplitsiitsest edutamisest ainult vajaduse korral näevad edutamise teel saadud tüübikonstruktorid ühtlasemad välja. Lisaks võib edutamise teel saadud liigi- ja tüübikonstruktorite eksplitsiitne eristamine aidata programmeerijat, kes ei ole veel edutamisega harjunud ja ei tunne end kindlalt seda abstraktsiooni kasutades. Täpselt nagu tüüpide juurde märkimine võib vahel koodi isedokumenteeruvusele kaasa aidata, võib seda teha ka edutamise teel saadud tüübikonstruktorite eksplitsiitne märkimine.

        Selle tõttu ongi tegu lahendusega, mis sai valitud käesoleva töö raames loodud programmeerimiskeele jaoks. Awful kasutab edutamise tähistamiseks hüüumärki ning nõuab seda nii edutamise teel saadud liikide kui ka tüüpide ees.
    \subsection{Edutamise võrdlus sõltuvate tüüpidega}\label{soltuvad}
      Paljude keelte tüübisüsteemides, sealhulgas Haskelli omas, kehtib \textit{faasierisus} (ing. k. \textit{phase distinction}). Väärtused võivad sõltuda tüüpidest aga mitte vastupidi. Ka edutamise olemasolul jääb faasierisus tegelikult kehtima. Kuigi näiteks vektorite puhul võib tunduda, et vektori tüüp sõltub naturaalarvulisest väärtusest, aga tegelikult on tüübid ja väärtused siiski rangelt eristatud~\cite{Giv}.

      Mõnedes teistes programmeerimiskeeltes, näiteks Agda~\cite{Agd}, Coq~\cite{The_Coq} ja Idris~\cite{The_Idr}, on olemas sõltuvad tüübid. See tähendab, et tüübid võivad sõltuda väärtustest.

      Sõltuvad tüübid, nagu ka edutamine, võimaldavad luua tüübitaseme naturaalarvusid ja liste ning muid tüübitaseme andmeid. Tegu on aga võimsama tööriistaga kui edutamine. Toome mõned lihtsad funktsioonid, mida saab kirjutada kasutades sõltuvaid tüüpe, aga mis ei ole võimalikud ainult andmetüüpide edutamise abil. Tarvitame näidetes Idrise süntaksit, sest see on väga sarnane Haskelli omaga (siinkohal toodud näidetes on ainus erinevus see, et tüübi märkimiseks kasutatakse ühte ja listi konstrueerimiseks kahte semikoolonit).

      Üks lihtne ja kasulik funktsioon, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada, on kahe vektori konkateneerimine. Kui me konkateneerime vektoreid pikkusega \verb!m! ja \verb!n!, siis tulemuse pikkus on \verb!m + n!. Tegu on tüübitaseme naturaalarvude liitmisega. Kui edutatakse ainult tüüpe ja konstruktoreid, ei ole tüübitaseme andmetele võimalik rakendada funktsioone.

      \begin{verbatim}cat : Array m t -> Array n t -> Array (m + n) t
cat Empty_Array b = b
cat (Construct_Array x a) b = Construct_Array x (cat a b)\end{verbatim}

      Toome siinkohal veel ühe näite sõltuvate tüüpide kasutusest~\cite{The_Idr}, mida ei ole võimalik teostada edutamise abil. Üldistatud algebraline andmetüüp \verb!InElement! võimaldab staatiliselt tõestada, et element esineb listis. \verb!inList! funktsiooni tüüp \verb!InList (5 : Integer) [1, 2, 5]! on teoreem, mis ütleb, et \verb!5! esineb listis \verb![1, 2, 5]!. See, et meil õnnestub vastavat tüüpi funktsioon kirjutada, tõestab tüübis toodud väite.

      \begin{verbatim}data InList : t -> List t -> Type where
  Here : InList x (x :: l)
  There : InList x l -> InList x (y :: l)
inList : InList (5 : Integer) [1, 2, 5]
inList = There (There Here)\end{verbatim}

      Haskellis \verb!InList! tüüp küll toimib, sest liste on võimalik tüübi tasemele edutada, aga kuna \verb!Integer! ei ole edutatav tüüp, ei ole Haskellis võimalik elemendi leidumise tõestust \verb!Integer! tüüpi täisarvude listi jaoks läbi viia. Veel halvem on olukord juhul, kui tahaksime analoogseid tõestusi läbi viia vektorite peal. Sõltuvate tüüpidega on see võimalik, aga tavaline ühekordne edutamine ei võimalda saavutada tüübitaseme vektoreid. Haskellis ei läbiks järgnev andmetüüp tüübikontrolli.

      \begin{verbatim}data InArray : t -> Array n t -> Type where
  Here : InArray x (Construct_Array x a)
  There : InArray x l -> InArray x (Construct_Array y a)\end{verbatim}

      Näeme, et paraku on kasulikke ja üldsegi mitte keerulisi funktsioone, mida edutamine, erinevalt sõltuvatest tüüpidest, ei võimalda kirjutada. Edutamisel on võrreldes sõltuvate tüüpidega siiski ka eeliseid mitte ainult puudusi~\cite{Giv}:

      \begin{itemize}
        \item
          Programmeerijatel, kes on harjunud faasierisusega, võib olla lihtsam kohaneda edutamisega kui sõltuvate tüüpidega.
        \item
          Sõltuvad tüübid muudavad keerulisemaks tüübikontrolli ja tüübituletuse.
        \item
          Faasierisuse puhul on lihtne tüübikontrolli järel kõik tüübid kustutada ning edutamine ei muuda seda. Tüüpide kustutamine sõltuvate tüüpidega keeles on oluliselt keerulisem.
      \end{itemize}

      Paljude kasutusjuhtude jaoks on edutamine piisav. Edutamine muudab tüübisüsteemi oluliselt võimsamaks ja väljendusrikkamaks, ohverdamata samas lihtsust ja nõudmata programmeerijalt oluliselt teistmoodi tüübisüsteemiga kohanemist.
\begin{comment}
  \begin{frame}[fragile]{Promotion Without GADT-s?}
    Many GADT-s in the examples have a certain pattern:
    \begin{itemize}
      \item
        The kind of the new type constructor \verb!F! starts with \verb!K L1 ... Ln! where \verb!K! is a kind constructor promoted from an algebraic data type.
      \item
        The first type argument of the resulting \verb!F! is a type constructor applied to some type variables.
      \item
        For every constructor \verb!MakeK! of \verb!K!, we write exactly one data constructor. The first type argument of the resulting \verb!F! is constructed with \verb!MakeK!.
      \item
        For each data constructor that we create, the other type arguments of the resulting \verb!F! are type variables.
      \item
        All type variables used in the resulting \verb!F! are different.
    \end{itemize}
    The two examples shown that do not conform to this rule - \verb!Fin! and \verb!Sum! - can also be done by relaxing only the third rule (allowing zero or more than one data constructor of \verb!F! for each type constructor of \verb!K!).
  \end{frame}
  \begin{frame}[fragile]{Why Not GADT-s?}
    \begin{itemize}
      \item
        Simplicity of use for the programmer.
      \item
        Hopefully simplicity of implementation (type checking and type inference)?
    \end{itemize}
    Many useful applications of promoted kinds are achievable with something much less powerful than GADT-s. GADT-s might be an overkill.
  \end{frame}
\end{comment}
  \peatykk{Süntaks}\label{syntaks}
    Selles peatükis kirjeldame keele Awful süntaksit.
    \subsection{Süntaksi formaalne spetsifikatsioon}
    Toome konkreetse süntaksi formaalse spetsifikatsiooni. Lisaks püstkriipsule, mis tähistab valikut kahe variandi vahel, ja tähele $\epsilon$, mis tähistab tühja sõnet, on kasutatud ka sümboleid $A^*=\epsilon|AA^*$ ja $A?=\epsilon|A$.

    Käesolev süntaksi spetsifikatsioon ei tegele leksiliste detailidega, nagu tühikud, reavahetused, kommentaarid ning muutujanimede, tähtede ja täisarvude leksiline struktuur. Neid detaile selgitame mitteformaalselt peatüki lõpus jaotistes~\ref{kommentaarid}-\ref{primitiivid}.

    Loetavuse huvides on keele elementide tähistused ning süntaksi kirjeldamiseks kasutatav notatsioon tavalises kirjatüübis. Keele võtmesõnad ja sümbolid on helehallis fikseeritud laiusega kirjatüübis. \markus{TODO: epsilon ei ole sobiv avaldiste jaoks, sest tähistab tühja stringi}

    \begin{equation*}
      \begin{tabular}{llll}
        Fail & $P$ & $::=$ & $I^*D^*K^*F^*$
      \end{tabular}
    \end{equation*}

    Awful keele fail koosneb imporditavate failide nimekirjast ning andmetüüpide, klasside ja funktsioonide deklaratsioonidest.

    \begin{equation*}
      \begin{tabular}{llll}
        Import & $I$ & $::=$ & {\color{helehall}\verb!Load!} $x${\color{helehall}\verb!.awf!}
      \end{tabular}
    \end{equation*}

    Tähega \verb!x! tähistame süntaksi spetsifikatsioonis ükskõik millist nime: kas siis faili, tüübi, tüübimuutuja, konstruktori, struktuuri välja, definitsiooni või lokaalse muutuja oma.

    \begin{equation*}
      \begin{tabular}{llll}
        Andmetüüp & $D$ & $::=$ & $S|A|G$
      \end{tabular}
    \end{equation*}

    Andmetüüp võib olla struktuur, algebraline andmetüüp või hargnev andmetüüp. Hargnevaid andmetüüpe tutvustame alamjaotises~\ref{hargnevad}.

    \begin{equation*}
      \begin{tabular}{llll}
        Struktuur & $S$ & $::=$ & {\color{helehall}\verb!Struct!} $xt\phi$
      \end{tabular}
    \end{equation*}

    Struktuuri deklaratsioon sisaldab nime, tüübimuutujaid ja väljasid.

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutujad & $t$ & $::=$ & $(${\color{helehall}\verb![!}$\tau(${\color{helehall}\verb!,!}$\tau)^*${\color{helehall}\verb!]!}$)?$
      \end{tabular}
    \end{equation*}

    

    \begin{equation*}
      \begin{tabular}{llll}
        Tüübimuutuja koos liigiga & $\tau$ & $::=$ & $x$ {\color{helehall}\verb!:!} $L$
      \end{tabular}
    \end{equation*}

    \begin{tabular}{llll}
      Liik & $L$ & $::=$ & $\Lambda$ $\Lambda^*|${\color{helehall}\verb"!"}$?x$ \\
       & $\Lambda$ & $::=$ & {\color{helehall}\verb!(!}$\Lambda$ $\Lambda^*${\color{helehall}\verb!)!}$|${\color{helehall}\verb"!"}$?x$ \\
      Struktuuri väljad / muutujad & $\phi$ & $::=$ & $(${\color{helehall}\verb!(!}$\nu(${\color{helehall}\verb!,!}$\nu)^*${\color{helehall}\verb!)!}$)?$ \\
      Muutuja koos tüübiga & $\nu$ & $::=$ & $x$ {\color{helehall}\verb!:!} $T$ \\
      Tüüp & $T$ & $::=$ & $t$ $t^*|${\color{helehall}\verb"!"}$?xl$ \\
       & $t$ & $::=$ & {\color{helehall}\verb!(!}$t$ $t^*${\color{helehall}\verb!)!}$|${\color{helehall}\verb"!"}$?xl$ \\
      Liigirakendus & $l$ & $::=$ & $(${\color{helehall}\verb"["}$L(${\color{helehall}\verb","}$L)^*${\color{helehall}\verb"]"}$)?$ \\
      Algebraline andmetüüp & $A$ & $::=$ & {\color{helehall}\verb!Algebraic!} $x\tau${\color{helehall}\verb!(!}$a${\color{helehall}\verb!,!}$a(${\color{helehall}\verb!,!}$a)^*${\color{helehall}\verb!)!} \\
      Algebralise andmetüübi konstruktor & $a$ & $::=$ & $x(${\color{helehall}\verb!(!}$L(${\color{helehall}\verb!,!}$L)^*${\color{helehall}\verb!)!}$)?$ \\
      Hargnev andmetüüp & $G$ & $::=$ & {\color{helehall}\verb!Branching!} $x${\color{helehall}\verb"[!"}$xl${\color{helehall}\verb!]!}$\tau${\color{helehall}\verb!(!}$H${\color{helehall}\verb!,!}$H(${\color{helehall}\verb!,!}$H)^*${\color{helehall}\verb!)!} \\
      Hargneva andmetüübi haru & $H$ & $::=$ & {\color{helehall}\verb"!"}$x$ $x^*$ {\color{helehall}\verb!->!} $x\phi$ \\
      Klass & $K$ & $::=$ & {\color{helehall}\verb!Class!} $x${\color{helehall}\verb!{!}$t${\color{helehall}\verb!}!}$(${\color{helehall}\verb!<!}$x${\color{helehall}\verb!>!}$)?(${\color{helehall}\verb!(!}$\mu(${\color{helehall}\verb!,!}$\mu)^*${\color{helehall}\verb!)!}$)?$ \\
      Klassi meetod & $\mu$ & $::=$ & $x\tau\kappa$ {\color{helehall}\verb!:!} $L$ \\
      Kitsendused & $\kappa$ & $::=$ & $(${\color{helehall}\verb!<!}$k(${\color{helehall}\verb!,!}$k)^*${\color{helehall}\verb!>!}$)?$ \\
      Kitsendus & $k$ & $::=$ & $x$ $x$ \\
      Definitsioon / esindaja & $F$ & $::=$ & $\delta|i$ \\
      Definitsioon & $\delta$ & $::=$ &  \\
      Avaldis & $E$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|\lambda|i|M|x$ \\
         & $e$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$i|${\color{helehall}\verb!(!}$M${\color{helehall}\verb!)!}$|x$ \\
         & $\epsilon$ & $::=$ & {\color{helehall}\verb!"!}$c${\color{helehall}\verb!"!}$|${\color{helehall}\verb!(!}$\lambda${\color{helehall}\verb!)!}$i|${\color{helehall}\verb!(!}$M${\color{helehall}\verb!)!}$|x$ \\
      Täht & $c$ & &  \\
      Lambda & $\lambda$ & $::=$ & $x$ {\color{helehall}\verb!->!} $E$ \\
      Täisarv & $i$ &  &  \\
      Mustrisobitus & $M$ & $::=$ &  \\
      Esindaja & $i$ & $::=$ &  \\
    \end{tabular}
\begin{comment}
  data Brnch_0 = Brnch_0 Name [Name] Name [(Name, Type_0)] deriving Show
  data Data_br_0 = Branching_data_0 Name [Kind_0] [(Name, Kind_0)] [Brnch_0] | Plain_data_0 [(Name, Kind_0)] Data_branch_0
  data Data_branch_0 = Algebraic_data_0 [Form_0]
  data Def_0 =
    Basic_def_0 Name [(Name, Kind_0)] [Constraint_0] [(Pattern_1, Type_0)] Type_0 Expression_0 |
    Instance_def_0 Location_0 Name Name [Kind_0] [Pattern_1] [Constraint_0] [(Name, ([Pattern_1], Expression_0))]
  data Expression_branch_0 =
    Application_expression_0 Expression_0 Expression_0
  data Match_Algebraic_0 = Match_Algebraic_0 Name [Pattern_1] Expression_0 deriving Show
  data Match_char_0 = Match_char_0 Char Expression_0 deriving Show
  data Match_Int_0 = Match_Int_0 Integer Expression_0 deriving Show
  data Matches_0 =
    Matches_Algebraic_0 [Match_Algebraic_0] (Maybe (Location_0, Expression_0)) |
    Matches_char_0 [Match_char_0] Expression_0 |
    Matches_Int_0 [Match_Int_0] Expression_0
      deriving Show
\end{comment}
    Süntaks ei ole taandetundlik. Antud otsuse põhjuseks oli parseri teostuse lihtsus, aga ka soov anda kasutajale vabadus koodi paigutuses. Lisaks vähendab mitte-taandetundlikkus parsimisvigade ohtu suuremate kooditükkide kopeerimisel ühest kohast teise. Antud otsuse peamiseks puuduseks on liigsed sulud ja eraldajad (näiteks \verb!Match! avaldises), mida taandetundlik süntaks oleks aidanud vältida.
    \subsection{Kommentaarid}\label{kommentaarid}
      Kommentaaride süsteem on sarnane Haskellile ja C keelele, selle vahega, et kasutatakse teistsuguseid sümboleid. Üherealist kommentaari alustatakse graavise sümboliga.

      \begin{verbatim}Def Id[T : Star](x : T) : T = T `Ühikfunktsioon\end{verbatim}

      Mitmerealist kommentaari alustatakse lainelise joone ja kaldkriipsuga, ning lõpetatakse kaldkriipsu ja lainelise joonega. Nagu ka Haskellis, võib mitmerealisi kommentaare teineteise sisse paigutada.

      \begin{verbatim}~/ Awful on funktsionaalne keel. /~\end{verbatim}
    \subsection{Muutujanimed}
      Keel on tõstutundlik. Erinevalt Haskellist ei ole piiratud, mis nimed peavad algama suur- ja millised väiketähega. Failid, tüübid, tüübimuutujad, konstruktorid, struktuuride väljad, definitsioonide nimed ja lokaalsed muutujad võivad kõik alata kas suur- või väiketähega vastavalt kasutaja soovile.

      Nimedes on lubatud ülakoma, numbrid (välja arvatud esimeses positsioonis), ladina tähed ja alakriips. ASCII standardis mitte esinevad sümbolid ei ole nimedes lubatud, küll aga tohib neid kasutada kommentaarides.

      Üksik alakriips tähistab, nagu ka Haskellis, nimetamata muutujat.
    \subsection{Primitiivid}\label{primitiivid}
      Tähtede (\verb!Char!) ümber käivad topeltjutumärgid (näiteks \verb#"!"#). Täisarvude süntaks on identne Haskelli omaga.
  \peatykk{Keele kirjeldus ja näited}\label{manual}
    \markus{kusagil kirjeldada sisse ehitatud liike ja tüüpe ja nende otstarvet} Awful on deklaratiivne, puhas, funktsionaalne keel.

    Kuna töö teemaks oli tüübisüsteemi arendamine mitte kompileerimisega seotud problemaatika, sai kirjutatud ainult interpretaator ning kompileerimise võimalust ei ole. Tüübisüsteem on siiski staatiline: koodifaile on võimalik tüübikontrollida ka ilma interpretaatorit käivitamata ning tüükontroll toimub enne interpreteerimist mitte selle käigus.

    Erinevalt Haskellist on Awful agara väärtustamisega.

    \markus{TODO: 1) rohkem näiteid 2) põhjendada disainivalikuid}
    \subsection{Moodulid ja importimine}
      Kõik Awful koodifailid lõpevad laiendiga \verb!.awf!. Awful'is on olemas lihtne moodulite süsteem. Mooduleid saab importida kasutades võtmesõna \verb!Load!. Impordid peavad olema faili alguses ja nende järjekord ei ole oluline.

      \begin{verbatim}Load Algebra.awf
Load Standard.awf\end{verbatim}

      Nimekonfliktide tuvastamise teostuse lihtsuse huvides ei ole lubatud, et kahes erinevas moodulis oleks mõni ühine muutujanimi, isegi juhul kui tegelikku võimalust nimekonfliktiks ei ole.
    \subsection{Liigid ja andmetüübid}
      Haskellis on kaks viisi uusi andmetüüpe luua: tavalised algebralised andmetüübid ja üldistatud algebralised andmetüübid. Keele Awful lähenemine andmetüüpidele on teistsugune. Keel pakub kasutajale kolme erinevat viisi uusi andmetüüpe luua: struktuurid, algebralised andmetüübid ja hargnevad andmetüübid. Ükski neist ei ole teisega asendatav, kõigil on erinev otstarve.

      Awful nõuab, et andmetüübid oleks deklareeritud enne klasse ja definitsioone. Andmetüüpide deklaratsioonide omavaheline järjekord ei ole aga oluline isegi kui nende vahel on sõltuvusi.
      \subsubsection{Liigid}
        \markus{siin mainida uuesti edutamist; mainida mis liigid on keelde sisse ehitatud - Star ja Arrow; viidata osale mis räägib edutamisest}
      \subsubsection{Struktuurid}
        Struktuurid on mõeldud andmetüüpide jaoks, millel on täpselt üks konstruktor. Konstruktori nimi ühtib tüübi nimega automaatselt. Erinevalt Haskellist on kohustuslik kirja panna struktuuri väljade nimed.

        \begin{verbatim}Struct Pair[T : Star, U : Star](First : T, Second : U)\end{verbatim}

        Juhul, kui struktuur ei kasuta tüübipolümorfismi, tuleb kandilised sulud lihtsalt ära jätta. Sama kehtib ka struktuuri väljade kohta: juhul kui struktuuril ei ole ühtegi välja, tuleb ära jätta ümarsulud väljade loeteluga.

        \begin{verbatim}Struct Trivial\end{verbatim}

      \subsubsection{Algebralised andmetüübid}
        Algebralised andmetüübid on sarnased Haskelli omadega, selle vahega, et kasutajalt nõutakse vähemalt kahte konstruktorit. Juhul, kui kasutaja tahab kirjutada ühe konstruktoriga andmetüüpi, on selleks struktuurid.

        Kuna algebraliste andmetüüpide puhul on andmetel kaks või enam erinevat kuju, ei ole nende jaoks võimalust spetsifitseerida väljade nimesid. Kui struktuurist saab andmed kätte väljade nimede abil, siis algebraliste andmetüüpide jaoks tuleb kasutada mustrisobituse avaldist, mida on kirjeldatud alamjaotises~\ref{match}.
      \subsubsection{Hargnevad andmetüübid}\label{hargnevad}
        \markus{Kirjutada võrdlus GADT-ga. Mis on eelised ja mis on puudused?}
      \subsubsection{Keelde sisse ehitatud andmetüübid}\label{sisseehitatudalgebralised}
        Lisaks tähtedele (\verb!Char!), funktsioonidele (\verb!Function!) ja piiramata suurusega täisarvudele (\verb!Int!) on keeles Awful ka ilma standardteeki importimata saadaval järgmised andmetüübid:

        \begin{verbatim}Algebraic Comparison(LT, EQ, GT)
Algebraic List[T : Star](Empty_List, Construct_List(T, List T))
Algebraic Maybe[T : Star](Nothing, Wrap(T))
Algebraic Nat(Zr, Next(Nat))\end{verbatim}

        Väiksem-võrdne-suurem võrdlustulemuse tüüp \verb!Comparison! on keelde sisse ehitatud, sest keelde on sisse ehitatud ka primitiivide (tähtede ja täisarvude) võrdlus. \verb!List! on keelde sisse ehitatud põhjusel, et keelde on sisse ehitatud täisarvude teisendamine stringideks. \verb!Maybe! on lisatud sisse ehitatud klassi \verb!Field! (korpus) jaoks, sest pöördelemendi tehte tulemus antakse \verb!Maybe! monaadi all, kuna kõik korpused peale triviaalse sisaldavad mittepööratavaid elemente. Naturaalarvude tüüp \verb!Nat! on lisatud, sest tulevikus on kavas lisada keelde kolmandaks primitiiviks jäägiklassikorpused, mis nõuavad tüübitaseme naturaalarvusid.

        Kuna kõik need andmetüübid on edutatavad, kaasneb nendega ka vastavate edutamise teel saadud liikide ja tüüpide kasutamise võimalus.
    \subsection{Tüübiklassid}
      Uue tüübiklassi loomine käib võtmesõnaga \verb!Class!, millele järgneb klassi nimi, tüübimuutuja nimi ja liik, päritav klass (kui seda on), ja nimekiri meetoditest koos tüüpidega.

      \begin{verbatim}Class Functor{F : Arrow Star Star}(
  Fmap[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))\end{verbatim}

      Vahel on kasulikud ka ilma meetoditeta klassid. Sisuliselt on tegu predikaatidega tüüpide peal ja nad on kasulikud kirjeldamaks tüüpide omadusi. Üks lihtne näide on klass \verb!Commutative!, mille esindajat saab kirjutada märkimaks, et tüüp, mis on ring, on lisaks teatud tingimustel kommutatiivne.

      \begin{verbatim}Class Commutative{T : Star}<Ring>\end{verbatim}

      Siinkohal tasub märkida, et täpselt nagu ka teiste klassidega, ei kontrollita selliste predikaatide puhul kasutaja kirjutatud klassiesindajate vastavust nõutud kitsendustele. Awful ei ole tõestusassistent ega paku võimalusi selliste omaduste tõestamiseks.
      \subsubsection{Pärilus}
        Magistritöö skoobi piiratuse tõttu võimaldab Awful ainult ühest pärilust. Seda, et üks klass pärib teist, märgitakse nurksulgude abil:

        \begin{verbatim}Class Finite{T : Star}<Ord>(All : List T)\end{verbatim}

        Näiteks antud juhul eeldab klass \verb!Finite! (mis lubab \verb!All! meetodi abil saada list lõpliku andmetüübi kõigist võimalikest väärtustest) klassi \verb!Ord!.
      \subsubsection{Kitsendused}
        
      \subsubsection{Klassi meetodite tüübikitsendused}
        Vahel on vaja kirjutada klassi, mille meetodid sisaldavad tüübikitsendusi. Hea näide on klass \verb!Mat!, mis on mõeldud üldistamaks erinevaid ruutmaatrikseid ning sisaldab endas adjunktmaatriksi, karakteristliku polünoomi, determinandi ja vektoriga korrutamise meetodeid. Tema meetodites esinevaid tüübimuutujaid on vaja kitsendada kitsendustega \verb!Ring! ja \verb!Commutative!, sest näiteks maatriksi ja vektori korrutamist ei ole võimalik defineerida, kui allolev struktuur ei ole ring, ja determinant nõuab kommutatiivset ringi.

        \begin{verbatim}Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> :
    Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> :
    Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> :
    Function (Array N T) (Function (F N T) (Array N T)))\end{verbatim}
      \subsubsection{Keelde sisse ehitatud klassid}\label{klassmaatriks}
        Neli klassi on saadaval ka ilma standardteeki importimata:

        \begin{verbatim}Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Ord{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(
  Brackets : Function T (List Char),
  Write : Function T (List Char))\end{verbatim}

        Klass \verb!Ord! on sarnane Haskelli samanimelise klassiga, selle vahega, et Awful'is ei ole klassi \verb!Eq!. See on keelde sisse ehitatud primitiivide võrdluse jaoks.

        Klass \verb!Writeable! on mõeldud andmestruktuuride stringideks teisendamiseks meetodi \verb!Write! abil; \verb!Brackets! on abimeetod, mis paneb avaldise sulgudesse välja arvatud juhul kui tegu on üksiku konstandiga. Tulevikus on plaanis selle klassi abil teostada interpreteerimise tulemuste kuvamine kasutajasõbralikumal kujul kui praegu.

        Klassid \verb!Ring! ja \verb!Field! on tuttavad algebrast: tegu on lihtsalt (mitte tingimata kommutatiivse) ringi ja korpusega. Klassi \verb!Ring! meetod \verb!Convert!, mis teisendab täisarvu ringi elemendiks, on mõeldud defineerimaks nulli (\verb!Convert 0!) ja ühikut (\verb!Convert 1!), aga ka selleks, et oleks mugav suvalises ringis elementi täisarvulise konstandiga korrutada. Klass \verb!Ring! on keelde sisse ehitatud täisarvuliste tehete jaoks. Klass \verb!Field! on lisatud, pidades silmas seda, et tulevikus on plaanis teostada jäägiklassikorpuste primitiiv koos kõigi aritmeetikatehetega, sealhulgas pöördelemendi leidmine.
    \subsection{Keelde sisse ehitatud definitsioonid ja esindajad}
      Lisaks alamjaotises~\ref{sisseehitatudalgebralised} loetletud algebraliste andmetüüpide konstruktoritele, on ilma standardteeki importimata võimalik kasutada järgmisi keelde sisse ehitatud muutujaid ja esindajaid:
      \subsubsection{Ühikfunktsioon}
        Ilma standardteeki importimata on saadaval ühikfunktsioon.

        \begin{verbatim}Def Id[T : Star](x : T) : T = x\end{verbatim}

        Põhjuseks on see, et keelde on sisse ehitatud klassi \verb!Ring! esindaja täisarvude jaoks. Klass \verb!Ring! sisaldab muuhulgas meetodit \verb!Convert!, mis teisendab täisarvu ringi elemendiks. Täisarvude ringi korral on meetod \verb!Convert! ekvivalentne ühikfunktsiooniga, mistõttu ongi ühikfunktsioon keelde sisse ehitatud.
      \subsubsection{Täisarvude võrdlus ja aritmeetika}
        Keelde on sisse ehitatud klasside \verb!Ord! ja \verb!Ring! esindajad täisarvude jaoks. Lisaks on olemas ka funktsioonid \verb!Div! ja \verb!Mod!, mis annavad vastavalt täisarvulise jagamise jagatise ja jäägi. Turvalisuse huvides on mõlema funktsiooni tulemus \verb!Maybe! all juhuks kui jagaja on null.
      \subsubsection{Tähtede võrdlus}
        Keelde on sisse ehitatud klassi \verb!Ord! esindaja tähtede jaoks.
      \subsubsection{Täisarvude stringiks teisendamine}
        Keelde on sisse ehitatud klassi \verb!Writeable! esindaja täisarvude jaoks.
      \subsubsection{Defineerimata käitumine}
        Defineerimata käitumist saab märkida erilise muutuja abil, mille nimi on \verb!Crash!. \verb!Crash! on sarnane Haskelli \verb!undefined! muutujaga selle poolest, et mõlemad on parameetriliselt polümorfsed üle suvalise tüübi liigist \verb!*!, selleks et neid saaks panna suvalisse kohta veel kirjutamata kooditüki asenduseks, või luua funktsioone mille käitumine ongi osade argumendiväärtuste korral defineerimata.

        Käitumine väärtustamisel on aga erinev selle tõttu, et Haskell on laisk ja Awful on agar keel. Näiteks Haskelli avaldis \verb!fst (0, undefined)! annab \verb!0!, aga Awfuli analoogne avaldis \verb!First (Pair 0 Crash)! resulteerub tulemuses \verb!Crash!.
    \subsection{Definitsioonid ja esindajad}
      \markus{TODO}
      \subsubsection{Definitsioonid}
        
      \subsubsection{Esindajad}
        
    \subsection{Avaldised}
      \markus{TODO: tekst}
      \subsubsection{Lambda-avaldised}
        Funktsionaalse programmeerimiskeelena sisaldab Awful loomulikult lambda-avaldisi. Mustrisobituse võimalust funktsiooni argumentides ei ole veel teostatud, aga seda on tulevikus plaanis lisada. Süntaks on sarnane Haskelli omaga, selle vahega, et ei ole vajalik \verb!\! sümbol enne muutujanime. Toome siinkohal näite lambda-avaldist kasutavast funktsioonist.

        \begin{verbatim}Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>
  (x : F T, y : T) : F T =
    Fmap (z -> Multiply z y) x\end{verbatim}

        Seda funktsiooni saab kasutada korrutamaks paremalt konstandiga liste, vektoreid, maatrikseid ja teisi funktoreid.
      \subsubsection{Mustrisobitus}\label{match}
        Mustrisobitus töötab tähtede, täisarvude ja algebraliste andmetüüpide peal.

        \begin{verbatim}Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}\end{verbatim}

        Saab kirjutada ka \verb!Default! juhu, mida kasutatakse, kui ükski eelnev variant ei sobinud. See vaikevalik tuleb alati kirjutada mustrisobituse viimaseks juhuks.

        \begin{verbatim}Def Max[T : Star]<Ord T>(x : T, y : T) : T =
  Match Compare x y {LT -> y, Default -> x}\end{verbatim}

        Turvalisuse tagamiseks kontrollitakse iga \verb!Match! avaldise puhul, kas kõik võimalikud juhud on käsitletud. Kattuvad või puuduvad juhud annavad vea. See tähendab, et \verb!Default! juhtum on kohustuslik tähtede ja täisarvude mustrisobituses, ning ka algebraliste andmetüüpide jaoks juhul kui eelnevalt ei ole kõiki võimalikke juhtusid käsitlenud.

        Erinevalt Haskellist ei luba Awful kirjutada keerulisema struktuuriga mustrisobitust, näiteks sobitada sama \verb!Match! avaldisega tühja, 1-elemendilist ja 2-elemendilist listi. Sellise otsuse põhjuseks oli teostamise lihtsus.

        Samuti ei luba Awful \verb!Match! avaldist üle struktuuri (selle asemel tuleb kasutada väljade nimesid, ja tulevikus on plaanis lisada võimalus teha struktuuride mustrisobitust otse funktsiooni argumendis) ega üle hargneva andmetüübi (selle asemel on võimalik kasutada tüübiklasse viisil, mis on kirjeldatud alamjaotises~\ref{tyybiklassihakk}).
      \subsubsection{Tüübiklasside kasutamine tüübimuutujate mustrisobituseks}\label{tyybiklassihakk}
        
    \subsection{Teegid}
      
      \subsubsection{Standardteek}
        Standardteeki ei ole kohustuslik importida.
      \subsubsection{Algebrateek}
        
    \subsection{Interpretaatori kompileerimine ja kasutajaliides}
      Interpretaatori kompileerimiseks tuleb kompileerida fail \verb!Awful.hs!.

      \begin{verbatim}ghc Awful.hs\end{verbatim}

      Awful annab kasutajale kaks käsklust mida koodifailidele ja avaldistele rakendada: \verb!check!, mis teostab tüübikontrolli, ning \verb!eval!, mis väärtustab avaldise.

      Käsklus \verb!check! võtab argumendiks failinime ning tüübikontrollib mooduli ja kõik selle impordid.

      \begin{verbatim}./Awful check Standard.awf\end{verbatim}

      Käsklus \verb!eval! võtab argumendiks nimekirja failinimedest ja avaldise ning tüübikontrollib moodulid ja kõik nende impordid. Seejärel väärtustatakse avaldise keskkonnas, kuhu on lisatud kõik moodulitest saadud definitsioonid.

      \begin{verbatim}./Awful eval Standard.awf Algebra.awf "Pair Trivial (Complex 0 0)"\end{verbatim}

      Tulemus väljastatakse otse niiviisi, kuidas avaldised on väärtustajas sisemiselt esitatud. Tulemuste kasutajasõbralikumal kujul väljastamine on plaanis teostada tulevikus.
  \peatykk{Teostuse detailid}
    Keele Awful interpretaator on interpretaatori jaoks võrdlemisi tüüpilise arhitektuuriga, koosnedes lekserist, parserist, nimekontollijast, tüübikontrollijast ja väärtustajast. Lisaks on eraldi moodul, mis vastutab kasutajaliidese ja moodulisüsteemi eest. \markus{mis klasse, teeke jne kasutan?}
    \subsection{Parser}
      \markus{kirjutada Alternative klassi kohta, mida kasutan parsimiseks}
      \subsubsection{Aplikatiivne parsimine}
        
      \subsubsection{Monaadiline parsimine}
        
    \subsection{Tüübikontroll}
      Awful võimaldab andmetüüpe, klasse ning definitsioone ja esindajaid kirjutada ükskõik millises järjekorras, olenemata nende omavahelistest sõltuvustest. Selle tõttu läbib tüübikontrollija nii andmetüübid, klassid kui ka definitsioonid ja esindajad kaks korda.
      \subsubsection{Andmetüübid}
        
      \subsubsection{Klassid}
        
      \subsubsection{Definitsioonid ja esindajad}
        
    \subsection{Väärtustamine}
      Väärtustaja kasutab avaldisi, mille küljes ei ole tüübiinfot.
\begin{comment}
    Add_Int_expression_2 |
    Add_Int'_expression_2 Integer |
    Algebraic_expression_2 String [Expression_2] |
    Application_expression_2 Expression_2 Expression_2 |
    Field_expression_2 String |
    Function_expression_2 Pattern_0 Expression_2 |
    Match_expression_2 Expression_2 Matches_2 |
    Struct_expression_2 (Map' Expression_2) |
\end{comment}
      \subsubsection{Struktuurid}
        
      \subsubsection{Algebralised andmetüübid}
        Algebralise andmetüübi esitus väärtustajas on list väljade sisust, millele on lisatud konstruktori nimi. Konstruktori nimi on algebraliste andmetüüpide puhul erinevalt struktuurist vajalik, sest seda kasutatakse mustrisobitusel õige haru leidmiseks.
      \subsubsection{Defineerimata käitumine}
        Muutuja \verb!Crash! on keelde sisse ehitatud muutuja, mis esineb tüüpimiskeskkonnas, aga seda ei ole lisatud väärtustamiskeskkonda. Väärtustaja annab tulemuse \verb!Maybe! monaadi all, ning kui muutuja väärtustamiskeskkonnast leidmine ebaõnnestub (mis võib juhtuda ainult muutuja \verb!Crash! korral), antakse tulemuseks \verb!Nothing! ja kasutajale kuvatakse, et väärtustamise lõpptulemuseks oli \verb!Crash!.
      \subsubsection{Struktuuri väljade leidmine}
        
      \subsubsection{Mustrisobitus}
        
      \subsubsection{Lambda-avaldised}
        
      \subsubsection{Klasside meetodid}
        
    \subsection{Moodulisüsteem}
      
  \peatykk{Edasine töö}
    \subsection{Liik kui kategooria}
      ~\cite{Cat}.
    \subsection{Klass kui alamliik}
      
    \subsection{Kasutusmugavus}
      \markus{let-avaldis} Magistritöö mahu tõttu keskendus töö tüübiklasside ja edutamise arendamisele ning töö skoobist jäid välja mõned väikesed, keele võimalusi otseselt mitte laiendavad, aga kasutusmugavuse seisukohast olulised aspektid. Need on plaanis tulevikus teostada, et muuta keeles kirjutatud kood loetavamaks ja kasutajasõbralikumaks.
      \begin{itemize}
        \item
          Võimaldada eksplitsiitset tüübirakendamist, et säästa kasutajale liigsete abi-definitsioonide tegemise vaeva
      \end{itemize}
      \subsubsection{Operaatorid ja tüübioperaatorid}
        
      \subsubsection{Mustrisobitus funktsioonide argumentides}
        
      \subsubsection{Väärtustamise tulemuste trükkimine}
        Anda interpreteerimise tulemused prettyprinditud kujul (\verb!Writeable! klassi abil)
      \subsubsection{Tüübisünonüümid}
        
      \subsubsection{Tüübirakendamine}
        
    \subsection{???}
      \markus{Tüübiklassihäki eemaldamine}
    \subsection{Süntaksi kasutajapoolsete täienduste võimalus}
      
    \subsection{Jäägiklassikorpuste primitiiv}
      
\begin{comment}
operators
type operators (minimally for functions, either, pair).
abstract methods
move duplicate instance control into Naming module?
if-elif-else?
Class Test{T : Star} -> Class Test{_ : Star}
eta reduction warnings
unused type variable warnings
unused local variable warnings
add something for easily changing fields of structs?
internal: do something with old/new status tags. check where exactly they're necessary. get rid of them where they're useless
change semantics of missing pattern-match variables from blank to lambda? (Left -> e is not Left _ -> e but Left x -> e x)
internal: make the system of specifying built-in algebraic data types and things better and safer
Allow hiding things to functions outside module - so that helper functions are not exported from the module
normalising constructors for some data types (polynomial, fraction) which assume a certain normal form of fields?
allow to hide (prevent exporting) constructors and field accessors which can potentially have bad behavior
internal: remove locations from expressions except from lowest-level things where some checks are necessary (name)?
switch expression that is less strict and more flexible than match?
some limited pattern matching in function arguments (and maybe also variables introduced through algebraic matching?)
syntactic sugar for lists, vectors, matrices... allow writing (tiny, limited to expression parsing) language extensions?
fix the show-read issue; give a specific error for that (different errors for unresolved type variable and missing constr)
basic IO operations (output to console, read file, write file, append to file)
implement map and set (AVL trees?)
make match work with finite and char
different ways of folding lists, vectors, sets, maps etc
gather naming and type errors and give a list instead of returning only the first one?
enrich kind system via promotion
make match work with chars
make promotion for built-in ADT-s automatic
modify parser: make promotion of ints and chars to type level explicit (with !)
simplify hyperkind system because there's no need to keep anything but the number of arguments
modify flexible type variable name generation. use just numbers for everything? ("T0" - maybe name conflict with userdefined)
module system related functions into a separate file?
more detailed type errors (write which two types clashed)
type clash location?
write in error why exactly you need a class constraint (which name of a function caused it)?
write in error where the need for class constraint occurred?
make command line arguments nicer
check for free type variables after typechecking an expression. throw an error (they are a problem with type classes!)
remove promotion of primitives? it seems that without GADT-s they are pointless?
prettyprint evaluation results
case reduction warning (case x of c1 -> f y, c2 -> g y on sama mis (case x of c1 -> f, c2 -> g) y)
mis juhtub kui esimeses moodulis on kusagil tüübimuutuja T ja järgmises moodulis sama nimega globaalne tüüp?
mis juhtub kui meil on 2 klassi millel on vastastikune pärilussuhe? ega tüübikontroll tsüklisse ei jookse?
mis juhtub kui on klassid A, B<A> ja C<A> ja siis mingi funktsioon saab kitsendusteks B ja C
mis juhtub sellisel juhul: Class Foo{T : Star}(foo<Ring T> : T = Zero)
mis juhtub kui on selline pärilussuhe, et A eeldab A-d????
liigirakendamise eemaldamine liigituletuse kasuks (igal pool? teatud piiratud juhtudel?)
käskida kasutajal klasse kirjutada päriluse järjekorras? (väldiks ring-päriluse probleemi, võimaldaks klassid teha 1 passis)
kas tüübirakendamist on kusagil vaja?
Funktsioon mis leiab enniku pikkuse valesti (rekursioon kutsutakse välja sama pika või 1 võrra pikema peal) - mis juhtub?
char-i kirjutamine keelest ära võtta ja standardteeki panna
võimaldada suvalise arvu konstruktoritega algebralisi andmetüüpe. (LISAKS struktide allesjätmisele?)
\end{comment}
  \peatykk{Kokkuvõte}
    \markus{what did you do?}

    \markus{What are the results?}

    \markus{future work?}
  \newpage
  \bibliography{bachelor-thesis}
  \addcontentsline{toc}{section}{\refname}
  \peatykktarn{Litsents}
    \subsection*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele kättesaadavaks tegemiseks}
      Mina, \textbf{Liisi Kerik},

      \begin{enumerate}
        \item
          annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose

          \textbf{Funktsionaalse programmeerimiskeele liigisüsteem}

          mille juhendaja on Härmel Nestra

          \begin{enumerate}
            \item[1.1]
              reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni;
            \item[1.2]
              üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace´i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
          \end{enumerate}
        \item
          olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
        \item
          kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi. 
      \end{enumerate}

      \noindent
      Tartus, 21.05.2018
\end{document}